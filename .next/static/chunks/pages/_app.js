/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/_app"],{

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./node_modules/swiper/modules/effect-fade/effect-fade.min.css":
/*!*************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./node_modules/swiper/modules/effect-fade/effect-fade.min.css ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\n/* harmony import */ var _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".swiper-fade.swiper-free-mode .swiper-slide{transition-timing-function:ease-out}.swiper-fade .swiper-slide{pointer-events:none;transition-property:opacity}.swiper-fade .swiper-slide .swiper-slide{pointer-events:none}.swiper-fade .swiper-slide-active,.swiper-fade .swiper-slide-active .swiper-slide-active{pointer-events:auto}\", \"\",{\"version\":3,\"sources\":[\"webpack://node_modules/swiper/modules/effect-fade/effect-fade.min.css\"],\"names\":[],\"mappings\":\"AAAA,4CAA4C,mCAAmC,CAAC,2BAA2B,mBAAmB,CAAC,2BAA2B,CAAC,yCAAyC,mBAAmB,CAAC,yFAAyF,mBAAmB\",\"sourcesContent\":[\".swiper-fade.swiper-free-mode .swiper-slide{transition-timing-function:ease-out}.swiper-fade .swiper-slide{pointer-events:none;transition-property:opacity}.swiper-fade .swiper-slide .swiper-slide{pointer-events:none}.swiper-fade .swiper-slide-active,.swiper-fade .swiper-slide-active .swiper-slide-active{pointer-events:auto}\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls5XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOV0udXNlWzJdIS4vbm9kZV9tb2R1bGVzL3N3aXBlci9tb2R1bGVzL2VmZmVjdC1mYWRlL2VmZmVjdC1mYWRlLm1pbi5jc3MuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDaUg7QUFDakgsOEJBQThCLHFHQUEyQjtBQUN6RDtBQUNBLHNGQUFzRixvQ0FBb0MsMkJBQTJCLG9CQUFvQiw0QkFBNEIseUNBQXlDLG9CQUFvQix5RkFBeUYsb0JBQW9CLE9BQU8sK1FBQStRLG9DQUFvQywyQkFBMkIsb0JBQW9CLDRCQUE0Qix5Q0FBeUMsb0JBQW9CLHlGQUF5RixvQkFBb0IsbUJBQW1CO0FBQ2o3QjtBQUNBLCtEQUFlLHVCQUF1QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zd2lwZXIvbW9kdWxlcy9lZmZlY3QtZmFkZS9lZmZlY3QtZmFkZS5taW4uY3NzPzM2NGUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLnN3aXBlci1mYWRlLnN3aXBlci1mcmVlLW1vZGUgLnN3aXBlci1zbGlkZXt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjplYXNlLW91dH0uc3dpcGVyLWZhZGUgLnN3aXBlci1zbGlkZXtwb2ludGVyLWV2ZW50czpub25lO3RyYW5zaXRpb24tcHJvcGVydHk6b3BhY2l0eX0uc3dpcGVyLWZhZGUgLnN3aXBlci1zbGlkZSAuc3dpcGVyLXNsaWRle3BvaW50ZXItZXZlbnRzOm5vbmV9LnN3aXBlci1mYWRlIC5zd2lwZXItc2xpZGUtYWN0aXZlLC5zd2lwZXItZmFkZSAuc3dpcGVyLXNsaWRlLWFjdGl2ZSAuc3dpcGVyLXNsaWRlLWFjdGl2ZXtwb2ludGVyLWV2ZW50czphdXRvfVwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9ub2RlX21vZHVsZXMvc3dpcGVyL21vZHVsZXMvZWZmZWN0LWZhZGUvZWZmZWN0LWZhZGUubWluLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSw0Q0FBNEMsbUNBQW1DLENBQUMsMkJBQTJCLG1CQUFtQixDQUFDLDJCQUEyQixDQUFDLHlDQUF5QyxtQkFBbUIsQ0FBQyx5RkFBeUYsbUJBQW1CXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5zd2lwZXItZmFkZS5zd2lwZXItZnJlZS1tb2RlIC5zd2lwZXItc2xpZGV7dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246ZWFzZS1vdXR9LnN3aXBlci1mYWRlIC5zd2lwZXItc2xpZGV7cG9pbnRlci1ldmVudHM6bm9uZTt0cmFuc2l0aW9uLXByb3BlcnR5Om9wYWNpdHl9LnN3aXBlci1mYWRlIC5zd2lwZXItc2xpZGUgLnN3aXBlci1zbGlkZXtwb2ludGVyLWV2ZW50czpub25lfS5zd2lwZXItZmFkZSAuc3dpcGVyLXNsaWRlLWFjdGl2ZSwuc3dpcGVyLWZhZGUgLnN3aXBlci1zbGlkZS1hY3RpdmUgLnN3aXBlci1zbGlkZS1hY3RpdmV7cG9pbnRlci1ldmVudHM6YXV0b31cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./node_modules/swiper/modules/effect-fade/effect-fade.min.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./node_modules/swiper/modules/navigation/navigation.min.css":
/*!***********************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./node_modules/swiper/modules/navigation/navigation.min.css ***!
  \***********************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\n/* harmony import */ var _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \":root{--swiper-navigation-size:44px}.swiper-button-next,.swiper-button-prev{position:absolute;top:50%;width:calc(var(--swiper-navigation-size)/ 44 * 27);height:var(--swiper-navigation-size);margin-top:calc(0px - (var(--swiper-navigation-size)/ 2));z-index:10;cursor:pointer;display:flex;align-items:center;justify-content:center;color:var(--swiper-navigation-color,var(--swiper-theme-color))}.swiper-button-next.swiper-button-disabled,.swiper-button-prev.swiper-button-disabled{opacity:.35;cursor:auto;pointer-events:none}.swiper-button-next.swiper-button-hidden,.swiper-button-prev.swiper-button-hidden{opacity:0;cursor:auto;pointer-events:none}.swiper-navigation-disabled .swiper-button-next,.swiper-navigation-disabled .swiper-button-prev{display:none!important}.swiper-button-next:after,.swiper-button-prev:after{font-family:swiper-icons;font-size:var(--swiper-navigation-size);text-transform:none!important;letter-spacing:0;font-feature-settings:;font-variant:initial;line-height:1}.swiper-button-prev,.swiper-rtl .swiper-button-next{left:10px;right:auto}.swiper-button-prev:after,.swiper-rtl .swiper-button-next:after{content:'prev'}.swiper-button-next,.swiper-rtl .swiper-button-prev{right:10px;left:auto}.swiper-button-next:after,.swiper-rtl .swiper-button-prev:after{content:'next'}.swiper-button-lock{display:none}\", \"\",{\"version\":3,\"sources\":[\"webpack://node_modules/swiper/modules/navigation/navigation.min.css\"],\"names\":[],\"mappings\":\"AAAA,MAAM,6BAA6B,CAAC,wCAAwC,iBAAiB,CAAC,OAAO,CAAC,kDAAkD,CAAC,oCAAoC,CAAC,yDAAyD,CAAC,UAAU,CAAC,cAAc,CAAC,YAAY,CAAC,kBAAkB,CAAC,sBAAsB,CAAC,8DAA8D,CAAC,sFAAsF,WAAW,CAAC,WAAW,CAAC,mBAAmB,CAAC,kFAAkF,SAAS,CAAC,WAAW,CAAC,mBAAmB,CAAC,gGAAgG,sBAAsB,CAAC,oDAAoD,wBAAwB,CAAC,uCAAuC,CAAC,6BAA6B,CAAC,gBAAgB,CAAC,sBAAoB,CAApB,oBAAoB,CAAC,aAAa,CAAC,oDAAoD,SAAS,CAAC,UAAU,CAAC,gEAAgE,cAAc,CAAC,oDAAoD,UAAU,CAAC,SAAS,CAAC,gEAAgE,cAAc,CAAC,oBAAoB,YAAY\",\"sourcesContent\":[\":root{--swiper-navigation-size:44px}.swiper-button-next,.swiper-button-prev{position:absolute;top:50%;width:calc(var(--swiper-navigation-size)/ 44 * 27);height:var(--swiper-navigation-size);margin-top:calc(0px - (var(--swiper-navigation-size)/ 2));z-index:10;cursor:pointer;display:flex;align-items:center;justify-content:center;color:var(--swiper-navigation-color,var(--swiper-theme-color))}.swiper-button-next.swiper-button-disabled,.swiper-button-prev.swiper-button-disabled{opacity:.35;cursor:auto;pointer-events:none}.swiper-button-next.swiper-button-hidden,.swiper-button-prev.swiper-button-hidden{opacity:0;cursor:auto;pointer-events:none}.swiper-navigation-disabled .swiper-button-next,.swiper-navigation-disabled .swiper-button-prev{display:none!important}.swiper-button-next:after,.swiper-button-prev:after{font-family:swiper-icons;font-size:var(--swiper-navigation-size);text-transform:none!important;letter-spacing:0;font-variant:initial;line-height:1}.swiper-button-prev,.swiper-rtl .swiper-button-next{left:10px;right:auto}.swiper-button-prev:after,.swiper-rtl .swiper-button-next:after{content:'prev'}.swiper-button-next,.swiper-rtl .swiper-button-prev{right:10px;left:auto}.swiper-button-next:after,.swiper-rtl .swiper-button-prev:after{content:'next'}.swiper-button-lock{display:none}\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls5XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOV0udXNlWzJdIS4vbm9kZV9tb2R1bGVzL3N3aXBlci9tb2R1bGVzL25hdmlnYXRpb24vbmF2aWdhdGlvbi5taW4uY3NzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ2lIO0FBQ2pILDhCQUE4QixxR0FBMkI7QUFDekQ7QUFDQSxnREFBZ0QsOEJBQThCLHdDQUF3QyxrQkFBa0IsUUFBUSxtREFBbUQscUNBQXFDLDBEQUEwRCxXQUFXLGVBQWUsYUFBYSxtQkFBbUIsdUJBQXVCLCtEQUErRCxzRkFBc0YsWUFBWSxZQUFZLG9CQUFvQixrRkFBa0YsVUFBVSxZQUFZLG9CQUFvQixnR0FBZ0csdUJBQXVCLG9EQUFvRCx5QkFBeUIsd0NBQXdDLDhCQUE4QixpQkFBaUIsdUJBQXVCLHFCQUFxQixjQUFjLG9EQUFvRCxVQUFVLFdBQVcsZ0VBQWdFLGVBQWUsb0RBQW9ELFdBQVcsVUFBVSxnRUFBZ0UsZUFBZSxvQkFBb0IsYUFBYSxPQUFPLHVrQkFBdWtCLDhCQUE4Qix3Q0FBd0Msa0JBQWtCLFFBQVEsbURBQW1ELHFDQUFxQywwREFBMEQsV0FBVyxlQUFlLGFBQWEsbUJBQW1CLHVCQUF1QiwrREFBK0Qsc0ZBQXNGLFlBQVksWUFBWSxvQkFBb0Isa0ZBQWtGLFVBQVUsWUFBWSxvQkFBb0IsZ0dBQWdHLHVCQUF1QixvREFBb0QseUJBQXlCLHdDQUF3Qyw4QkFBOEIsaUJBQWlCLHFCQUFxQixjQUFjLG9EQUFvRCxVQUFVLFdBQVcsZ0VBQWdFLGVBQWUsb0RBQW9ELFdBQVcsVUFBVSxnRUFBZ0UsZUFBZSxvQkFBb0IsYUFBYSxtQkFBbUI7QUFDdHNHO0FBQ0EsK0RBQWUsdUJBQXVCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9tb2R1bGVzL25hdmlnYXRpb24vbmF2aWdhdGlvbi5taW4uY3NzP2RkYzgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiOnJvb3R7LS1zd2lwZXItbmF2aWdhdGlvbi1zaXplOjQ0cHh9LnN3aXBlci1idXR0b24tbmV4dCwuc3dpcGVyLWJ1dHRvbi1wcmV2e3Bvc2l0aW9uOmFic29sdXRlO3RvcDo1MCU7d2lkdGg6Y2FsYyh2YXIoLS1zd2lwZXItbmF2aWdhdGlvbi1zaXplKS8gNDQgKiAyNyk7aGVpZ2h0OnZhcigtLXN3aXBlci1uYXZpZ2F0aW9uLXNpemUpO21hcmdpbi10b3A6Y2FsYygwcHggLSAodmFyKC0tc3dpcGVyLW5hdmlnYXRpb24tc2l6ZSkvIDIpKTt6LWluZGV4OjEwO2N1cnNvcjpwb2ludGVyO2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjtjb2xvcjp2YXIoLS1zd2lwZXItbmF2aWdhdGlvbi1jb2xvcix2YXIoLS1zd2lwZXItdGhlbWUtY29sb3IpKX0uc3dpcGVyLWJ1dHRvbi1uZXh0LnN3aXBlci1idXR0b24tZGlzYWJsZWQsLnN3aXBlci1idXR0b24tcHJldi5zd2lwZXItYnV0dG9uLWRpc2FibGVke29wYWNpdHk6LjM1O2N1cnNvcjphdXRvO3BvaW50ZXItZXZlbnRzOm5vbmV9LnN3aXBlci1idXR0b24tbmV4dC5zd2lwZXItYnV0dG9uLWhpZGRlbiwuc3dpcGVyLWJ1dHRvbi1wcmV2LnN3aXBlci1idXR0b24taGlkZGVue29wYWNpdHk6MDtjdXJzb3I6YXV0bztwb2ludGVyLWV2ZW50czpub25lfS5zd2lwZXItbmF2aWdhdGlvbi1kaXNhYmxlZCAuc3dpcGVyLWJ1dHRvbi1uZXh0LC5zd2lwZXItbmF2aWdhdGlvbi1kaXNhYmxlZCAuc3dpcGVyLWJ1dHRvbi1wcmV2e2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9LnN3aXBlci1idXR0b24tbmV4dDphZnRlciwuc3dpcGVyLWJ1dHRvbi1wcmV2OmFmdGVye2ZvbnQtZmFtaWx5OnN3aXBlci1pY29ucztmb250LXNpemU6dmFyKC0tc3dpcGVyLW5hdmlnYXRpb24tc2l6ZSk7dGV4dC10cmFuc2Zvcm06bm9uZSFpbXBvcnRhbnQ7bGV0dGVyLXNwYWNpbmc6MDtmb250LWZlYXR1cmUtc2V0dGluZ3M6O2ZvbnQtdmFyaWFudDppbml0aWFsO2xpbmUtaGVpZ2h0OjF9LnN3aXBlci1idXR0b24tcHJldiwuc3dpcGVyLXJ0bCAuc3dpcGVyLWJ1dHRvbi1uZXh0e2xlZnQ6MTBweDtyaWdodDphdXRvfS5zd2lwZXItYnV0dG9uLXByZXY6YWZ0ZXIsLnN3aXBlci1ydGwgLnN3aXBlci1idXR0b24tbmV4dDphZnRlcntjb250ZW50OidwcmV2J30uc3dpcGVyLWJ1dHRvbi1uZXh0LC5zd2lwZXItcnRsIC5zd2lwZXItYnV0dG9uLXByZXZ7cmlnaHQ6MTBweDtsZWZ0OmF1dG99LnN3aXBlci1idXR0b24tbmV4dDphZnRlciwuc3dpcGVyLXJ0bCAuc3dpcGVyLWJ1dHRvbi1wcmV2OmFmdGVye2NvbnRlbnQ6J25leHQnfS5zd2lwZXItYnV0dG9uLWxvY2t7ZGlzcGxheTpub25lfVwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9ub2RlX21vZHVsZXMvc3dpcGVyL21vZHVsZXMvbmF2aWdhdGlvbi9uYXZpZ2F0aW9uLm1pbi5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEsTUFBTSw2QkFBNkIsQ0FBQyx3Q0FBd0MsaUJBQWlCLENBQUMsT0FBTyxDQUFDLGtEQUFrRCxDQUFDLG9DQUFvQyxDQUFDLHlEQUF5RCxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLGtCQUFrQixDQUFDLHNCQUFzQixDQUFDLDhEQUE4RCxDQUFDLHNGQUFzRixXQUFXLENBQUMsV0FBVyxDQUFDLG1CQUFtQixDQUFDLGtGQUFrRixTQUFTLENBQUMsV0FBVyxDQUFDLG1CQUFtQixDQUFDLGdHQUFnRyxzQkFBc0IsQ0FBQyxvREFBb0Qsd0JBQXdCLENBQUMsdUNBQXVDLENBQUMsNkJBQTZCLENBQUMsZ0JBQWdCLENBQUMsc0JBQW9CLENBQXBCLG9CQUFvQixDQUFDLGFBQWEsQ0FBQyxvREFBb0QsU0FBUyxDQUFDLFVBQVUsQ0FBQyxnRUFBZ0UsY0FBYyxDQUFDLG9EQUFvRCxVQUFVLENBQUMsU0FBUyxDQUFDLGdFQUFnRSxjQUFjLENBQUMsb0JBQW9CLFlBQVlcIixcInNvdXJjZXNDb250ZW50XCI6W1wiOnJvb3R7LS1zd2lwZXItbmF2aWdhdGlvbi1zaXplOjQ0cHh9LnN3aXBlci1idXR0b24tbmV4dCwuc3dpcGVyLWJ1dHRvbi1wcmV2e3Bvc2l0aW9uOmFic29sdXRlO3RvcDo1MCU7d2lkdGg6Y2FsYyh2YXIoLS1zd2lwZXItbmF2aWdhdGlvbi1zaXplKS8gNDQgKiAyNyk7aGVpZ2h0OnZhcigtLXN3aXBlci1uYXZpZ2F0aW9uLXNpemUpO21hcmdpbi10b3A6Y2FsYygwcHggLSAodmFyKC0tc3dpcGVyLW5hdmlnYXRpb24tc2l6ZSkvIDIpKTt6LWluZGV4OjEwO2N1cnNvcjpwb2ludGVyO2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjtjb2xvcjp2YXIoLS1zd2lwZXItbmF2aWdhdGlvbi1jb2xvcix2YXIoLS1zd2lwZXItdGhlbWUtY29sb3IpKX0uc3dpcGVyLWJ1dHRvbi1uZXh0LnN3aXBlci1idXR0b24tZGlzYWJsZWQsLnN3aXBlci1idXR0b24tcHJldi5zd2lwZXItYnV0dG9uLWRpc2FibGVke29wYWNpdHk6LjM1O2N1cnNvcjphdXRvO3BvaW50ZXItZXZlbnRzOm5vbmV9LnN3aXBlci1idXR0b24tbmV4dC5zd2lwZXItYnV0dG9uLWhpZGRlbiwuc3dpcGVyLWJ1dHRvbi1wcmV2LnN3aXBlci1idXR0b24taGlkZGVue29wYWNpdHk6MDtjdXJzb3I6YXV0bztwb2ludGVyLWV2ZW50czpub25lfS5zd2lwZXItbmF2aWdhdGlvbi1kaXNhYmxlZCAuc3dpcGVyLWJ1dHRvbi1uZXh0LC5zd2lwZXItbmF2aWdhdGlvbi1kaXNhYmxlZCAuc3dpcGVyLWJ1dHRvbi1wcmV2e2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9LnN3aXBlci1idXR0b24tbmV4dDphZnRlciwuc3dpcGVyLWJ1dHRvbi1wcmV2OmFmdGVye2ZvbnQtZmFtaWx5OnN3aXBlci1pY29ucztmb250LXNpemU6dmFyKC0tc3dpcGVyLW5hdmlnYXRpb24tc2l6ZSk7dGV4dC10cmFuc2Zvcm06bm9uZSFpbXBvcnRhbnQ7bGV0dGVyLXNwYWNpbmc6MDtmb250LXZhcmlhbnQ6aW5pdGlhbDtsaW5lLWhlaWdodDoxfS5zd2lwZXItYnV0dG9uLXByZXYsLnN3aXBlci1ydGwgLnN3aXBlci1idXR0b24tbmV4dHtsZWZ0OjEwcHg7cmlnaHQ6YXV0b30uc3dpcGVyLWJ1dHRvbi1wcmV2OmFmdGVyLC5zd2lwZXItcnRsIC5zd2lwZXItYnV0dG9uLW5leHQ6YWZ0ZXJ7Y29udGVudDoncHJldid9LnN3aXBlci1idXR0b24tbmV4dCwuc3dpcGVyLXJ0bCAuc3dpcGVyLWJ1dHRvbi1wcmV2e3JpZ2h0OjEwcHg7bGVmdDphdXRvfS5zd2lwZXItYnV0dG9uLW5leHQ6YWZ0ZXIsLnN3aXBlci1ydGwgLnN3aXBlci1idXR0b24tcHJldjphZnRlcntjb250ZW50OiduZXh0J30uc3dpcGVyLWJ1dHRvbi1sb2Nre2Rpc3BsYXk6bm9uZX1cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./node_modules/swiper/modules/navigation/navigation.min.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./node_modules/swiper/modules/pagination/pagination.min.css":
/*!***********************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./node_modules/swiper/modules/pagination/pagination.min.css ***!
  \***********************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\n/* harmony import */ var _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".swiper-pagination{position:absolute;text-align:center;transition:.3s opacity;transform:translate3d(0,0,0);z-index:10}.swiper-pagination.swiper-pagination-hidden{opacity:0}.swiper-pagination-disabled>.swiper-pagination,.swiper-pagination.swiper-pagination-disabled{display:none!important}.swiper-horizontal>.swiper-pagination-bullets,.swiper-pagination-bullets.swiper-pagination-horizontal,.swiper-pagination-custom,.swiper-pagination-fraction{bottom:10px;left:0;width:100%}.swiper-pagination-bullets-dynamic{overflow:hidden;font-size:0}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transform:scale(.33);position:relative}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev{transform:scale(.33)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next{transform:scale(.33)}.swiper-pagination-bullet{width:var(--swiper-pagination-bullet-width,var(--swiper-pagination-bullet-size,8px));height:var(--swiper-pagination-bullet-height,var(--swiper-pagination-bullet-size,8px));display:inline-block;border-radius:50%;background:var(--swiper-pagination-bullet-inactive-color,#000);opacity:var(--swiper-pagination-bullet-inactive-opacity, .2)}button.swiper-pagination-bullet{border:none;margin:0;padding:0;box-shadow:none;-webkit-appearance:none;-moz-appearance:none;appearance:none}.swiper-pagination-clickable .swiper-pagination-bullet{cursor:pointer}.swiper-pagination-bullet:only-child{display:none!important}.swiper-pagination-bullet-active{opacity:var(--swiper-pagination-bullet-opacity, 1);background:var(--swiper-pagination-color,var(--swiper-theme-color))}.swiper-pagination-vertical.swiper-pagination-bullets,.swiper-vertical>.swiper-pagination-bullets{right:10px;top:50%;transform:translate3d(0px,-50%,0)}.swiper-pagination-vertical.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets .swiper-pagination-bullet{margin:var(--swiper-pagination-bullet-vertical-gap,6px) 0;display:block}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{top:50%;transform:translateY(-50%);width:8px}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{display:inline-block;transition:.2s transform,.2s top}.swiper-horizontal>.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets .swiper-pagination-bullet{margin:0 var(--swiper-pagination-bullet-horizontal-gap,4px)}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{left:50%;transform:translateX(-50%);white-space:nowrap}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s left}.swiper-horizontal.swiper-rtl>.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s right}.swiper-pagination-progressbar{background:rgba(0,0,0,.25);position:absolute}.swiper-pagination-progressbar .swiper-pagination-progressbar-fill{background:var(--swiper-pagination-color,var(--swiper-theme-color));position:absolute;left:0;top:0;width:100%;height:100%;transform:scale(0);transform-origin:left top}.swiper-rtl .swiper-pagination-progressbar .swiper-pagination-progressbar-fill{transform-origin:right top}.swiper-horizontal>.swiper-pagination-progressbar,.swiper-pagination-progressbar.swiper-pagination-horizontal,.swiper-pagination-progressbar.swiper-pagination-vertical.swiper-pagination-progressbar-opposite,.swiper-vertical>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite{width:100%;height:4px;left:0;top:0}.swiper-horizontal>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-horizontal.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-vertical,.swiper-vertical>.swiper-pagination-progressbar{width:4px;height:100%;left:0;top:0}.swiper-pagination-lock{display:none}\", \"\",{\"version\":3,\"sources\":[\"webpack://node_modules/swiper/modules/pagination/pagination.min.css\"],\"names\":[],\"mappings\":\"AAAA,mBAAmB,iBAAiB,CAAC,iBAAiB,CAAC,sBAAsB,CAAC,4BAA4B,CAAC,UAAU,CAAC,4CAA4C,SAAS,CAAC,6FAA6F,sBAAsB,CAAC,4JAA4J,WAAW,CAAC,MAAM,CAAC,UAAU,CAAC,mCAAmC,eAAe,CAAC,WAAW,CAAC,6DAA6D,oBAAoB,CAAC,iBAAiB,CAAC,oEAAoE,kBAAkB,CAAC,yEAAyE,kBAAkB,CAAC,yEAAyE,oBAAoB,CAAC,8EAA8E,oBAAoB,CAAC,yEAAyE,oBAAoB,CAAC,8EAA8E,oBAAoB,CAAC,0BAA0B,oFAAoF,CAAC,sFAAsF,CAAC,oBAAoB,CAAC,iBAAiB,CAAC,8DAA8D,CAAC,4DAA4D,CAAC,gCAAgC,WAAW,CAAC,QAAQ,CAAC,SAAS,CAAC,eAAe,CAAC,uBAAuB,CAAC,oBAAc,CAAd,eAAe,CAAC,uDAAuD,cAAc,CAAC,qCAAqC,sBAAsB,CAAC,iCAAiC,kDAAkD,CAAC,mEAAmE,CAAC,kGAAkG,UAAU,CAAC,OAAO,CAAC,iCAAiC,CAAC,sJAAsJ,yDAAyD,CAAC,aAAa,CAAC,sKAAsK,OAAO,CAAC,0BAA0B,CAAC,SAAS,CAAC,0NAA0N,oBAAoB,CAAC,gCAAgC,CAAC,0JAA0J,2DAA2D,CAAC,0KAA0K,QAAQ,CAAC,0BAA0B,CAAC,kBAAkB,CAAC,8NAA8N,iCAAiC,CAAC,2FAA2F,kCAAkC,CAAC,+BAA+B,0BAA0B,CAAC,iBAAiB,CAAC,mEAAmE,mEAAmE,CAAC,iBAAiB,CAAC,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC,WAAW,CAAC,kBAAkB,CAAC,yBAAyB,CAAC,+EAA+E,0BAA0B,CAAC,sSAAsS,UAAU,CAAC,UAAU,CAAC,MAAM,CAAC,KAAK,CAAC,sSAAsS,SAAS,CAAC,WAAW,CAAC,MAAM,CAAC,KAAK,CAAC,wBAAwB,YAAY\",\"sourcesContent\":[\".swiper-pagination{position:absolute;text-align:center;transition:.3s opacity;transform:translate3d(0,0,0);z-index:10}.swiper-pagination.swiper-pagination-hidden{opacity:0}.swiper-pagination-disabled>.swiper-pagination,.swiper-pagination.swiper-pagination-disabled{display:none!important}.swiper-horizontal>.swiper-pagination-bullets,.swiper-pagination-bullets.swiper-pagination-horizontal,.swiper-pagination-custom,.swiper-pagination-fraction{bottom:10px;left:0;width:100%}.swiper-pagination-bullets-dynamic{overflow:hidden;font-size:0}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transform:scale(.33);position:relative}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev{transform:scale(.33)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next{transform:scale(.33)}.swiper-pagination-bullet{width:var(--swiper-pagination-bullet-width,var(--swiper-pagination-bullet-size,8px));height:var(--swiper-pagination-bullet-height,var(--swiper-pagination-bullet-size,8px));display:inline-block;border-radius:50%;background:var(--swiper-pagination-bullet-inactive-color,#000);opacity:var(--swiper-pagination-bullet-inactive-opacity, .2)}button.swiper-pagination-bullet{border:none;margin:0;padding:0;box-shadow:none;-webkit-appearance:none;appearance:none}.swiper-pagination-clickable .swiper-pagination-bullet{cursor:pointer}.swiper-pagination-bullet:only-child{display:none!important}.swiper-pagination-bullet-active{opacity:var(--swiper-pagination-bullet-opacity, 1);background:var(--swiper-pagination-color,var(--swiper-theme-color))}.swiper-pagination-vertical.swiper-pagination-bullets,.swiper-vertical>.swiper-pagination-bullets{right:10px;top:50%;transform:translate3d(0px,-50%,0)}.swiper-pagination-vertical.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets .swiper-pagination-bullet{margin:var(--swiper-pagination-bullet-vertical-gap,6px) 0;display:block}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{top:50%;transform:translateY(-50%);width:8px}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{display:inline-block;transition:.2s transform,.2s top}.swiper-horizontal>.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets .swiper-pagination-bullet{margin:0 var(--swiper-pagination-bullet-horizontal-gap,4px)}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{left:50%;transform:translateX(-50%);white-space:nowrap}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s left}.swiper-horizontal.swiper-rtl>.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s right}.swiper-pagination-progressbar{background:rgba(0,0,0,.25);position:absolute}.swiper-pagination-progressbar .swiper-pagination-progressbar-fill{background:var(--swiper-pagination-color,var(--swiper-theme-color));position:absolute;left:0;top:0;width:100%;height:100%;transform:scale(0);transform-origin:left top}.swiper-rtl .swiper-pagination-progressbar .swiper-pagination-progressbar-fill{transform-origin:right top}.swiper-horizontal>.swiper-pagination-progressbar,.swiper-pagination-progressbar.swiper-pagination-horizontal,.swiper-pagination-progressbar.swiper-pagination-vertical.swiper-pagination-progressbar-opposite,.swiper-vertical>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite{width:100%;height:4px;left:0;top:0}.swiper-horizontal>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-horizontal.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-vertical,.swiper-vertical>.swiper-pagination-progressbar{width:4px;height:100%;left:0;top:0}.swiper-pagination-lock{display:none}\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls5XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOV0udXNlWzJdIS4vbm9kZV9tb2R1bGVzL3N3aXBlci9tb2R1bGVzL3BhZ2luYXRpb24vcGFnaW5hdGlvbi5taW4uY3NzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ2lIO0FBQ2pILDhCQUE4QixxR0FBMkI7QUFDekQ7QUFDQSw2REFBNkQsa0JBQWtCLGtCQUFrQix1QkFBdUIsNkJBQTZCLFdBQVcsNENBQTRDLFVBQVUsNkZBQTZGLHVCQUF1Qiw0SkFBNEosWUFBWSxPQUFPLFdBQVcsbUNBQW1DLGdCQUFnQixZQUFZLDZEQUE2RCxxQkFBcUIsa0JBQWtCLG9FQUFvRSxtQkFBbUIseUVBQXlFLG1CQUFtQix5RUFBeUUscUJBQXFCLDhFQUE4RSxxQkFBcUIseUVBQXlFLHFCQUFxQiw4RUFBOEUscUJBQXFCLDBCQUEwQixxRkFBcUYsdUZBQXVGLHFCQUFxQixrQkFBa0IsK0RBQStELDZEQUE2RCxnQ0FBZ0MsWUFBWSxTQUFTLFVBQVUsZ0JBQWdCLHdCQUF3QixxQkFBcUIsZ0JBQWdCLHVEQUF1RCxlQUFlLHFDQUFxQyx1QkFBdUIsaUNBQWlDLG1EQUFtRCxvRUFBb0Usa0dBQWtHLFdBQVcsUUFBUSxrQ0FBa0Msc0pBQXNKLDBEQUEwRCxjQUFjLHNLQUFzSyxRQUFRLDJCQUEyQixVQUFVLDBOQUEwTixxQkFBcUIsaUNBQWlDLDBKQUEwSiw0REFBNEQsMEtBQTBLLFNBQVMsMkJBQTJCLG1CQUFtQiw4TkFBOE4sa0NBQWtDLDJGQUEyRixtQ0FBbUMsK0JBQStCLDJCQUEyQixrQkFBa0IsbUVBQW1FLG9FQUFvRSxrQkFBa0IsT0FBTyxNQUFNLFdBQVcsWUFBWSxtQkFBbUIsMEJBQTBCLCtFQUErRSwyQkFBMkIsc1NBQXNTLFdBQVcsV0FBVyxPQUFPLE1BQU0sc1NBQXNTLFVBQVUsWUFBWSxPQUFPLE1BQU0sd0JBQXdCLGFBQWEsT0FBTyxncUNBQWdxQyxrQkFBa0Isa0JBQWtCLHVCQUF1Qiw2QkFBNkIsV0FBVyw0Q0FBNEMsVUFBVSw2RkFBNkYsdUJBQXVCLDRKQUE0SixZQUFZLE9BQU8sV0FBVyxtQ0FBbUMsZ0JBQWdCLFlBQVksNkRBQTZELHFCQUFxQixrQkFBa0Isb0VBQW9FLG1CQUFtQix5RUFBeUUsbUJBQW1CLHlFQUF5RSxxQkFBcUIsOEVBQThFLHFCQUFxQix5RUFBeUUscUJBQXFCLDhFQUE4RSxxQkFBcUIsMEJBQTBCLHFGQUFxRix1RkFBdUYscUJBQXFCLGtCQUFrQiwrREFBK0QsNkRBQTZELGdDQUFnQyxZQUFZLFNBQVMsVUFBVSxnQkFBZ0Isd0JBQXdCLGdCQUFnQix1REFBdUQsZUFBZSxxQ0FBcUMsdUJBQXVCLGlDQUFpQyxtREFBbUQsb0VBQW9FLGtHQUFrRyxXQUFXLFFBQVEsa0NBQWtDLHNKQUFzSiwwREFBMEQsY0FBYyxzS0FBc0ssUUFBUSwyQkFBMkIsVUFBVSwwTkFBME4scUJBQXFCLGlDQUFpQywwSkFBMEosNERBQTRELDBLQUEwSyxTQUFTLDJCQUEyQixtQkFBbUIsOE5BQThOLGtDQUFrQywyRkFBMkYsbUNBQW1DLCtCQUErQiwyQkFBMkIsa0JBQWtCLG1FQUFtRSxvRUFBb0Usa0JBQWtCLE9BQU8sTUFBTSxXQUFXLFlBQVksbUJBQW1CLDBCQUEwQiwrRUFBK0UsMkJBQTJCLHNTQUFzUyxXQUFXLFdBQVcsT0FBTyxNQUFNLHNTQUFzUyxVQUFVLFlBQVksT0FBTyxNQUFNLHdCQUF3QixhQUFhLG1CQUFtQjtBQUN0Z1Y7QUFDQSwrREFBZSx1QkFBdUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc3dpcGVyL21vZHVsZXMvcGFnaW5hdGlvbi9wYWdpbmF0aW9uLm1pbi5jc3M/Mjg1NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIuc3dpcGVyLXBhZ2luYXRpb257cG9zaXRpb246YWJzb2x1dGU7dGV4dC1hbGlnbjpjZW50ZXI7dHJhbnNpdGlvbjouM3Mgb3BhY2l0eTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDApO3otaW5kZXg6MTB9LnN3aXBlci1wYWdpbmF0aW9uLnN3aXBlci1wYWdpbmF0aW9uLWhpZGRlbntvcGFjaXR5OjB9LnN3aXBlci1wYWdpbmF0aW9uLWRpc2FibGVkPi5zd2lwZXItcGFnaW5hdGlvbiwuc3dpcGVyLXBhZ2luYXRpb24uc3dpcGVyLXBhZ2luYXRpb24tZGlzYWJsZWR7ZGlzcGxheTpub25lIWltcG9ydGFudH0uc3dpcGVyLWhvcml6b250YWw+LnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHMsLnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHMuc3dpcGVyLXBhZ2luYXRpb24taG9yaXpvbnRhbCwuc3dpcGVyLXBhZ2luYXRpb24tY3VzdG9tLC5zd2lwZXItcGFnaW5hdGlvbi1mcmFjdGlvbntib3R0b206MTBweDtsZWZ0OjA7d2lkdGg6MTAwJX0uc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0cy1keW5hbWlje292ZXJmbG93OmhpZGRlbjtmb250LXNpemU6MH0uc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0cy1keW5hbWljIC5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXR7dHJhbnNmb3JtOnNjYWxlKC4zMyk7cG9zaXRpb246cmVsYXRpdmV9LnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHMtZHluYW1pYyAuc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0LWFjdGl2ZXt0cmFuc2Zvcm06c2NhbGUoMSl9LnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHMtZHluYW1pYyAuc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0LWFjdGl2ZS1tYWlue3RyYW5zZm9ybTpzY2FsZSgxKX0uc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0cy1keW5hbWljIC5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXQtYWN0aXZlLXByZXZ7dHJhbnNmb3JtOnNjYWxlKC42Nil9LnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHMtZHluYW1pYyAuc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0LWFjdGl2ZS1wcmV2LXByZXZ7dHJhbnNmb3JtOnNjYWxlKC4zMyl9LnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHMtZHluYW1pYyAuc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0LWFjdGl2ZS1uZXh0e3RyYW5zZm9ybTpzY2FsZSguNjYpfS5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXRzLWR5bmFtaWMgLnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldC1hY3RpdmUtbmV4dC1uZXh0e3RyYW5zZm9ybTpzY2FsZSguMzMpfS5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXR7d2lkdGg6dmFyKC0tc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0LXdpZHRoLHZhcigtLXN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldC1zaXplLDhweCkpO2hlaWdodDp2YXIoLS1zd2lwZXItcGFnaW5hdGlvbi1idWxsZXQtaGVpZ2h0LHZhcigtLXN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldC1zaXplLDhweCkpO2Rpc3BsYXk6aW5saW5lLWJsb2NrO2JvcmRlci1yYWRpdXM6NTAlO2JhY2tncm91bmQ6dmFyKC0tc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0LWluYWN0aXZlLWNvbG9yLCMwMDApO29wYWNpdHk6dmFyKC0tc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0LWluYWN0aXZlLW9wYWNpdHksIC4yKX1idXR0b24uc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0e2JvcmRlcjpub25lO21hcmdpbjowO3BhZGRpbmc6MDtib3gtc2hhZG93Om5vbmU7LXdlYmtpdC1hcHBlYXJhbmNlOm5vbmU7LW1vei1hcHBlYXJhbmNlOm5vbmU7YXBwZWFyYW5jZTpub25lfS5zd2lwZXItcGFnaW5hdGlvbi1jbGlja2FibGUgLnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHtjdXJzb3I6cG9pbnRlcn0uc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0Om9ubHktY2hpbGR7ZGlzcGxheTpub25lIWltcG9ydGFudH0uc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0LWFjdGl2ZXtvcGFjaXR5OnZhcigtLXN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldC1vcGFjaXR5LCAxKTtiYWNrZ3JvdW5kOnZhcigtLXN3aXBlci1wYWdpbmF0aW9uLWNvbG9yLHZhcigtLXN3aXBlci10aGVtZS1jb2xvcikpfS5zd2lwZXItcGFnaW5hdGlvbi12ZXJ0aWNhbC5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXRzLC5zd2lwZXItdmVydGljYWw+LnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHN7cmlnaHQ6MTBweDt0b3A6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwcHgsLTUwJSwwKX0uc3dpcGVyLXBhZ2luYXRpb24tdmVydGljYWwuc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0cyAuc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0LC5zd2lwZXItdmVydGljYWw+LnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHMgLnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHttYXJnaW46dmFyKC0tc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0LXZlcnRpY2FsLWdhcCw2cHgpIDA7ZGlzcGxheTpibG9ja30uc3dpcGVyLXBhZ2luYXRpb24tdmVydGljYWwuc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0cy5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXRzLWR5bmFtaWMsLnN3aXBlci12ZXJ0aWNhbD4uc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0cy5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXRzLWR5bmFtaWN7dG9wOjUwJTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKTt3aWR0aDo4cHh9LnN3aXBlci1wYWdpbmF0aW9uLXZlcnRpY2FsLnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHMuc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0cy1keW5hbWljIC5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXQsLnN3aXBlci12ZXJ0aWNhbD4uc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0cy5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXRzLWR5bmFtaWMgLnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHtkaXNwbGF5OmlubGluZS1ibG9jazt0cmFuc2l0aW9uOi4ycyB0cmFuc2Zvcm0sLjJzIHRvcH0uc3dpcGVyLWhvcml6b250YWw+LnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHMgLnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldCwuc3dpcGVyLXBhZ2luYXRpb24taG9yaXpvbnRhbC5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXRzIC5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXR7bWFyZ2luOjAgdmFyKC0tc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0LWhvcml6b250YWwtZ2FwLDRweCl9LnN3aXBlci1ob3Jpem9udGFsPi5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXRzLnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHMtZHluYW1pYywuc3dpcGVyLXBhZ2luYXRpb24taG9yaXpvbnRhbC5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXRzLnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHMtZHluYW1pY3tsZWZ0OjUwJTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKTt3aGl0ZS1zcGFjZTpub3dyYXB9LnN3aXBlci1ob3Jpem9udGFsPi5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXRzLnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHMtZHluYW1pYyAuc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0LC5zd2lwZXItcGFnaW5hdGlvbi1ob3Jpem9udGFsLnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHMuc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0cy1keW5hbWljIC5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXR7dHJhbnNpdGlvbjouMnMgdHJhbnNmb3JtLC4ycyBsZWZ0fS5zd2lwZXItaG9yaXpvbnRhbC5zd2lwZXItcnRsPi5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXRzLWR5bmFtaWMgLnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHt0cmFuc2l0aW9uOi4ycyB0cmFuc2Zvcm0sLjJzIHJpZ2h0fS5zd2lwZXItcGFnaW5hdGlvbi1wcm9ncmVzc2JhcntiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsLjI1KTtwb3NpdGlvbjphYnNvbHV0ZX0uc3dpcGVyLXBhZ2luYXRpb24tcHJvZ3Jlc3NiYXIgLnN3aXBlci1wYWdpbmF0aW9uLXByb2dyZXNzYmFyLWZpbGx7YmFja2dyb3VuZDp2YXIoLS1zd2lwZXItcGFnaW5hdGlvbi1jb2xvcix2YXIoLS1zd2lwZXItdGhlbWUtY29sb3IpKTtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7dG9wOjA7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTt0cmFuc2Zvcm06c2NhbGUoMCk7dHJhbnNmb3JtLW9yaWdpbjpsZWZ0IHRvcH0uc3dpcGVyLXJ0bCAuc3dpcGVyLXBhZ2luYXRpb24tcHJvZ3Jlc3NiYXIgLnN3aXBlci1wYWdpbmF0aW9uLXByb2dyZXNzYmFyLWZpbGx7dHJhbnNmb3JtLW9yaWdpbjpyaWdodCB0b3B9LnN3aXBlci1ob3Jpem9udGFsPi5zd2lwZXItcGFnaW5hdGlvbi1wcm9ncmVzc2Jhciwuc3dpcGVyLXBhZ2luYXRpb24tcHJvZ3Jlc3NiYXIuc3dpcGVyLXBhZ2luYXRpb24taG9yaXpvbnRhbCwuc3dpcGVyLXBhZ2luYXRpb24tcHJvZ3Jlc3NiYXIuc3dpcGVyLXBhZ2luYXRpb24tdmVydGljYWwuc3dpcGVyLXBhZ2luYXRpb24tcHJvZ3Jlc3NiYXItb3Bwb3NpdGUsLnN3aXBlci12ZXJ0aWNhbD4uc3dpcGVyLXBhZ2luYXRpb24tcHJvZ3Jlc3NiYXIuc3dpcGVyLXBhZ2luYXRpb24tcHJvZ3Jlc3NiYXItb3Bwb3NpdGV7d2lkdGg6MTAwJTtoZWlnaHQ6NHB4O2xlZnQ6MDt0b3A6MH0uc3dpcGVyLWhvcml6b250YWw+LnN3aXBlci1wYWdpbmF0aW9uLXByb2dyZXNzYmFyLnN3aXBlci1wYWdpbmF0aW9uLXByb2dyZXNzYmFyLW9wcG9zaXRlLC5zd2lwZXItcGFnaW5hdGlvbi1wcm9ncmVzc2Jhci5zd2lwZXItcGFnaW5hdGlvbi1ob3Jpem9udGFsLnN3aXBlci1wYWdpbmF0aW9uLXByb2dyZXNzYmFyLW9wcG9zaXRlLC5zd2lwZXItcGFnaW5hdGlvbi1wcm9ncmVzc2Jhci5zd2lwZXItcGFnaW5hdGlvbi12ZXJ0aWNhbCwuc3dpcGVyLXZlcnRpY2FsPi5zd2lwZXItcGFnaW5hdGlvbi1wcm9ncmVzc2Jhcnt3aWR0aDo0cHg7aGVpZ2h0OjEwMCU7bGVmdDowO3RvcDowfS5zd2lwZXItcGFnaW5hdGlvbi1sb2Nre2Rpc3BsYXk6bm9uZX1cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vbm9kZV9tb2R1bGVzL3N3aXBlci9tb2R1bGVzL3BhZ2luYXRpb24vcGFnaW5hdGlvbi5taW4uY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBLG1CQUFtQixpQkFBaUIsQ0FBQyxpQkFBaUIsQ0FBQyxzQkFBc0IsQ0FBQyw0QkFBNEIsQ0FBQyxVQUFVLENBQUMsNENBQTRDLFNBQVMsQ0FBQyw2RkFBNkYsc0JBQXNCLENBQUMsNEpBQTRKLFdBQVcsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLG1DQUFtQyxlQUFlLENBQUMsV0FBVyxDQUFDLDZEQUE2RCxvQkFBb0IsQ0FBQyxpQkFBaUIsQ0FBQyxvRUFBb0Usa0JBQWtCLENBQUMseUVBQXlFLGtCQUFrQixDQUFDLHlFQUF5RSxvQkFBb0IsQ0FBQyw4RUFBOEUsb0JBQW9CLENBQUMseUVBQXlFLG9CQUFvQixDQUFDLDhFQUE4RSxvQkFBb0IsQ0FBQywwQkFBMEIsb0ZBQW9GLENBQUMsc0ZBQXNGLENBQUMsb0JBQW9CLENBQUMsaUJBQWlCLENBQUMsOERBQThELENBQUMsNERBQTRELENBQUMsZ0NBQWdDLFdBQVcsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLGVBQWUsQ0FBQyx1QkFBdUIsQ0FBQyxvQkFBYyxDQUFkLGVBQWUsQ0FBQyx1REFBdUQsY0FBYyxDQUFDLHFDQUFxQyxzQkFBc0IsQ0FBQyxpQ0FBaUMsa0RBQWtELENBQUMsbUVBQW1FLENBQUMsa0dBQWtHLFVBQVUsQ0FBQyxPQUFPLENBQUMsaUNBQWlDLENBQUMsc0pBQXNKLHlEQUF5RCxDQUFDLGFBQWEsQ0FBQyxzS0FBc0ssT0FBTyxDQUFDLDBCQUEwQixDQUFDLFNBQVMsQ0FBQywwTkFBME4sb0JBQW9CLENBQUMsZ0NBQWdDLENBQUMsMEpBQTBKLDJEQUEyRCxDQUFDLDBLQUEwSyxRQUFRLENBQUMsMEJBQTBCLENBQUMsa0JBQWtCLENBQUMsOE5BQThOLGlDQUFpQyxDQUFDLDJGQUEyRixrQ0FBa0MsQ0FBQywrQkFBK0IsMEJBQTBCLENBQUMsaUJBQWlCLENBQUMsbUVBQW1FLG1FQUFtRSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxrQkFBa0IsQ0FBQyx5QkFBeUIsQ0FBQywrRUFBK0UsMEJBQTBCLENBQUMsc1NBQXNTLFVBQVUsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxzU0FBc1MsU0FBUyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLHdCQUF3QixZQUFZXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5zd2lwZXItcGFnaW5hdGlvbntwb3NpdGlvbjphYnNvbHV0ZTt0ZXh0LWFsaWduOmNlbnRlcjt0cmFuc2l0aW9uOi4zcyBvcGFjaXR5O3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDAsMCk7ei1pbmRleDoxMH0uc3dpcGVyLXBhZ2luYXRpb24uc3dpcGVyLXBhZ2luYXRpb24taGlkZGVue29wYWNpdHk6MH0uc3dpcGVyLXBhZ2luYXRpb24tZGlzYWJsZWQ+LnN3aXBlci1wYWdpbmF0aW9uLC5zd2lwZXItcGFnaW5hdGlvbi5zd2lwZXItcGFnaW5hdGlvbi1kaXNhYmxlZHtkaXNwbGF5Om5vbmUhaW1wb3J0YW50fS5zd2lwZXItaG9yaXpvbnRhbD4uc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0cywuc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0cy5zd2lwZXItcGFnaW5hdGlvbi1ob3Jpem9udGFsLC5zd2lwZXItcGFnaW5hdGlvbi1jdXN0b20sLnN3aXBlci1wYWdpbmF0aW9uLWZyYWN0aW9ue2JvdHRvbToxMHB4O2xlZnQ6MDt3aWR0aDoxMDAlfS5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXRzLWR5bmFtaWN7b3ZlcmZsb3c6aGlkZGVuO2ZvbnQtc2l6ZTowfS5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXRzLWR5bmFtaWMgLnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHt0cmFuc2Zvcm06c2NhbGUoLjMzKTtwb3NpdGlvbjpyZWxhdGl2ZX0uc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0cy1keW5hbWljIC5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXQtYWN0aXZle3RyYW5zZm9ybTpzY2FsZSgxKX0uc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0cy1keW5hbWljIC5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXQtYWN0aXZlLW1haW57dHJhbnNmb3JtOnNjYWxlKDEpfS5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXRzLWR5bmFtaWMgLnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldC1hY3RpdmUtcHJldnt0cmFuc2Zvcm06c2NhbGUoLjY2KX0uc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0cy1keW5hbWljIC5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXQtYWN0aXZlLXByZXYtcHJldnt0cmFuc2Zvcm06c2NhbGUoLjMzKX0uc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0cy1keW5hbWljIC5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXQtYWN0aXZlLW5leHR7dHJhbnNmb3JtOnNjYWxlKC42Nil9LnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHMtZHluYW1pYyAuc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0LWFjdGl2ZS1uZXh0LW5leHR7dHJhbnNmb3JtOnNjYWxlKC4zMyl9LnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHt3aWR0aDp2YXIoLS1zd2lwZXItcGFnaW5hdGlvbi1idWxsZXQtd2lkdGgsdmFyKC0tc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0LXNpemUsOHB4KSk7aGVpZ2h0OnZhcigtLXN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldC1oZWlnaHQsdmFyKC0tc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0LXNpemUsOHB4KSk7ZGlzcGxheTppbmxpbmUtYmxvY2s7Ym9yZGVyLXJhZGl1czo1MCU7YmFja2dyb3VuZDp2YXIoLS1zd2lwZXItcGFnaW5hdGlvbi1idWxsZXQtaW5hY3RpdmUtY29sb3IsIzAwMCk7b3BhY2l0eTp2YXIoLS1zd2lwZXItcGFnaW5hdGlvbi1idWxsZXQtaW5hY3RpdmUtb3BhY2l0eSwgLjIpfWJ1dHRvbi5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXR7Ym9yZGVyOm5vbmU7bWFyZ2luOjA7cGFkZGluZzowO2JveC1zaGFkb3c6bm9uZTstd2Via2l0LWFwcGVhcmFuY2U6bm9uZTthcHBlYXJhbmNlOm5vbmV9LnN3aXBlci1wYWdpbmF0aW9uLWNsaWNrYWJsZSAuc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0e2N1cnNvcjpwb2ludGVyfS5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXQ6b25seS1jaGlsZHtkaXNwbGF5Om5vbmUhaW1wb3J0YW50fS5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXQtYWN0aXZle29wYWNpdHk6dmFyKC0tc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0LW9wYWNpdHksIDEpO2JhY2tncm91bmQ6dmFyKC0tc3dpcGVyLXBhZ2luYXRpb24tY29sb3IsdmFyKC0tc3dpcGVyLXRoZW1lLWNvbG9yKSl9LnN3aXBlci1wYWdpbmF0aW9uLXZlcnRpY2FsLnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHMsLnN3aXBlci12ZXJ0aWNhbD4uc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0c3tyaWdodDoxMHB4O3RvcDo1MCU7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDBweCwtNTAlLDApfS5zd2lwZXItcGFnaW5hdGlvbi12ZXJ0aWNhbC5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXRzIC5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXQsLnN3aXBlci12ZXJ0aWNhbD4uc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0cyAuc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0e21hcmdpbjp2YXIoLS1zd2lwZXItcGFnaW5hdGlvbi1idWxsZXQtdmVydGljYWwtZ2FwLDZweCkgMDtkaXNwbGF5OmJsb2NrfS5zd2lwZXItcGFnaW5hdGlvbi12ZXJ0aWNhbC5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXRzLnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHMtZHluYW1pYywuc3dpcGVyLXZlcnRpY2FsPi5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXRzLnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHMtZHluYW1pY3t0b3A6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpO3dpZHRoOjhweH0uc3dpcGVyLXBhZ2luYXRpb24tdmVydGljYWwuc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0cy5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXRzLWR5bmFtaWMgLnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldCwuc3dpcGVyLXZlcnRpY2FsPi5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXRzLnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHMtZHluYW1pYyAuc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0e2Rpc3BsYXk6aW5saW5lLWJsb2NrO3RyYW5zaXRpb246LjJzIHRyYW5zZm9ybSwuMnMgdG9wfS5zd2lwZXItaG9yaXpvbnRhbD4uc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0cyAuc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0LC5zd2lwZXItcGFnaW5hdGlvbi1ob3Jpem9udGFsLnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHMgLnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHttYXJnaW46MCB2YXIoLS1zd2lwZXItcGFnaW5hdGlvbi1idWxsZXQtaG9yaXpvbnRhbC1nYXAsNHB4KX0uc3dpcGVyLWhvcml6b250YWw+LnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHMuc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0cy1keW5hbWljLC5zd2lwZXItcGFnaW5hdGlvbi1ob3Jpem9udGFsLnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHMuc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0cy1keW5hbWlje2xlZnQ6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpO3doaXRlLXNwYWNlOm5vd3JhcH0uc3dpcGVyLWhvcml6b250YWw+LnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHMuc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0cy1keW5hbWljIC5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXQsLnN3aXBlci1wYWdpbmF0aW9uLWhvcml6b250YWwuc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0cy5zd2lwZXItcGFnaW5hdGlvbi1idWxsZXRzLWR5bmFtaWMgLnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHt0cmFuc2l0aW9uOi4ycyB0cmFuc2Zvcm0sLjJzIGxlZnR9LnN3aXBlci1ob3Jpem9udGFsLnN3aXBlci1ydGw+LnN3aXBlci1wYWdpbmF0aW9uLWJ1bGxldHMtZHluYW1pYyAuc3dpcGVyLXBhZ2luYXRpb24tYnVsbGV0e3RyYW5zaXRpb246LjJzIHRyYW5zZm9ybSwuMnMgcmlnaHR9LnN3aXBlci1wYWdpbmF0aW9uLXByb2dyZXNzYmFye2JhY2tncm91bmQ6cmdiYSgwLDAsMCwuMjUpO3Bvc2l0aW9uOmFic29sdXRlfS5zd2lwZXItcGFnaW5hdGlvbi1wcm9ncmVzc2JhciAuc3dpcGVyLXBhZ2luYXRpb24tcHJvZ3Jlc3NiYXItZmlsbHtiYWNrZ3JvdW5kOnZhcigtLXN3aXBlci1wYWdpbmF0aW9uLWNvbG9yLHZhcigtLXN3aXBlci10aGVtZS1jb2xvcikpO3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6MDt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO3RyYW5zZm9ybTpzY2FsZSgwKTt0cmFuc2Zvcm0tb3JpZ2luOmxlZnQgdG9wfS5zd2lwZXItcnRsIC5zd2lwZXItcGFnaW5hdGlvbi1wcm9ncmVzc2JhciAuc3dpcGVyLXBhZ2luYXRpb24tcHJvZ3Jlc3NiYXItZmlsbHt0cmFuc2Zvcm0tb3JpZ2luOnJpZ2h0IHRvcH0uc3dpcGVyLWhvcml6b250YWw+LnN3aXBlci1wYWdpbmF0aW9uLXByb2dyZXNzYmFyLC5zd2lwZXItcGFnaW5hdGlvbi1wcm9ncmVzc2Jhci5zd2lwZXItcGFnaW5hdGlvbi1ob3Jpem9udGFsLC5zd2lwZXItcGFnaW5hdGlvbi1wcm9ncmVzc2Jhci5zd2lwZXItcGFnaW5hdGlvbi12ZXJ0aWNhbC5zd2lwZXItcGFnaW5hdGlvbi1wcm9ncmVzc2Jhci1vcHBvc2l0ZSwuc3dpcGVyLXZlcnRpY2FsPi5zd2lwZXItcGFnaW5hdGlvbi1wcm9ncmVzc2Jhci5zd2lwZXItcGFnaW5hdGlvbi1wcm9ncmVzc2Jhci1vcHBvc2l0ZXt3aWR0aDoxMDAlO2hlaWdodDo0cHg7bGVmdDowO3RvcDowfS5zd2lwZXItaG9yaXpvbnRhbD4uc3dpcGVyLXBhZ2luYXRpb24tcHJvZ3Jlc3NiYXIuc3dpcGVyLXBhZ2luYXRpb24tcHJvZ3Jlc3NiYXItb3Bwb3NpdGUsLnN3aXBlci1wYWdpbmF0aW9uLXByb2dyZXNzYmFyLnN3aXBlci1wYWdpbmF0aW9uLWhvcml6b250YWwuc3dpcGVyLXBhZ2luYXRpb24tcHJvZ3Jlc3NiYXItb3Bwb3NpdGUsLnN3aXBlci1wYWdpbmF0aW9uLXByb2dyZXNzYmFyLnN3aXBlci1wYWdpbmF0aW9uLXZlcnRpY2FsLC5zd2lwZXItdmVydGljYWw+LnN3aXBlci1wYWdpbmF0aW9uLXByb2dyZXNzYmFye3dpZHRoOjRweDtoZWlnaHQ6MTAwJTtsZWZ0OjA7dG9wOjB9LnN3aXBlci1wYWdpbmF0aW9uLWxvY2t7ZGlzcGxheTpub25lfVwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./node_modules/swiper/modules/pagination/pagination.min.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./node_modules/swiper/modules/scrollbar/scrollbar.min.css":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./node_modules/swiper/modules/scrollbar/scrollbar.min.css ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\n/* harmony import */ var _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".swiper-scrollbar{border-radius:10px;position:relative;-ms-touch-action:none;background:rgba(0,0,0,.1)}.swiper-scrollbar-disabled>.swiper-scrollbar,.swiper-scrollbar.swiper-scrollbar-disabled{display:none!important}.swiper-horizontal>.swiper-scrollbar,.swiper-scrollbar.swiper-scrollbar-horizontal{position:absolute;left:1%;bottom:3px;z-index:50;height:5px;width:98%}.swiper-scrollbar.swiper-scrollbar-vertical,.swiper-vertical>.swiper-scrollbar{position:absolute;right:3px;top:1%;z-index:50;width:5px;height:98%}.swiper-scrollbar-drag{height:100%;width:100%;position:relative;background:rgba(0,0,0,.5);border-radius:10px;left:0;top:0}.swiper-scrollbar-cursor-drag{cursor:move}.swiper-scrollbar-lock{display:none}\", \"\",{\"version\":3,\"sources\":[\"webpack://node_modules/swiper/modules/scrollbar/scrollbar.min.css\"],\"names\":[],\"mappings\":\"AAAA,kBAAkB,kBAAkB,CAAC,iBAAiB,CAAC,qBAAqB,CAAC,yBAAyB,CAAC,yFAAyF,sBAAsB,CAAC,mFAAmF,iBAAiB,CAAC,OAAO,CAAC,UAAU,CAAC,UAAU,CAAC,UAAU,CAAC,SAAS,CAAC,+EAA+E,iBAAiB,CAAC,SAAS,CAAC,MAAM,CAAC,UAAU,CAAC,SAAS,CAAC,UAAU,CAAC,uBAAuB,WAAW,CAAC,UAAU,CAAC,iBAAiB,CAAC,yBAAyB,CAAC,kBAAkB,CAAC,MAAM,CAAC,KAAK,CAAC,8BAA8B,WAAW,CAAC,uBAAuB,YAAY\",\"sourcesContent\":[\".swiper-scrollbar{border-radius:10px;position:relative;-ms-touch-action:none;background:rgba(0,0,0,.1)}.swiper-scrollbar-disabled>.swiper-scrollbar,.swiper-scrollbar.swiper-scrollbar-disabled{display:none!important}.swiper-horizontal>.swiper-scrollbar,.swiper-scrollbar.swiper-scrollbar-horizontal{position:absolute;left:1%;bottom:3px;z-index:50;height:5px;width:98%}.swiper-scrollbar.swiper-scrollbar-vertical,.swiper-vertical>.swiper-scrollbar{position:absolute;right:3px;top:1%;z-index:50;width:5px;height:98%}.swiper-scrollbar-drag{height:100%;width:100%;position:relative;background:rgba(0,0,0,.5);border-radius:10px;left:0;top:0}.swiper-scrollbar-cursor-drag{cursor:move}.swiper-scrollbar-lock{display:none}\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls5XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOV0udXNlWzJdIS4vbm9kZV9tb2R1bGVzL3N3aXBlci9tb2R1bGVzL3Njcm9sbGJhci9zY3JvbGxiYXIubWluLmNzcy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNpSDtBQUNqSCw4QkFBOEIscUdBQTJCO0FBQ3pEO0FBQ0EsNERBQTRELG1CQUFtQixrQkFBa0Isc0JBQXNCLDBCQUEwQix5RkFBeUYsdUJBQXVCLG1GQUFtRixrQkFBa0IsUUFBUSxXQUFXLFdBQVcsV0FBVyxVQUFVLCtFQUErRSxrQkFBa0IsVUFBVSxPQUFPLFdBQVcsVUFBVSxXQUFXLHVCQUF1QixZQUFZLFdBQVcsa0JBQWtCLDBCQUEwQixtQkFBbUIsT0FBTyxNQUFNLDhCQUE4QixZQUFZLHVCQUF1QixhQUFhLE9BQU8sa2VBQWtlLG1CQUFtQixrQkFBa0Isc0JBQXNCLDBCQUEwQix5RkFBeUYsdUJBQXVCLG1GQUFtRixrQkFBa0IsUUFBUSxXQUFXLFdBQVcsV0FBVyxVQUFVLCtFQUErRSxrQkFBa0IsVUFBVSxPQUFPLFdBQVcsVUFBVSxXQUFXLHVCQUF1QixZQUFZLFdBQVcsa0JBQWtCLDBCQUEwQixtQkFBbUIsT0FBTyxNQUFNLDhCQUE4QixZQUFZLHVCQUF1QixhQUFhLG1CQUFtQjtBQUN0NkQ7QUFDQSwrREFBZSx1QkFBdUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc3dpcGVyL21vZHVsZXMvc2Nyb2xsYmFyL3Njcm9sbGJhci5taW4uY3NzPzhmODQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLnN3aXBlci1zY3JvbGxiYXJ7Ym9yZGVyLXJhZGl1czoxMHB4O3Bvc2l0aW9uOnJlbGF0aXZlOy1tcy10b3VjaC1hY3Rpb246bm9uZTtiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsLjEpfS5zd2lwZXItc2Nyb2xsYmFyLWRpc2FibGVkPi5zd2lwZXItc2Nyb2xsYmFyLC5zd2lwZXItc2Nyb2xsYmFyLnN3aXBlci1zY3JvbGxiYXItZGlzYWJsZWR7ZGlzcGxheTpub25lIWltcG9ydGFudH0uc3dpcGVyLWhvcml6b250YWw+LnN3aXBlci1zY3JvbGxiYXIsLnN3aXBlci1zY3JvbGxiYXIuc3dpcGVyLXNjcm9sbGJhci1ob3Jpem9udGFse3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MSU7Ym90dG9tOjNweDt6LWluZGV4OjUwO2hlaWdodDo1cHg7d2lkdGg6OTglfS5zd2lwZXItc2Nyb2xsYmFyLnN3aXBlci1zY3JvbGxiYXItdmVydGljYWwsLnN3aXBlci12ZXJ0aWNhbD4uc3dpcGVyLXNjcm9sbGJhcntwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDozcHg7dG9wOjElO3otaW5kZXg6NTA7d2lkdGg6NXB4O2hlaWdodDo5OCV9LnN3aXBlci1zY3JvbGxiYXItZHJhZ3toZWlnaHQ6MTAwJTt3aWR0aDoxMDAlO3Bvc2l0aW9uOnJlbGF0aXZlO2JhY2tncm91bmQ6cmdiYSgwLDAsMCwuNSk7Ym9yZGVyLXJhZGl1czoxMHB4O2xlZnQ6MDt0b3A6MH0uc3dpcGVyLXNjcm9sbGJhci1jdXJzb3ItZHJhZ3tjdXJzb3I6bW92ZX0uc3dpcGVyLXNjcm9sbGJhci1sb2Nre2Rpc3BsYXk6bm9uZX1cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vbm9kZV9tb2R1bGVzL3N3aXBlci9tb2R1bGVzL3Njcm9sbGJhci9zY3JvbGxiYXIubWluLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSxrQkFBa0Isa0JBQWtCLENBQUMsaUJBQWlCLENBQUMscUJBQXFCLENBQUMseUJBQXlCLENBQUMseUZBQXlGLHNCQUFzQixDQUFDLG1GQUFtRixpQkFBaUIsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLCtFQUErRSxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLHVCQUF1QixXQUFXLENBQUMsVUFBVSxDQUFDLGlCQUFpQixDQUFDLHlCQUF5QixDQUFDLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsOEJBQThCLFdBQVcsQ0FBQyx1QkFBdUIsWUFBWVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuc3dpcGVyLXNjcm9sbGJhcntib3JkZXItcmFkaXVzOjEwcHg7cG9zaXRpb246cmVsYXRpdmU7LW1zLXRvdWNoLWFjdGlvbjpub25lO2JhY2tncm91bmQ6cmdiYSgwLDAsMCwuMSl9LnN3aXBlci1zY3JvbGxiYXItZGlzYWJsZWQ+LnN3aXBlci1zY3JvbGxiYXIsLnN3aXBlci1zY3JvbGxiYXIuc3dpcGVyLXNjcm9sbGJhci1kaXNhYmxlZHtkaXNwbGF5Om5vbmUhaW1wb3J0YW50fS5zd2lwZXItaG9yaXpvbnRhbD4uc3dpcGVyLXNjcm9sbGJhciwuc3dpcGVyLXNjcm9sbGJhci5zd2lwZXItc2Nyb2xsYmFyLWhvcml6b250YWx7cG9zaXRpb246YWJzb2x1dGU7bGVmdDoxJTtib3R0b206M3B4O3otaW5kZXg6NTA7aGVpZ2h0OjVweDt3aWR0aDo5OCV9LnN3aXBlci1zY3JvbGxiYXIuc3dpcGVyLXNjcm9sbGJhci12ZXJ0aWNhbCwuc3dpcGVyLXZlcnRpY2FsPi5zd2lwZXItc2Nyb2xsYmFye3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjNweDt0b3A6MSU7ei1pbmRleDo1MDt3aWR0aDo1cHg7aGVpZ2h0Ojk4JX0uc3dpcGVyLXNjcm9sbGJhci1kcmFne2hlaWdodDoxMDAlO3dpZHRoOjEwMCU7cG9zaXRpb246cmVsYXRpdmU7YmFja2dyb3VuZDpyZ2JhKDAsMCwwLC41KTtib3JkZXItcmFkaXVzOjEwcHg7bGVmdDowO3RvcDowfS5zd2lwZXItc2Nyb2xsYmFyLWN1cnNvci1kcmFne2N1cnNvcjptb3ZlfS5zd2lwZXItc2Nyb2xsYmFyLWxvY2t7ZGlzcGxheTpub25lfVwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./node_modules/swiper/modules/scrollbar/scrollbar.min.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./node_modules/swiper/swiper.min.css":
/*!************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./node_modules/swiper/swiper.min.css ***!
  \************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\n/* harmony import */ var _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/**\\n * Swiper 8.4.7\\n * Most modern mobile touch slider and framework with hardware accelerated transitions\\n * https://swiperjs.com\\n *\\n * Copyright 2014-2023 Vladimir Kharlampidi\\n *\\n * Released under the MIT License\\n *\\n * Released on: January 30, 2023\\n */\\n\\n@font-face{font-family:swiper-icons;src:url('data:application/font-woff;charset=utf-8;base64, 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');font-weight:400;font-style:normal}:root{--swiper-theme-color:#007aff}.swiper{margin-left:auto;margin-right:auto;position:relative;overflow:hidden;list-style:none;padding:0;z-index:1}.swiper-vertical>.swiper-wrapper{flex-direction:column}.swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:flex;transition-property:transform;box-sizing:content-box}.swiper-android .swiper-slide,.swiper-wrapper{transform:translate3d(0px,0,0)}.swiper-pointer-events{touch-action:pan-y}.swiper-pointer-events.swiper-vertical{touch-action:pan-x}.swiper-slide{flex-shrink:0;width:100%;height:100%;position:relative;transition-property:transform}.swiper-slide-invisible-blank{visibility:hidden}.swiper-autoheight,.swiper-autoheight .swiper-slide{height:auto}.swiper-autoheight .swiper-wrapper{align-items:flex-start;transition-property:transform,height}.swiper-backface-hidden .swiper-slide{transform:translateZ(0);-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-3d,.swiper-3d.swiper-css-mode .swiper-wrapper{perspective:1200px}.swiper-3d .swiper-cube-shadow,.swiper-3d .swiper-slide,.swiper-3d .swiper-slide-shadow,.swiper-3d .swiper-slide-shadow-bottom,.swiper-3d .swiper-slide-shadow-left,.swiper-3d .swiper-slide-shadow-right,.swiper-3d .swiper-slide-shadow-top,.swiper-3d .swiper-wrapper{transform-style:preserve-3d}.swiper-3d .swiper-slide-shadow,.swiper-3d .swiper-slide-shadow-bottom,.swiper-3d .swiper-slide-shadow-left,.swiper-3d .swiper-slide-shadow-right,.swiper-3d .swiper-slide-shadow-top{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}.swiper-3d .swiper-slide-shadow{background:rgba(0,0,0,.15)}.swiper-3d .swiper-slide-shadow-left{background-image:linear-gradient(to left,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-right{background-image:linear-gradient(to right,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-top{background-image:linear-gradient(to top,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-bottom{background-image:linear-gradient(to bottom,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-css-mode>.swiper-wrapper{overflow:auto;scrollbar-width:none;-ms-overflow-style:none}.swiper-css-mode>.swiper-wrapper::-webkit-scrollbar{display:none}.swiper-css-mode>.swiper-wrapper>.swiper-slide{scroll-snap-align:start start}.swiper-horizontal.swiper-css-mode>.swiper-wrapper{scroll-snap-type:x mandatory}.swiper-vertical.swiper-css-mode>.swiper-wrapper{scroll-snap-type:y mandatory}.swiper-centered>.swiper-wrapper::before{content:'';flex-shrink:0;order:9999}.swiper-centered.swiper-horizontal>.swiper-wrapper>.swiper-slide:first-child{-webkit-margin-start:var(--swiper-centered-offset-before);margin-inline-start:var(--swiper-centered-offset-before)}.swiper-centered.swiper-horizontal>.swiper-wrapper::before{height:100%;min-height:1px;width:var(--swiper-centered-offset-after)}.swiper-centered.swiper-vertical>.swiper-wrapper>.swiper-slide:first-child{-webkit-margin-before:var(--swiper-centered-offset-before);margin-block-start:var(--swiper-centered-offset-before)}.swiper-centered.swiper-vertical>.swiper-wrapper::before{width:100%;min-width:1px;height:var(--swiper-centered-offset-after)}.swiper-centered>.swiper-wrapper>.swiper-slide{scroll-snap-align:center center;scroll-snap-stop:always}\", \"\",{\"version\":3,\"sources\":[\"webpack://node_modules/swiper/swiper.min.css\"],\"names\":[],\"mappings\":\"AAAA;;;;;;;;;;EAUE;;AAEF,WAAW,wBAAwB,CAAC,4rEAA4rE,CAAC,eAAe,CAAC,iBAAiB,CAAC,MAAM,4BAA4B,CAAC,QAAQ,gBAAgB,CAAC,iBAAiB,CAAC,iBAAiB,CAAC,eAAe,CAAC,eAAe,CAAC,SAAS,CAAC,SAAS,CAAC,iCAAiC,qBAAqB,CAAC,gBAAgB,iBAAiB,CAAC,UAAU,CAAC,WAAW,CAAC,SAAS,CAAC,YAAY,CAAC,6BAA6B,CAAC,sBAAsB,CAAC,8CAA8C,8BAA8B,CAAC,uBAAuB,kBAAkB,CAAC,uCAAuC,kBAAkB,CAAC,cAAc,aAAa,CAAC,UAAU,CAAC,WAAW,CAAC,iBAAiB,CAAC,6BAA6B,CAAC,8BAA8B,iBAAiB,CAAC,oDAAoD,WAAW,CAAC,mCAAmC,sBAAsB,CAAC,oCAAoC,CAAC,sCAAsC,uBAAuB,CAAC,kCAAkC,CAAC,0BAA0B,CAAC,sDAAsD,kBAAkB,CAAC,yQAAyQ,2BAA2B,CAAC,sLAAsL,iBAAiB,CAAC,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC,WAAW,CAAC,mBAAmB,CAAC,UAAU,CAAC,gCAAgC,0BAA0B,CAAC,qCAAqC,sEAAsE,CAAC,sCAAsC,uEAAuE,CAAC,oCAAoC,qEAAqE,CAAC,uCAAuC,wEAAwE,CAAC,iCAAiC,aAAa,CAAC,oBAAoB,CAAC,uBAAuB,CAAC,oDAAoD,YAAY,CAAC,+CAA+C,6BAA6B,CAAC,mDAAmD,4BAA4B,CAAC,iDAAiD,4BAA4B,CAAC,yCAAyC,UAAU,CAAC,aAAa,CAAC,UAAU,CAAC,6EAA6E,yDAAuD,CAAvD,wDAAwD,CAAC,2DAA2D,WAAW,CAAC,cAAc,CAAC,yCAAyC,CAAC,2EAA2E,0DAAsD,CAAtD,uDAAuD,CAAC,yDAAyD,UAAU,CAAC,aAAa,CAAC,0CAA0C,CAAC,+CAA+C,+BAA+B,CAAC,uBAAuB\",\"sourcesContent\":[\"/**\\n * Swiper 8.4.7\\n * Most modern mobile touch slider and framework with hardware accelerated transitions\\n * https://swiperjs.com\\n *\\n * Copyright 2014-2023 Vladimir Kharlampidi\\n *\\n * Released under the MIT License\\n *\\n * Released on: January 30, 2023\\n */\\n\\n@font-face{font-family:swiper-icons;src:url('data:application/font-woff;charset=utf-8;base64, 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');font-weight:400;font-style:normal}:root{--swiper-theme-color:#007aff}.swiper{margin-left:auto;margin-right:auto;position:relative;overflow:hidden;list-style:none;padding:0;z-index:1}.swiper-vertical>.swiper-wrapper{flex-direction:column}.swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:flex;transition-property:transform;box-sizing:content-box}.swiper-android .swiper-slide,.swiper-wrapper{transform:translate3d(0px,0,0)}.swiper-pointer-events{touch-action:pan-y}.swiper-pointer-events.swiper-vertical{touch-action:pan-x}.swiper-slide{flex-shrink:0;width:100%;height:100%;position:relative;transition-property:transform}.swiper-slide-invisible-blank{visibility:hidden}.swiper-autoheight,.swiper-autoheight .swiper-slide{height:auto}.swiper-autoheight .swiper-wrapper{align-items:flex-start;transition-property:transform,height}.swiper-backface-hidden .swiper-slide{transform:translateZ(0);-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-3d,.swiper-3d.swiper-css-mode .swiper-wrapper{perspective:1200px}.swiper-3d .swiper-cube-shadow,.swiper-3d .swiper-slide,.swiper-3d .swiper-slide-shadow,.swiper-3d .swiper-slide-shadow-bottom,.swiper-3d .swiper-slide-shadow-left,.swiper-3d .swiper-slide-shadow-right,.swiper-3d .swiper-slide-shadow-top,.swiper-3d .swiper-wrapper{transform-style:preserve-3d}.swiper-3d .swiper-slide-shadow,.swiper-3d .swiper-slide-shadow-bottom,.swiper-3d .swiper-slide-shadow-left,.swiper-3d .swiper-slide-shadow-right,.swiper-3d .swiper-slide-shadow-top{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}.swiper-3d .swiper-slide-shadow{background:rgba(0,0,0,.15)}.swiper-3d .swiper-slide-shadow-left{background-image:linear-gradient(to left,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-right{background-image:linear-gradient(to right,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-top{background-image:linear-gradient(to top,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-bottom{background-image:linear-gradient(to bottom,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-css-mode>.swiper-wrapper{overflow:auto;scrollbar-width:none;-ms-overflow-style:none}.swiper-css-mode>.swiper-wrapper::-webkit-scrollbar{display:none}.swiper-css-mode>.swiper-wrapper>.swiper-slide{scroll-snap-align:start start}.swiper-horizontal.swiper-css-mode>.swiper-wrapper{scroll-snap-type:x mandatory}.swiper-vertical.swiper-css-mode>.swiper-wrapper{scroll-snap-type:y mandatory}.swiper-centered>.swiper-wrapper::before{content:'';flex-shrink:0;order:9999}.swiper-centered.swiper-horizontal>.swiper-wrapper>.swiper-slide:first-child{margin-inline-start:var(--swiper-centered-offset-before)}.swiper-centered.swiper-horizontal>.swiper-wrapper::before{height:100%;min-height:1px;width:var(--swiper-centered-offset-after)}.swiper-centered.swiper-vertical>.swiper-wrapper>.swiper-slide:first-child{margin-block-start:var(--swiper-centered-offset-before)}.swiper-centered.swiper-vertical>.swiper-wrapper::before{width:100%;min-width:1px;height:var(--swiper-centered-offset-after)}.swiper-centered>.swiper-wrapper>.swiper-slide{scroll-snap-align:center center;scroll-snap-stop:always}\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls5XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOV0udXNlWzJdIS4vbm9kZV9tb2R1bGVzL3N3aXBlci9zd2lwZXIubWluLmNzcy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUMyRztBQUMzRyw4QkFBOEIscUdBQTJCO0FBQ3pEO0FBQ0EsaVVBQWlVLHlCQUF5QixvQ0FBb0MsY0FBYywyb0VBQTJvRSxnQkFBZ0Isa0JBQWtCLE1BQU0sNkJBQTZCLFFBQVEsaUJBQWlCLGtCQUFrQixrQkFBa0IsZ0JBQWdCLGdCQUFnQixVQUFVLFVBQVUsaUNBQWlDLHNCQUFzQixnQkFBZ0Isa0JBQWtCLFdBQVcsWUFBWSxVQUFVLGFBQWEsOEJBQThCLHVCQUF1Qiw4Q0FBOEMsK0JBQStCLHVCQUF1QixtQkFBbUIsdUNBQXVDLG1CQUFtQixjQUFjLGNBQWMsV0FBVyxZQUFZLGtCQUFrQiw4QkFBOEIsOEJBQThCLGtCQUFrQixvREFBb0QsWUFBWSxtQ0FBbUMsdUJBQXVCLHFDQUFxQyxzQ0FBc0Msd0JBQXdCLG1DQUFtQywyQkFBMkIsc0RBQXNELG1CQUFtQix5UUFBeVEsNEJBQTRCLHNMQUFzTCxrQkFBa0IsT0FBTyxNQUFNLFdBQVcsWUFBWSxvQkFBb0IsV0FBVyxnQ0FBZ0MsMkJBQTJCLHFDQUFxQyx1RUFBdUUsc0NBQXNDLHdFQUF3RSxvQ0FBb0Msc0VBQXNFLHVDQUF1Qyx5RUFBeUUsaUNBQWlDLGNBQWMscUJBQXFCLHdCQUF3QixvREFBb0QsYUFBYSwrQ0FBK0MsOEJBQThCLG1EQUFtRCw2QkFBNkIsaURBQWlELDZCQUE2Qix5Q0FBeUMsV0FBVyxjQUFjLFdBQVcsNkVBQTZFLDBEQUEwRCx5REFBeUQsMkRBQTJELFlBQVksZUFBZSwwQ0FBMEMsMkVBQTJFLDJEQUEyRCx3REFBd0QseURBQXlELFdBQVcsY0FBYywyQ0FBMkMsK0NBQStDLGdDQUFnQyx3QkFBd0IsT0FBTyw0R0FBNEcsTUFBTSxxeUNBQXF5Qyx5QkFBeUIsb0NBQW9DLGNBQWMsMm9FQUEyb0UsZ0JBQWdCLGtCQUFrQixNQUFNLDZCQUE2QixRQUFRLGlCQUFpQixrQkFBa0Isa0JBQWtCLGdCQUFnQixnQkFBZ0IsVUFBVSxVQUFVLGlDQUFpQyxzQkFBc0IsZ0JBQWdCLGtCQUFrQixXQUFXLFlBQVksVUFBVSxhQUFhLDhCQUE4Qix1QkFBdUIsOENBQThDLCtCQUErQix1QkFBdUIsbUJBQW1CLHVDQUF1QyxtQkFBbUIsY0FBYyxjQUFjLFdBQVcsWUFBWSxrQkFBa0IsOEJBQThCLDhCQUE4QixrQkFBa0Isb0RBQW9ELFlBQVksbUNBQW1DLHVCQUF1QixxQ0FBcUMsc0NBQXNDLHdCQUF3QixtQ0FBbUMsMkJBQTJCLHNEQUFzRCxtQkFBbUIseVFBQXlRLDRCQUE0QixzTEFBc0wsa0JBQWtCLE9BQU8sTUFBTSxXQUFXLFlBQVksb0JBQW9CLFdBQVcsZ0NBQWdDLDJCQUEyQixxQ0FBcUMsdUVBQXVFLHNDQUFzQyx3RUFBd0Usb0NBQW9DLHNFQUFzRSx1Q0FBdUMseUVBQXlFLGlDQUFpQyxjQUFjLHFCQUFxQix3QkFBd0Isb0RBQW9ELGFBQWEsK0NBQStDLDhCQUE4QixtREFBbUQsNkJBQTZCLGlEQUFpRCw2QkFBNkIseUNBQXlDLFdBQVcsY0FBYyxXQUFXLDZFQUE2RSx5REFBeUQsMkRBQTJELFlBQVksZUFBZSwwQ0FBMEMsMkVBQTJFLHdEQUF3RCx5REFBeUQsV0FBVyxjQUFjLDJDQUEyQywrQ0FBK0MsZ0NBQWdDLHdCQUF3QixtQkFBbUI7QUFDemdaO0FBQ0EsK0RBQWUsdUJBQXVCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9zd2lwZXIubWluLmNzcz9lNGNlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi8qKlxcbiAqIFN3aXBlciA4LjQuN1xcbiAqIE1vc3QgbW9kZXJuIG1vYmlsZSB0b3VjaCBzbGlkZXIgYW5kIGZyYW1ld29yayB3aXRoIGhhcmR3YXJlIGFjY2VsZXJhdGVkIHRyYW5zaXRpb25zXFxuICogaHR0cHM6Ly9zd2lwZXJqcy5jb21cXG4gKlxcbiAqIENvcHlyaWdodCAyMDE0LTIwMjMgVmxhZGltaXIgS2hhcmxhbXBpZGlcXG4gKlxcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxcbiAqXFxuICogUmVsZWFzZWQgb246IEphbnVhcnkgMzAsIDIwMjNcXG4gKi9cXG5cXG5AZm9udC1mYWNle2ZvbnQtZmFtaWx5OnN3aXBlci1pY29ucztzcmM6dXJsKCdkYXRhOmFwcGxpY2F0aW9uL2ZvbnQtd29mZjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwgZDA5R1JnQUJBQUFBQUFaZ0FCQUFBQUFBREFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJHUmxSTkFBQUdSQUFBQUJvQUFBQWNpNnFIa1VkRVJVWUFBQVdnQUFBQUl3QUFBQ1FBWUFCWFIxQlBVd0FBQmhRQUFBQXVBQUFBTnVBWTcreEhVMVZDQUFBRnhBQUFBRkFBQUFCbTJmUGN6VTlUTHpJQUFBSGNBQUFBU2dBQUFHQlA5VjVSWTIxaGNBQUFBa1FBQUFDSUFBQUJZdDZGMGNCamRuUWdBQUFDekFBQUFBUUFBQUFFQUJFQlJHZGhjM0FBQUFXWUFBQUFDQUFBQUFqLy93QURaMng1WmdBQUF5d0FBQURNQUFBRDJNSHRyeVZvWldGa0FBQUJiQUFBQURBQUFBQTJFMitlb1dob1pXRUFBQUdjQUFBQUh3QUFBQ1FDOWdEemFHMTBlQUFBQWlnQUFBQVpBQUFBcmdKa0FCRnNiMk5oQUFBQzBBQUFBRm9BQUFCYUZRQVVHRzFoZUhBQUFBRzhBQUFBSHdBQUFDQUFjQUJBYm1GdFpRQUFBL2dBQUFFNUFBQUNYdkZkQndsd2IzTjBBQUFGTkFBQUFHSUFBQUNFNXM3NGhYamFZMkJrWUdBQVlwZjVIdS9qK1cyK01uQXpNWURBemFYNlFqRDYvNC8vQnhqNUdBOEF1UndNWUdrQVB5d0wxM2phWTJCa1lHQTg4UDhBZ3g0aisvOGZRRFlmQTFBRUJXZ0RBSUIyQk9vQWVOcGpZR1JnWU5CaDRHZGdZZ0FCRU1uSUFCSnpZTkFEQ1FBQUNXZ0FzUUI0Mm1OZ1lmekNPSUdCbFlHQjBZY3hqWUdCd1IxS2YyV1FaR2hoWUdCaVlHVm1nQUZHQmlRUWtPYWF3dERBb01CUXhYamcvd0VHUGNZRERBNHdOVUEyQ0Nnd3NBQUFPNEVMNmdBQWVOcGoyTTBneUFBQ3F4Z0dOV0JrWjJENC93TUEreGtEZGdBQUFIamFZMkJnWUdhQVlCa0dSZ1lRaUFIeUdNRjhGZ1lISU0zRHdNSEFCR1FyTU9neVdETEVNMVQ5L3c4VUJmRU1nTHpFLy8vL1AvNS8vZi9WL3h2K3I0ZWFBQWVNYkF4d0lVWW1JTUhFZ0tZQVlqVWNzREF3c0xLeGMzQnljZlB3OGpFUUEvZ1pCQVNGaEVWRXhjUWxKS1drWldUbDVCVVVsWlJWVk5YVU5UUVpCZ01BQU1SK0UrZ0FFUUZFQUFBQUtnQXFBQ29BTkFBK0FFZ0FVZ0JjQUdZQWNBQjZBSVFBamdDWUFLSUFyQUMyQU1BQXlnRFVBTjRBNkFEeUFQd0JCZ0VRQVJvQkpBRXVBVGdCUWdGTUFWWUJZQUZxQVhRQmZnR0lBWklCbkFHbUFiSUJ6Z0hzQUFCNDJ1Mk5NUTZDVUF5R1c1Njh4OUFuZVlZZ200TUpiaEtGYUV4SU9BVlg4QXBld1N0NEJpYzRBZmVBaWQzVk9CaXhEeGZQWUV6YTVPK1hmaTA0WUFEZ2dpVUlVTEN1RUpLOFZoTzRiU3ZwZG5rdEhJNVFDWXRkaTJzbDhablhhSGxxVXJOS3pkS2NUOGNqbHErcndaU3ZJVmN6TmllenNmblAvdXpubWZQRkJOT0RNMks3TVRRNDVZRUFacUdQODFBbUdHY0YzaVBxT29wMHIxU1BUYVRiVmtmVWU0SFhqOTd3WUUreU53V1l4d1d1NHYxdWdXSGdvM1MxWGRaRVZxV003RVQwY2ZuTEd4V2ZrZ1I0Mm8yUHZXckRNQlNGai9JSExhRjB6S2pSZ2RpVk13U2NOUkFvV1VvSDc4WTJpY0IveUlZMDlBbjZBSDJCZHUvVUIreXhvcFlzaFFpRXZudnUwZFVSZ0R0OFFlQzhQRHc3RnBqaTNmRUE0ei9QRUo2WU9CNWhLaDRkajNFdlhoeFBxSC9TS1VZM3JKN3NyWjRGWm5oMVBNQXRQaHdQNmZsMlBNSk1QRGdlUTRyWThZVDZHemFvMGVBRUE0MDlEdWdnbVRuRm5PY1NDaUVpTE1neENpVEk2Q3E1RFpVZDNRbXAxMHZPMExhTFRkMmNqTjRmT3VtbGM3bFVZYlNRY1pGa3V0Ukc3ZzZKS1pLeTBSbWRMWTY4MENEbkVKK1VNa3BGRmUxUk43bnhkVnBYckM0YVR0bmF1ck9uWWVyY1pnMllWbUxOL2QvZ2N6ZkVpbXJFL2ZzL2JPdXEyOVptbjh0bG9PUmFYZ1pnR2E3OHlPOS9jblhtMkJwYUd2cTI1RHY5UzRFOSs1U0ljOVBxdXBKS2hZRlNTbDQ3K1FjcjFtWU5BQUFBZU5wdHcwY0t3a0FBQU1EWkpBOFE3T1VKdmtMc1BmWjZ6RlZFUlB5OHFIaDJZRVIrM2kvQlA4M3ZJQkxMeVNzb0tpbXJxS3FwYTJocDYranE2UnNZR2htYm1KcVpTeTBzcmF4dGJPM3NIUnlkbkVNVTR1UjZ5eDdKSlh2ZVA3V3JEeWNBQUFBQUFBSC8vd0FDZU5wallHUmdZT0FCWWhrZ1pnSkNaZ1pOQmtZR0xRWnRJSnNGTE1ZQUFBdzNBTGdBZU5vbGl6RUtnREFRQkNjaFJiQzJzRkVSMFlENnFWUWlCQ3YvSDllekdJNlo1WEJBdzhDQksvbTVpUVFWYXVWYlhMbk9yTVp2Mm9MZEtGYThQanVydTJoSnpHYWJtT1NMek5NenZ1dHBCM040Mm1OZ1pHQmc0R0tRWXpCaFlNeEpMTWxqNEdCZ0FZb3cvUC9QQUpKaExNNnNTb1dLZldDQUF3REFqZ2JSQUFCNDJtTmdZR0JrQUlJYkNabzVJUHJtVW4waEdBMEFPOEVGVFFBQScpO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXN0eWxlOm5vcm1hbH06cm9vdHstLXN3aXBlci10aGVtZS1jb2xvcjojMDA3YWZmfS5zd2lwZXJ7bWFyZ2luLWxlZnQ6YXV0bzttYXJnaW4tcmlnaHQ6YXV0bztwb3NpdGlvbjpyZWxhdGl2ZTtvdmVyZmxvdzpoaWRkZW47bGlzdC1zdHlsZTpub25lO3BhZGRpbmc6MDt6LWluZGV4OjF9LnN3aXBlci12ZXJ0aWNhbD4uc3dpcGVyLXdyYXBwZXJ7ZmxleC1kaXJlY3Rpb246Y29sdW1ufS5zd2lwZXItd3JhcHBlcntwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO3otaW5kZXg6MTtkaXNwbGF5OmZsZXg7dHJhbnNpdGlvbi1wcm9wZXJ0eTp0cmFuc2Zvcm07Ym94LXNpemluZzpjb250ZW50LWJveH0uc3dpcGVyLWFuZHJvaWQgLnN3aXBlci1zbGlkZSwuc3dpcGVyLXdyYXBwZXJ7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDBweCwwLDApfS5zd2lwZXItcG9pbnRlci1ldmVudHN7dG91Y2gtYWN0aW9uOnBhbi15fS5zd2lwZXItcG9pbnRlci1ldmVudHMuc3dpcGVyLXZlcnRpY2Fse3RvdWNoLWFjdGlvbjpwYW4teH0uc3dpcGVyLXNsaWRle2ZsZXgtc2hyaW5rOjA7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtwb3NpdGlvbjpyZWxhdGl2ZTt0cmFuc2l0aW9uLXByb3BlcnR5OnRyYW5zZm9ybX0uc3dpcGVyLXNsaWRlLWludmlzaWJsZS1ibGFua3t2aXNpYmlsaXR5OmhpZGRlbn0uc3dpcGVyLWF1dG9oZWlnaHQsLnN3aXBlci1hdXRvaGVpZ2h0IC5zd2lwZXItc2xpZGV7aGVpZ2h0OmF1dG99LnN3aXBlci1hdXRvaGVpZ2h0IC5zd2lwZXItd3JhcHBlcnthbGlnbi1pdGVtczpmbGV4LXN0YXJ0O3RyYW5zaXRpb24tcHJvcGVydHk6dHJhbnNmb3JtLGhlaWdodH0uc3dpcGVyLWJhY2tmYWNlLWhpZGRlbiAuc3dpcGVyLXNsaWRle3RyYW5zZm9ybTp0cmFuc2xhdGVaKDApOy13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTpoaWRkZW47YmFja2ZhY2UtdmlzaWJpbGl0eTpoaWRkZW59LnN3aXBlci0zZCwuc3dpcGVyLTNkLnN3aXBlci1jc3MtbW9kZSAuc3dpcGVyLXdyYXBwZXJ7cGVyc3BlY3RpdmU6MTIwMHB4fS5zd2lwZXItM2QgLnN3aXBlci1jdWJlLXNoYWRvdywuc3dpcGVyLTNkIC5zd2lwZXItc2xpZGUsLnN3aXBlci0zZCAuc3dpcGVyLXNsaWRlLXNoYWRvdywuc3dpcGVyLTNkIC5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbSwuc3dpcGVyLTNkIC5zd2lwZXItc2xpZGUtc2hhZG93LWxlZnQsLnN3aXBlci0zZCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodCwuc3dpcGVyLTNkIC5zd2lwZXItc2xpZGUtc2hhZG93LXRvcCwuc3dpcGVyLTNkIC5zd2lwZXItd3JhcHBlcnt0cmFuc2Zvcm0tc3R5bGU6cHJlc2VydmUtM2R9LnN3aXBlci0zZCAuc3dpcGVyLXNsaWRlLXNoYWRvdywuc3dpcGVyLTNkIC5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbSwuc3dpcGVyLTNkIC5zd2lwZXItc2xpZGUtc2hhZG93LWxlZnQsLnN3aXBlci0zZCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodCwuc3dpcGVyLTNkIC5zd2lwZXItc2xpZGUtc2hhZG93LXRvcHtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7dG9wOjA7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtwb2ludGVyLWV2ZW50czpub25lO3otaW5kZXg6MTB9LnN3aXBlci0zZCAuc3dpcGVyLXNsaWRlLXNoYWRvd3tiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsLjE1KX0uc3dpcGVyLTNkIC5zd2lwZXItc2xpZGUtc2hhZG93LWxlZnR7YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQodG8gbGVmdCxyZ2JhKDAsMCwwLC41KSxyZ2JhKDAsMCwwLDApKX0uc3dpcGVyLTNkIC5zd2lwZXItc2xpZGUtc2hhZG93LXJpZ2h0e2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LHJnYmEoMCwwLDAsLjUpLHJnYmEoMCwwLDAsMCkpfS5zd2lwZXItM2QgLnN3aXBlci1zbGlkZS1zaGFkb3ctdG9we2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIHRvcCxyZ2JhKDAsMCwwLC41KSxyZ2JhKDAsMCwwLDApKX0uc3dpcGVyLTNkIC5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbXtiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudCh0byBib3R0b20scmdiYSgwLDAsMCwuNSkscmdiYSgwLDAsMCwwKSl9LnN3aXBlci1jc3MtbW9kZT4uc3dpcGVyLXdyYXBwZXJ7b3ZlcmZsb3c6YXV0bztzY3JvbGxiYXItd2lkdGg6bm9uZTstbXMtb3ZlcmZsb3ctc3R5bGU6bm9uZX0uc3dpcGVyLWNzcy1tb2RlPi5zd2lwZXItd3JhcHBlcjo6LXdlYmtpdC1zY3JvbGxiYXJ7ZGlzcGxheTpub25lfS5zd2lwZXItY3NzLW1vZGU+LnN3aXBlci13cmFwcGVyPi5zd2lwZXItc2xpZGV7c2Nyb2xsLXNuYXAtYWxpZ246c3RhcnQgc3RhcnR9LnN3aXBlci1ob3Jpem9udGFsLnN3aXBlci1jc3MtbW9kZT4uc3dpcGVyLXdyYXBwZXJ7c2Nyb2xsLXNuYXAtdHlwZTp4IG1hbmRhdG9yeX0uc3dpcGVyLXZlcnRpY2FsLnN3aXBlci1jc3MtbW9kZT4uc3dpcGVyLXdyYXBwZXJ7c2Nyb2xsLXNuYXAtdHlwZTp5IG1hbmRhdG9yeX0uc3dpcGVyLWNlbnRlcmVkPi5zd2lwZXItd3JhcHBlcjo6YmVmb3Jle2NvbnRlbnQ6Jyc7ZmxleC1zaHJpbms6MDtvcmRlcjo5OTk5fS5zd2lwZXItY2VudGVyZWQuc3dpcGVyLWhvcml6b250YWw+LnN3aXBlci13cmFwcGVyPi5zd2lwZXItc2xpZGU6Zmlyc3QtY2hpbGR7LXdlYmtpdC1tYXJnaW4tc3RhcnQ6dmFyKC0tc3dpcGVyLWNlbnRlcmVkLW9mZnNldC1iZWZvcmUpO21hcmdpbi1pbmxpbmUtc3RhcnQ6dmFyKC0tc3dpcGVyLWNlbnRlcmVkLW9mZnNldC1iZWZvcmUpfS5zd2lwZXItY2VudGVyZWQuc3dpcGVyLWhvcml6b250YWw+LnN3aXBlci13cmFwcGVyOjpiZWZvcmV7aGVpZ2h0OjEwMCU7bWluLWhlaWdodDoxcHg7d2lkdGg6dmFyKC0tc3dpcGVyLWNlbnRlcmVkLW9mZnNldC1hZnRlcil9LnN3aXBlci1jZW50ZXJlZC5zd2lwZXItdmVydGljYWw+LnN3aXBlci13cmFwcGVyPi5zd2lwZXItc2xpZGU6Zmlyc3QtY2hpbGR7LXdlYmtpdC1tYXJnaW4tYmVmb3JlOnZhcigtLXN3aXBlci1jZW50ZXJlZC1vZmZzZXQtYmVmb3JlKTttYXJnaW4tYmxvY2stc3RhcnQ6dmFyKC0tc3dpcGVyLWNlbnRlcmVkLW9mZnNldC1iZWZvcmUpfS5zd2lwZXItY2VudGVyZWQuc3dpcGVyLXZlcnRpY2FsPi5zd2lwZXItd3JhcHBlcjo6YmVmb3Jle3dpZHRoOjEwMCU7bWluLXdpZHRoOjFweDtoZWlnaHQ6dmFyKC0tc3dpcGVyLWNlbnRlcmVkLW9mZnNldC1hZnRlcil9LnN3aXBlci1jZW50ZXJlZD4uc3dpcGVyLXdyYXBwZXI+LnN3aXBlci1zbGlkZXtzY3JvbGwtc25hcC1hbGlnbjpjZW50ZXIgY2VudGVyO3Njcm9sbC1zbmFwLXN0b3A6YWx3YXlzfVwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9ub2RlX21vZHVsZXMvc3dpcGVyL3N3aXBlci5taW4uY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBOzs7Ozs7Ozs7O0VBVUU7O0FBRUYsV0FBVyx3QkFBd0IsQ0FBQyw0ckVBQTRyRSxDQUFDLGVBQWUsQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLDRCQUE0QixDQUFDLFFBQVEsZ0JBQWdCLENBQUMsaUJBQWlCLENBQUMsaUJBQWlCLENBQUMsZUFBZSxDQUFDLGVBQWUsQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLGlDQUFpQyxxQkFBcUIsQ0FBQyxnQkFBZ0IsaUJBQWlCLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLDZCQUE2QixDQUFDLHNCQUFzQixDQUFDLDhDQUE4Qyw4QkFBOEIsQ0FBQyx1QkFBdUIsa0JBQWtCLENBQUMsdUNBQXVDLGtCQUFrQixDQUFDLGNBQWMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsaUJBQWlCLENBQUMsNkJBQTZCLENBQUMsOEJBQThCLGlCQUFpQixDQUFDLG9EQUFvRCxXQUFXLENBQUMsbUNBQW1DLHNCQUFzQixDQUFDLG9DQUFvQyxDQUFDLHNDQUFzQyx1QkFBdUIsQ0FBQyxrQ0FBa0MsQ0FBQywwQkFBMEIsQ0FBQyxzREFBc0Qsa0JBQWtCLENBQUMseVFBQXlRLDJCQUEyQixDQUFDLHNMQUFzTCxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsbUJBQW1CLENBQUMsVUFBVSxDQUFDLGdDQUFnQywwQkFBMEIsQ0FBQyxxQ0FBcUMsc0VBQXNFLENBQUMsc0NBQXNDLHVFQUF1RSxDQUFDLG9DQUFvQyxxRUFBcUUsQ0FBQyx1Q0FBdUMsd0VBQXdFLENBQUMsaUNBQWlDLGFBQWEsQ0FBQyxvQkFBb0IsQ0FBQyx1QkFBdUIsQ0FBQyxvREFBb0QsWUFBWSxDQUFDLCtDQUErQyw2QkFBNkIsQ0FBQyxtREFBbUQsNEJBQTRCLENBQUMsaURBQWlELDRCQUE0QixDQUFDLHlDQUF5QyxVQUFVLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyw2RUFBNkUseURBQXVELENBQXZELHdEQUF3RCxDQUFDLDJEQUEyRCxXQUFXLENBQUMsY0FBYyxDQUFDLHlDQUF5QyxDQUFDLDJFQUEyRSwwREFBc0QsQ0FBdEQsdURBQXVELENBQUMseURBQXlELFVBQVUsQ0FBQyxhQUFhLENBQUMsMENBQTBDLENBQUMsK0NBQStDLCtCQUErQixDQUFDLHVCQUF1QlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIvKipcXG4gKiBTd2lwZXIgOC40LjdcXG4gKiBNb3N0IG1vZGVybiBtb2JpbGUgdG91Y2ggc2xpZGVyIGFuZCBmcmFtZXdvcmsgd2l0aCBoYXJkd2FyZSBhY2NlbGVyYXRlZCB0cmFuc2l0aW9uc1xcbiAqIGh0dHBzOi8vc3dpcGVyanMuY29tXFxuICpcXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDIzIFZsYWRpbWlyIEtoYXJsYW1waWRpXFxuICpcXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcXG4gKlxcbiAqIFJlbGVhc2VkIG9uOiBKYW51YXJ5IDMwLCAyMDIzXFxuICovXFxuXFxuQGZvbnQtZmFjZXtmb250LWZhbWlseTpzd2lwZXItaWNvbnM7c3JjOnVybCgnZGF0YTphcHBsaWNhdGlvbi9mb250LXdvZmY7Y2hhcnNldD11dGYtODtiYXNlNjQsIGQwOUdSZ0FCQUFBQUFBWmdBQkFBQUFBQURBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCR1JsUk5BQUFHUkFBQUFCb0FBQUFjaTZxSGtVZEVSVVlBQUFXZ0FBQUFJd0FBQUNRQVlBQlhSMUJQVXdBQUJoUUFBQUF1QUFBQU51QVk3K3hIVTFWQ0FBQUZ4QUFBQUZBQUFBQm0yZlBjelU5VEx6SUFBQUhjQUFBQVNnQUFBR0JQOVY1UlkyMWhjQUFBQWtRQUFBQ0lBQUFCWXQ2RjBjQmpkblFnQUFBQ3pBQUFBQVFBQUFBRUFCRUJSR2RoYzNBQUFBV1lBQUFBQ0FBQUFBai8vd0FEWjJ4NVpnQUFBeXdBQUFETUFBQUQyTUh0cnlWb1pXRmtBQUFCYkFBQUFEQUFBQUEyRTIrZW9XaG9aV0VBQUFHY0FBQUFId0FBQUNRQzlnRHphRzEwZUFBQUFpZ0FBQUFaQUFBQXJnSmtBQkZzYjJOaEFBQUMwQUFBQUZvQUFBQmFGUUFVR0cxaGVIQUFBQUc4QUFBQUh3QUFBQ0FBY0FCQWJtRnRaUUFBQS9nQUFBRTVBQUFDWHZGZEJ3bHdiM04wQUFBRk5BQUFBR0lBQUFDRTVzNzRoWGphWTJCa1lHQUFZcGY1SHUvaitXMitNbkF6TVlEQXphWDZRakQ2LzQvL0J4ajVHQThBdVJ3TVlHa0FQeXdMMTNqYVkyQmtZR0E4OFA4QWd4NGorLzhmUURZZkExQUVCV2dEQUlCMkJPb0FlTnBqWUdSZ1lOQmg0R2RnWWdBQkVNbklBQkp6WU5BRENRQUFDV2dBc1FCNDJtTmdZZnpDT0lHQmxZR0IwWWN4allHQndSMUtmMldRWkdoaFlHQmlZR1ZtZ0FGR0JpUVFrT2Fhd3REQW9NQlF4WGpnL3dFR1BjWUREQTR3TlVBMkNDZ3dzQUFBTzRFTDZnQUFlTnBqMk0wZ3lBQUNxeGdHTldCa1oyRDQvd01BK3hrRGRnQUFBSGphWTJCZ1lHYUFZQmtHUmdZUWlBSHlHTUY4RmdZSElNM0R3TUhBQkdRck1PZ3lXRExFTTFUOS93OFVCZkVNZ0x6RS8vLy9QLzUvL2YvVi94dityNGVhQUFlTWJBeHdJVVltSU1IRWdLWUFZalVjc0RBd3NMS3hjM0J5Y2ZQdzhqRVFBL2daQkFTRmhFVkV4Y1FsSktXa1pXVGw1QlVVbFpSVlZOWFVOVFFaQmdNQUFNUitFK2dBRVFGRUFBQUFLZ0FxQUNvQU5BQStBRWdBVWdCY0FHWUFjQUI2QUlRQWpnQ1lBS0lBckFDMkFNQUF5Z0RVQU40QTZBRHlBUHdCQmdFUUFSb0JKQUV1QVRnQlFnRk1BVllCWUFGcUFYUUJmZ0dJQVpJQm5BR21BYklCemdIc0FBQjQydTJOTVE2Q1VBeUdXNTY4eDlBbmVZWWdtNE1KYmhLRmFFeElPQVZYOEFwZXdTdDRCaWM0QWZlQWlkM1ZPQml4RHhmUFlFemE1TytYZmkwNFlBRGdnaVVJVUxDdUVKSzhWaE80YlN2cGRua3RISTVRQ1l0ZGkyc2w4Wm5YYUhscVVyTkt6ZEtjVDhjamxxK3J3WlN2SVZjek5pZXpzZm5QL3V6bm1mUEZCTk9ETTJLN01UUTQ1WUVBWnFHUDgxQW1HR2NGM2lQcU9vcDByMVNQVGFUYlZrZlVlNEhYajk3d1lFK3lOd1dZeHdXdTR2MXVnV0hnbzNTMVhkWkVWcVdNN0VUMGNmbkxHeFdma2dSNDJvMlB2V3JETUJTRmovSUhMYUYwektqUmdkaVZNd1NjTlJBb1dVb0g3OFkyaWNCL3lJWTA5QW42QUgyQmR1L1VCK3l4b3BZc2hRaUV2bnZ1MGRVUmdEdDhRZUM4UER3N0ZwamkzZkVBNHovUEVKNllPQjVoS2g0ZGozRXZYaHhQcUgvU0tVWTNySjdzclo0RlpuaDFQTUF0UGh3UDZmbDJQTUpNUERnZVE0clk4WVQ2R3phbzBlQUVBNDA5RHVnZ21UbkZuT2NTQ2lFaUxNZ3hDaVRJNkNxNURaVWQzUW1wMTB2TzBMYUxUZDJjak40Zk91bWxjN2xVWWJTUWNaRmt1dFJHN2c2SktaS3kwUm1kTFk2ODBDRG5FSitVTWtwRkZlMVJON254ZFZwWHJDNGFUdG5hdXJPblllcmNaZzJZVm1MTi9kL2djemZFaW1yRS9mcy9iT3VxMjlabW44dGxvT1JhWGdaZ0dhNzh5TzkvY25YbTJCcGFHdnEyNUR2OVM0RTkrNVNJYzlQcXVwSktoWUZTU2w0NytRY3IxbVlOQUFBQWVOcHR3MGNLd2tBQUFNRFpKQThRN09VSnZrTHNQZlo2ekZWRVJQeThxSGgyWUVSKzNpL0JQODN2SUJMTHlTc29LaW1ycUtxcGEyaHA2K2pxNlJzWUdobWJtSnFaU3kwc3JheHRiTzNzSFJ5ZG5FTVU0dVI2eXg3SkpYdmVQN1dyRHljQUFBQUFBQUgvL3dBQ2VOcGpZR1JnWU9BQlloa2daZ0pDWmdaTkJrWUdMUVp0SUpzRkxNWUFBQXczQUxnQWVOb2xpekVLZ0RBUUJDY2hSYkMyc0ZFUjBZRDZxVlFpQkN2L0g5ZXpHSTZaNVhCQXc4Q0JLL201aVFRVmF1VmJYTG5Pck1adjJvTGRLRmE4UGp1cnUyaEp6R2FibU9TTHpOTXp2dXRwQjNONDJtTmdaR0JnNEdLUVl6QmhZTXhKTE1sajRHQmdBWW93L1AvUEFKSmhMTTZzU29XS2ZXQ0FBd0RBamdiUkFBQjQybU5nWUdCa0FJSWJDWm81SVBybVVuMGhHQTBBTzhFRlRRQUEnKTtmb250LXdlaWdodDo0MDA7Zm9udC1zdHlsZTpub3JtYWx9OnJvb3R7LS1zd2lwZXItdGhlbWUtY29sb3I6IzAwN2FmZn0uc3dpcGVye21hcmdpbi1sZWZ0OmF1dG87bWFyZ2luLXJpZ2h0OmF1dG87cG9zaXRpb246cmVsYXRpdmU7b3ZlcmZsb3c6aGlkZGVuO2xpc3Qtc3R5bGU6bm9uZTtwYWRkaW5nOjA7ei1pbmRleDoxfS5zd2lwZXItdmVydGljYWw+LnN3aXBlci13cmFwcGVye2ZsZXgtZGlyZWN0aW9uOmNvbHVtbn0uc3dpcGVyLXdyYXBwZXJ7cG9zaXRpb246cmVsYXRpdmU7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTt6LWluZGV4OjE7ZGlzcGxheTpmbGV4O3RyYW5zaXRpb24tcHJvcGVydHk6dHJhbnNmb3JtO2JveC1zaXppbmc6Y29udGVudC1ib3h9LnN3aXBlci1hbmRyb2lkIC5zd2lwZXItc2xpZGUsLnN3aXBlci13cmFwcGVye3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwcHgsMCwwKX0uc3dpcGVyLXBvaW50ZXItZXZlbnRze3RvdWNoLWFjdGlvbjpwYW4teX0uc3dpcGVyLXBvaW50ZXItZXZlbnRzLnN3aXBlci12ZXJ0aWNhbHt0b3VjaC1hY3Rpb246cGFuLXh9LnN3aXBlci1zbGlkZXtmbGV4LXNocmluazowO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7cG9zaXRpb246cmVsYXRpdmU7dHJhbnNpdGlvbi1wcm9wZXJ0eTp0cmFuc2Zvcm19LnN3aXBlci1zbGlkZS1pbnZpc2libGUtYmxhbmt7dmlzaWJpbGl0eTpoaWRkZW59LnN3aXBlci1hdXRvaGVpZ2h0LC5zd2lwZXItYXV0b2hlaWdodCAuc3dpcGVyLXNsaWRle2hlaWdodDphdXRvfS5zd2lwZXItYXV0b2hlaWdodCAuc3dpcGVyLXdyYXBwZXJ7YWxpZ24taXRlbXM6ZmxleC1zdGFydDt0cmFuc2l0aW9uLXByb3BlcnR5OnRyYW5zZm9ybSxoZWlnaHR9LnN3aXBlci1iYWNrZmFjZS1oaWRkZW4gLnN3aXBlci1zbGlkZXt0cmFuc2Zvcm06dHJhbnNsYXRlWigwKTstd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6aGlkZGVuO2JhY2tmYWNlLXZpc2liaWxpdHk6aGlkZGVufS5zd2lwZXItM2QsLnN3aXBlci0zZC5zd2lwZXItY3NzLW1vZGUgLnN3aXBlci13cmFwcGVye3BlcnNwZWN0aXZlOjEyMDBweH0uc3dpcGVyLTNkIC5zd2lwZXItY3ViZS1zaGFkb3csLnN3aXBlci0zZCAuc3dpcGVyLXNsaWRlLC5zd2lwZXItM2QgLnN3aXBlci1zbGlkZS1zaGFkb3csLnN3aXBlci0zZCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b20sLnN3aXBlci0zZCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1sZWZ0LC5zd2lwZXItM2QgLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHQsLnN3aXBlci0zZCAuc3dpcGVyLXNsaWRlLXNoYWRvdy10b3AsLnN3aXBlci0zZCAuc3dpcGVyLXdyYXBwZXJ7dHJhbnNmb3JtLXN0eWxlOnByZXNlcnZlLTNkfS5zd2lwZXItM2QgLnN3aXBlci1zbGlkZS1zaGFkb3csLnN3aXBlci0zZCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b20sLnN3aXBlci0zZCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1sZWZ0LC5zd2lwZXItM2QgLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHQsLnN3aXBlci0zZCAuc3dpcGVyLXNsaWRlLXNoYWRvdy10b3B7cG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDowO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7cG9pbnRlci1ldmVudHM6bm9uZTt6LWluZGV4OjEwfS5zd2lwZXItM2QgLnN3aXBlci1zbGlkZS1zaGFkb3d7YmFja2dyb3VuZDpyZ2JhKDAsMCwwLC4xNSl9LnN3aXBlci0zZCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1sZWZ0e2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIGxlZnQscmdiYSgwLDAsMCwuNSkscmdiYSgwLDAsMCwwKSl9LnN3aXBlci0zZCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodHtiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudCh0byByaWdodCxyZ2JhKDAsMCwwLC41KSxyZ2JhKDAsMCwwLDApKX0uc3dpcGVyLTNkIC5zd2lwZXItc2xpZGUtc2hhZG93LXRvcHtiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudCh0byB0b3AscmdiYSgwLDAsMCwuNSkscmdiYSgwLDAsMCwwKSl9LnN3aXBlci0zZCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b217YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLHJnYmEoMCwwLDAsLjUpLHJnYmEoMCwwLDAsMCkpfS5zd2lwZXItY3NzLW1vZGU+LnN3aXBlci13cmFwcGVye292ZXJmbG93OmF1dG87c2Nyb2xsYmFyLXdpZHRoOm5vbmU7LW1zLW92ZXJmbG93LXN0eWxlOm5vbmV9LnN3aXBlci1jc3MtbW9kZT4uc3dpcGVyLXdyYXBwZXI6Oi13ZWJraXQtc2Nyb2xsYmFye2Rpc3BsYXk6bm9uZX0uc3dpcGVyLWNzcy1tb2RlPi5zd2lwZXItd3JhcHBlcj4uc3dpcGVyLXNsaWRle3Njcm9sbC1zbmFwLWFsaWduOnN0YXJ0IHN0YXJ0fS5zd2lwZXItaG9yaXpvbnRhbC5zd2lwZXItY3NzLW1vZGU+LnN3aXBlci13cmFwcGVye3Njcm9sbC1zbmFwLXR5cGU6eCBtYW5kYXRvcnl9LnN3aXBlci12ZXJ0aWNhbC5zd2lwZXItY3NzLW1vZGU+LnN3aXBlci13cmFwcGVye3Njcm9sbC1zbmFwLXR5cGU6eSBtYW5kYXRvcnl9LnN3aXBlci1jZW50ZXJlZD4uc3dpcGVyLXdyYXBwZXI6OmJlZm9yZXtjb250ZW50OicnO2ZsZXgtc2hyaW5rOjA7b3JkZXI6OTk5OX0uc3dpcGVyLWNlbnRlcmVkLnN3aXBlci1ob3Jpem9udGFsPi5zd2lwZXItd3JhcHBlcj4uc3dpcGVyLXNsaWRlOmZpcnN0LWNoaWxke21hcmdpbi1pbmxpbmUtc3RhcnQ6dmFyKC0tc3dpcGVyLWNlbnRlcmVkLW9mZnNldC1iZWZvcmUpfS5zd2lwZXItY2VudGVyZWQuc3dpcGVyLWhvcml6b250YWw+LnN3aXBlci13cmFwcGVyOjpiZWZvcmV7aGVpZ2h0OjEwMCU7bWluLWhlaWdodDoxcHg7d2lkdGg6dmFyKC0tc3dpcGVyLWNlbnRlcmVkLW9mZnNldC1hZnRlcil9LnN3aXBlci1jZW50ZXJlZC5zd2lwZXItdmVydGljYWw+LnN3aXBlci13cmFwcGVyPi5zd2lwZXItc2xpZGU6Zmlyc3QtY2hpbGR7bWFyZ2luLWJsb2NrLXN0YXJ0OnZhcigtLXN3aXBlci1jZW50ZXJlZC1vZmZzZXQtYmVmb3JlKX0uc3dpcGVyLWNlbnRlcmVkLnN3aXBlci12ZXJ0aWNhbD4uc3dpcGVyLXdyYXBwZXI6OmJlZm9yZXt3aWR0aDoxMDAlO21pbi13aWR0aDoxcHg7aGVpZ2h0OnZhcigtLXN3aXBlci1jZW50ZXJlZC1vZmZzZXQtYWZ0ZXIpfS5zd2lwZXItY2VudGVyZWQ+LnN3aXBlci13cmFwcGVyPi5zd2lwZXItc2xpZGV7c2Nyb2xsLXNuYXAtYWxpZ246Y2VudGVyIGNlbnRlcjtzY3JvbGwtc25hcC1zdG9wOmFsd2F5c31cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./node_modules/swiper/swiper.min.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./styles/globals.css":
/*!********************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./styles/globals.css ***!
  \********************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_index_js_ruleSet_1_rules_3_oneOf_9_use_1_node_modules_next_dist_build_webpack_loaders_postcss_loader_src_index_js_ruleSet_1_rules_3_oneOf_9_use_2_node_modules_swiper_swiper_min_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! -!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!../node_modules/swiper/swiper.min.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./node_modules/swiper/swiper.min.css\");\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_index_js_ruleSet_1_rules_3_oneOf_9_use_1_node_modules_next_dist_build_webpack_loaders_postcss_loader_src_index_js_ruleSet_1_rules_3_oneOf_9_use_2_node_modules_swiper_modules_navigation_navigation_min_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! -!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!../node_modules/swiper/modules/navigation/navigation.min.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./node_modules/swiper/modules/navigation/navigation.min.css\");\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_index_js_ruleSet_1_rules_3_oneOf_9_use_1_node_modules_next_dist_build_webpack_loaders_postcss_loader_src_index_js_ruleSet_1_rules_3_oneOf_9_use_2_node_modules_swiper_modules_pagination_pagination_min_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! -!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!../node_modules/swiper/modules/pagination/pagination.min.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./node_modules/swiper/modules/pagination/pagination.min.css\");\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_index_js_ruleSet_1_rules_3_oneOf_9_use_1_node_modules_next_dist_build_webpack_loaders_postcss_loader_src_index_js_ruleSet_1_rules_3_oneOf_9_use_2_node_modules_swiper_modules_scrollbar_scrollbar_min_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! -!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!../node_modules/swiper/modules/scrollbar/scrollbar.min.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./node_modules/swiper/modules/scrollbar/scrollbar.min.css\");\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_index_js_ruleSet_1_rules_3_oneOf_9_use_1_node_modules_next_dist_build_webpack_loaders_postcss_loader_src_index_js_ruleSet_1_rules_3_oneOf_9_use_2_node_modules_swiper_modules_effect_fade_effect_fade_min_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! -!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!../node_modules/swiper/modules/effect-fade/effect-fade.min.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./node_modules/swiper/modules/effect-fade/effect-fade.min.css\");\n// Imports\n\n\n\n\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);\n___CSS_LOADER_EXPORT___.i(_node_modules_next_dist_build_webpack_loaders_css_loader_src_index_js_ruleSet_1_rules_3_oneOf_9_use_1_node_modules_next_dist_build_webpack_loaders_postcss_loader_src_index_js_ruleSet_1_rules_3_oneOf_9_use_2_node_modules_swiper_swiper_min_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n___CSS_LOADER_EXPORT___.i(_node_modules_next_dist_build_webpack_loaders_css_loader_src_index_js_ruleSet_1_rules_3_oneOf_9_use_1_node_modules_next_dist_build_webpack_loaders_postcss_loader_src_index_js_ruleSet_1_rules_3_oneOf_9_use_2_node_modules_swiper_modules_navigation_navigation_min_css__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\n___CSS_LOADER_EXPORT___.i(_node_modules_next_dist_build_webpack_loaders_css_loader_src_index_js_ruleSet_1_rules_3_oneOf_9_use_1_node_modules_next_dist_build_webpack_loaders_postcss_loader_src_index_js_ruleSet_1_rules_3_oneOf_9_use_2_node_modules_swiper_modules_pagination_pagination_min_css__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\n___CSS_LOADER_EXPORT___.i(_node_modules_next_dist_build_webpack_loaders_css_loader_src_index_js_ruleSet_1_rules_3_oneOf_9_use_1_node_modules_next_dist_build_webpack_loaders_postcss_loader_src_index_js_ruleSet_1_rules_3_oneOf_9_use_2_node_modules_swiper_modules_scrollbar_scrollbar_min_css__WEBPACK_IMPORTED_MODULE_4__[\"default\"]);\n___CSS_LOADER_EXPORT___.i(_node_modules_next_dist_build_webpack_loaders_css_loader_src_index_js_ruleSet_1_rules_3_oneOf_9_use_1_node_modules_next_dist_build_webpack_loaders_postcss_loader_src_index_js_ruleSet_1_rules_3_oneOf_9_use_2_node_modules_swiper_modules_effect_fade_effect_fade_min_css__WEBPACK_IMPORTED_MODULE_5__[\"default\"]);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/* image popup */\\r\\nimg.mfp-img {\\r\\n  box-shadow: 0 0 8px rgb(0 0 0 / 60%);\\r\\n  position: absolute;\\r\\n  max-height: 392px;\\r\\n  padding: 0 !important;\\r\\n  top: 50%;\\r\\n  left: 50%;\\r\\n  transform: translate(-50%, -50%);\\r\\n}\\r\\n.mfp-img-container .mfp-content {\\r\\n  max-width: 400px !important;\\r\\n}\\r\\n.mfp-img-container .mfp-close {\\r\\n  top: -110px;\\r\\n  right: -24px;\\r\\n}\\r\\n\\r\\n.google {\\r\\n  filter: grayscale(1);\\r\\n  position: relative;\\r\\n  height: 200px;\\r\\n}\\r\\n.google iframe {\\r\\n  position: absolute;\\r\\n  left: 0;\\r\\n  right: 0;\\r\\n  bottom: 0;\\r\\n}\\r\\n\\r\\n#slides,\\r\\n#slides .swiper,\\r\\n#slides img {\\r\\n  height: 100%;\\r\\n}\\r\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://styles/globals.css\"],\"names\":[],\"mappings\":\"AAMA,gBAAgB;AAChB;EACE,oCAAoC;EACpC,kBAAkB;EAClB,iBAAiB;EACjB,qBAAqB;EACrB,QAAQ;EACR,SAAS;EACT,gCAAgC;AAClC;AACA;EACE,2BAA2B;AAC7B;AACA;EACE,WAAW;EACX,YAAY;AACd;;AAEA;EACE,oBAAoB;EACpB,kBAAkB;EAClB,aAAa;AACf;AACA;EACE,kBAAkB;EAClB,OAAO;EACP,QAAQ;EACR,SAAS;AACX;;AAEA;;;EAGE,YAAY;AACd\",\"sourcesContent\":[\"@import \\\"swiper/css\\\";\\r\\n@import \\\"swiper/css/navigation\\\";\\r\\n@import \\\"swiper/css/pagination\\\";\\r\\n@import \\\"swiper/css/scrollbar\\\";\\r\\n@import \\\"swiper/css/effect-fade\\\";\\r\\n\\r\\n/* image popup */\\r\\nimg.mfp-img {\\r\\n  box-shadow: 0 0 8px rgb(0 0 0 / 60%);\\r\\n  position: absolute;\\r\\n  max-height: 392px;\\r\\n  padding: 0 !important;\\r\\n  top: 50%;\\r\\n  left: 50%;\\r\\n  transform: translate(-50%, -50%);\\r\\n}\\r\\n.mfp-img-container .mfp-content {\\r\\n  max-width: 400px !important;\\r\\n}\\r\\n.mfp-img-container .mfp-close {\\r\\n  top: -110px;\\r\\n  right: -24px;\\r\\n}\\r\\n\\r\\n.google {\\r\\n  filter: grayscale(1);\\r\\n  position: relative;\\r\\n  height: 200px;\\r\\n}\\r\\n.google iframe {\\r\\n  position: absolute;\\r\\n  left: 0;\\r\\n  right: 0;\\r\\n  bottom: 0;\\r\\n}\\r\\n\\r\\n#slides,\\r\\n#slides .swiper,\\r\\n#slides img {\\r\\n  height: 100%;\\r\\n}\\r\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls5XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOV0udXNlWzJdIS4vc3R5bGVzL2dsb2JhbHMuY3NzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDd0g7QUFDOEw7QUFDdUI7QUFDQTtBQUNGO0FBQ0k7QUFDL1UsOEJBQThCLGtIQUEyQjtBQUN6RCwwQkFBMEIseVJBQWlDO0FBQzNELDBCQUEwQixnVEFBaUM7QUFDM0QsMEJBQTBCLGdUQUFpQztBQUMzRCwwQkFBMEIsOFNBQWlDO0FBQzNELDBCQUEwQixrVEFBaUM7QUFDM0Q7QUFDQSw0RUFBNEUsMkNBQTJDLHlCQUF5Qix3QkFBd0IsNEJBQTRCLGVBQWUsZ0JBQWdCLHVDQUF1QyxLQUFLLHFDQUFxQyxrQ0FBa0MsS0FBSyxtQ0FBbUMsa0JBQWtCLG1CQUFtQixLQUFLLGlCQUFpQiwyQkFBMkIseUJBQXlCLG9CQUFvQixLQUFLLG9CQUFvQix5QkFBeUIsY0FBYyxlQUFlLGdCQUFnQixLQUFLLHFEQUFxRCxtQkFBbUIsS0FBSyxXQUFXLDBGQUEwRixNQUFNLFlBQVksYUFBYSxhQUFhLGFBQWEsV0FBVyxVQUFVLFlBQVksTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLFVBQVUsVUFBVSxNQUFNLEtBQUssWUFBWSxhQUFhLFdBQVcsS0FBSyxLQUFLLFlBQVksV0FBVyxVQUFVLFVBQVUsTUFBTSxPQUFPLFVBQVUsZ0RBQWdELHNDQUFzQyxzQ0FBc0MscUNBQXFDLHVDQUF1QywwQ0FBMEMsMkNBQTJDLHlCQUF5Qix3QkFBd0IsNEJBQTRCLGVBQWUsZ0JBQWdCLHVDQUF1QyxLQUFLLHFDQUFxQyxrQ0FBa0MsS0FBSyxtQ0FBbUMsa0JBQWtCLG1CQUFtQixLQUFLLGlCQUFpQiwyQkFBMkIseUJBQXlCLG9CQUFvQixLQUFLLG9CQUFvQix5QkFBeUIsY0FBYyxlQUFlLGdCQUFnQixLQUFLLHFEQUFxRCxtQkFBbUIsS0FBSyx1QkFBdUI7QUFDajVEO0FBQ0EsK0RBQWUsdUJBQXVCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3R5bGVzL2dsb2JhbHMuY3NzPzRiNTYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzBfX18gZnJvbSBcIi0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOV0udXNlWzFdIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls5XS51c2VbMl0hLi4vbm9kZV9tb2R1bGVzL3N3aXBlci9zd2lwZXIubWluLmNzc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfMV9fXyBmcm9tIFwiLSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls5XS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzldLnVzZVsyXSEuLi9ub2RlX21vZHVsZXMvc3dpcGVyL21vZHVsZXMvbmF2aWdhdGlvbi9uYXZpZ2F0aW9uLm1pbi5jc3NcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzJfX18gZnJvbSBcIi0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOV0udXNlWzFdIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls5XS51c2VbMl0hLi4vbm9kZV9tb2R1bGVzL3N3aXBlci9tb2R1bGVzL3BhZ2luYXRpb24vcGFnaW5hdGlvbi5taW4uY3NzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8zX19fIGZyb20gXCItIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzldLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOV0udXNlWzJdIS4uL25vZGVfbW9kdWxlcy9zd2lwZXIvbW9kdWxlcy9zY3JvbGxiYXIvc2Nyb2xsYmFyLm1pbi5jc3NcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzRfX18gZnJvbSBcIi0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOV0udXNlWzFdIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls5XS51c2VbMl0hLi4vbm9kZV9tb2R1bGVzL3N3aXBlci9tb2R1bGVzL2VmZmVjdC1mYWRlL2VmZmVjdC1mYWRlLm1pbi5jc3NcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmkoX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8wX19fKTtcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmkoX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8xX19fKTtcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmkoX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8yX19fKTtcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmkoX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8zX19fKTtcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmkoX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF80X19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi8qIGltYWdlIHBvcHVwICovXFxyXFxuaW1nLm1mcC1pbWcge1xcclxcbiAgYm94LXNoYWRvdzogMCAwIDhweCByZ2IoMCAwIDAgLyA2MCUpO1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgbWF4LWhlaWdodDogMzkycHg7XFxyXFxuICBwYWRkaW5nOiAwICFpbXBvcnRhbnQ7XFxyXFxuICB0b3A6IDUwJTtcXHJcXG4gIGxlZnQ6IDUwJTtcXHJcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xcclxcbn1cXHJcXG4ubWZwLWltZy1jb250YWluZXIgLm1mcC1jb250ZW50IHtcXHJcXG4gIG1heC13aWR0aDogNDAwcHggIWltcG9ydGFudDtcXHJcXG59XFxyXFxuLm1mcC1pbWctY29udGFpbmVyIC5tZnAtY2xvc2Uge1xcclxcbiAgdG9wOiAtMTEwcHg7XFxyXFxuICByaWdodDogLTI0cHg7XFxyXFxufVxcclxcblxcclxcbi5nb29nbGUge1xcclxcbiAgZmlsdGVyOiBncmF5c2NhbGUoMSk7XFxyXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuICBoZWlnaHQ6IDIwMHB4O1xcclxcbn1cXHJcXG4uZ29vZ2xlIGlmcmFtZSB7XFxyXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICBsZWZ0OiAwO1xcclxcbiAgcmlnaHQ6IDA7XFxyXFxuICBib3R0b206IDA7XFxyXFxufVxcclxcblxcclxcbiNzbGlkZXMsXFxyXFxuI3NsaWRlcyAuc3dpcGVyLFxcclxcbiNzbGlkZXMgaW1nIHtcXHJcXG4gIGhlaWdodDogMTAwJTtcXHJcXG59XFxyXFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL3N0eWxlcy9nbG9iYWxzLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFNQSxnQkFBZ0I7QUFDaEI7RUFDRSxvQ0FBb0M7RUFDcEMsa0JBQWtCO0VBQ2xCLGlCQUFpQjtFQUNqQixxQkFBcUI7RUFDckIsUUFBUTtFQUNSLFNBQVM7RUFDVCxnQ0FBZ0M7QUFDbEM7QUFDQTtFQUNFLDJCQUEyQjtBQUM3QjtBQUNBO0VBQ0UsV0FBVztFQUNYLFlBQVk7QUFDZDs7QUFFQTtFQUNFLG9CQUFvQjtFQUNwQixrQkFBa0I7RUFDbEIsYUFBYTtBQUNmO0FBQ0E7RUFDRSxrQkFBa0I7RUFDbEIsT0FBTztFQUNQLFFBQVE7RUFDUixTQUFTO0FBQ1g7O0FBRUE7OztFQUdFLFlBQVk7QUFDZFwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJAaW1wb3J0IFxcXCJzd2lwZXIvY3NzXFxcIjtcXHJcXG5AaW1wb3J0IFxcXCJzd2lwZXIvY3NzL25hdmlnYXRpb25cXFwiO1xcclxcbkBpbXBvcnQgXFxcInN3aXBlci9jc3MvcGFnaW5hdGlvblxcXCI7XFxyXFxuQGltcG9ydCBcXFwic3dpcGVyL2Nzcy9zY3JvbGxiYXJcXFwiO1xcclxcbkBpbXBvcnQgXFxcInN3aXBlci9jc3MvZWZmZWN0LWZhZGVcXFwiO1xcclxcblxcclxcbi8qIGltYWdlIHBvcHVwICovXFxyXFxuaW1nLm1mcC1pbWcge1xcclxcbiAgYm94LXNoYWRvdzogMCAwIDhweCByZ2IoMCAwIDAgLyA2MCUpO1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgbWF4LWhlaWdodDogMzkycHg7XFxyXFxuICBwYWRkaW5nOiAwICFpbXBvcnRhbnQ7XFxyXFxuICB0b3A6IDUwJTtcXHJcXG4gIGxlZnQ6IDUwJTtcXHJcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xcclxcbn1cXHJcXG4ubWZwLWltZy1jb250YWluZXIgLm1mcC1jb250ZW50IHtcXHJcXG4gIG1heC13aWR0aDogNDAwcHggIWltcG9ydGFudDtcXHJcXG59XFxyXFxuLm1mcC1pbWctY29udGFpbmVyIC5tZnAtY2xvc2Uge1xcclxcbiAgdG9wOiAtMTEwcHg7XFxyXFxuICByaWdodDogLTI0cHg7XFxyXFxufVxcclxcblxcclxcbi5nb29nbGUge1xcclxcbiAgZmlsdGVyOiBncmF5c2NhbGUoMSk7XFxyXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuICBoZWlnaHQ6IDIwMHB4O1xcclxcbn1cXHJcXG4uZ29vZ2xlIGlmcmFtZSB7XFxyXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICBsZWZ0OiAwO1xcclxcbiAgcmlnaHQ6IDA7XFxyXFxuICBib3R0b206IDA7XFxyXFxufVxcclxcblxcclxcbiNzbGlkZXMsXFxyXFxuI3NsaWRlcyAuc3dpcGVyLFxcclxcbiNzbGlkZXMgaW1nIHtcXHJcXG4gIGhlaWdodDogMTAwJTtcXHJcXG59XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./styles/globals.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js ***!
  \************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/ // css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function(useSourceMap) {\n    var list = [] // return the list of modules as css string\n    ;\n    list.toString = function toString() {\n        return this.map(function(item) {\n            var content = cssWithMappingToString(item, useSourceMap);\n            if (item[2]) {\n                return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n            }\n            return content;\n        }).join(\"\");\n    } // import a list of modules into the list\n    ;\n    // eslint-disable-next-line func-names\n    list.i = function(modules, mediaQuery, dedupe) {\n        if (typeof modules === \"string\") {\n            // eslint-disable-next-line no-param-reassign\n            modules = [\n                [\n                    null,\n                    modules,\n                    \"\"\n                ]\n            ];\n        }\n        var alreadyImportedModules = {};\n        if (dedupe) {\n            for(var i = 0; i < this.length; i++){\n                // eslint-disable-next-line prefer-destructuring\n                var id = this[i][0];\n                if (id != null) {\n                    alreadyImportedModules[id] = true;\n                }\n            }\n        }\n        for(var _i = 0; _i < modules.length; _i++){\n            var item = [].concat(modules[_i]);\n            if (dedupe && alreadyImportedModules[item[0]]) {\n                continue;\n            }\n            if (mediaQuery) {\n                if (!item[2]) {\n                    item[2] = mediaQuery;\n                } else {\n                    item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n                }\n            }\n            list.push(item);\n        }\n    };\n    return list;\n};\nfunction cssWithMappingToString(item, useSourceMap) {\n    var content = item[1] || \"\" // eslint-disable-next-line prefer-destructuring\n    ;\n    var cssMapping = item[3];\n    if (!cssMapping) {\n        return content;\n    }\n    if (useSourceMap && typeof btoa === \"function\") {\n        var sourceMapping = toComment(cssMapping);\n        var sourceURLs = cssMapping.sources.map(function(source) {\n            return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n        });\n        return [\n            content\n        ].concat(sourceURLs).concat([\n            sourceMapping\n        ]).join(\"\\n\");\n    }\n    return [\n        content\n    ].join(\"\\n\");\n} // Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n    // eslint-disable-next-line no-undef\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    return \"/*# \".concat(data, \" */\");\n}\n\n//# sourceMappingURL=api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxxQkFBcUI7QUFDekU7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanM/Y2E0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovIC8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcbiAgICB2YXIgbGlzdCA9IFtdIC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcbiAgICA7XG4gICAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG4gICAgICAgICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH0pLmpvaW4oXCJcIik7XG4gICAgfSAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAgIDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgIGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnksIGRlZHVwZSkge1xuICAgICAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgbW9kdWxlcyA9IFtcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZXMsXG4gICAgICAgICAgICAgICAgICAgIFwiXCJcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG4gICAgICAgIGlmIChkZWR1cGUpIHtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xuICAgICAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspe1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfaV0pO1xuICAgICAgICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVtWzJdID0gXCJcIi5jb25jYXQobWVkaWFRdWVyeSwgXCIgYW5kIFwiKS5jb25jYXQoaXRlbVsyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gbGlzdDtcbn07XG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuICAgIHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCBcIlwiIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgIDtcbiAgICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG4gICAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgICBpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG4gICAgICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCBcIlwiKS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBjb250ZW50XG4gICAgICAgIF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbXG4gICAgICAgICAgICBzb3VyY2VNYXBwaW5nXG4gICAgICAgIF0pLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAgIGNvbnRlbnRcbiAgICBdLmpvaW4oXCJcXG5cIik7XG59IC8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcbiAgICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gICAgcmV0dXJuIFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!":
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app! ***!
  \*******************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/_app\",\n      function () {\n        return __webpack_require__(/*! private-next-pages/_app */ \"./pages/_app.js\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/_app\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD1wcml2YXRlLW5leHQtcGFnZXMlMkZfYXBwJnBhZ2U9JTJGX2FwcCEuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxnREFBeUI7QUFDaEQ7QUFDQTtBQUNBLE9BQU8sSUFBVTtBQUNqQixNQUFNLFVBQVU7QUFDaEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzY3ODIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9fYXBwXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwicHJpdmF0ZS1uZXh0LXBhZ2VzL19hcHBcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL19hcHBcIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!\n"));

/***/ }),

/***/ "./styles/globals.css":
/*!****************************!*\
  !*** ./styles/globals.css ***!
  \****************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./styles/globals.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./styles/globals.css\",\n      function () {\n        content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./styles/globals.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvZ2xvYmFscy5jc3MuanMiLCJtYXBwaW5ncyI6IkFBQUEsVUFBVSxtQkFBTyxDQUFDLG9OQUF3RztBQUMxSCwwQkFBMEIsbUJBQU8sQ0FBQyx1ZUFBK087O0FBRWpSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxJQUFJLElBQVU7QUFDZCx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxpQkFBaUI7QUFDckIsTUFBTSx1ZUFBK087QUFDclA7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyx1ZUFBK087O0FBRXpROztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixVQUFVOztBQUUxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsVUFBVTtBQUNaO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3N0eWxlcy9nbG9iYWxzLmNzcz8xNzQ0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBhcGkgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls5XS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzldLnVzZVsyXSEuL2dsb2JhbHMuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCBzdHlsZS1sb2FkZXIgaW5qZWN0cyBDU1MgaW50byB0aGUgYm90dG9tXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIDxoZWFkPi4gVGhpcyBjYXVzZXMgb3JkZXJpbmcgcHJvYmxlbXMgYmV0d2VlbiBkZXZcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHByb2QuIFRvIGZpeCB0aGlzLCB3ZSByZW5kZXIgYSA8bm9zY3JpcHQ+IHRhZyBhc1xuICAgICAgICAgICAgICAgICAgICAvLyBhbiBhbmNob3IgZm9yIHRoZSBzdHlsZXMgdG8gYmUgcGxhY2VkIGJlZm9yZS4gVGhlc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gc3R5bGVzIHdpbGwgYmUgYXBwbGllZCBfYmVmb3JlXyA8c3R5bGUganN4IGdsb2JhbD4uXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmNob3JFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNfX25leHRfY3NzX19ET19OT1RfVVNFX19cIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gYW5jaG9yRWxlbWVudC5wYXJlbnROb2RlLy8gTm9ybWFsbHkgPGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3RcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LCBhbmNob3JFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiLCBpc05hbWVkRXhwb3J0KSB7XG4gICAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBwO1xuICAgIGZvcihwIGluIGEpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFbcF0gIT09IGJbcF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IocCBpbiBiKXtcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYVtwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls5XS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzldLnVzZVsyXSEuL2dsb2JhbHMuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls5XS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzldLnVzZVsyXSEuL2dsb2JhbHMuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./styles/globals.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js ***!
  \************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nconst isOldIE = function isOldIE() {\n    let memo;\n    return function memorize() {\n        if (typeof memo === \"undefined\") {\n            // Test for IE <= 9 as proposed by Browserhacks\n            // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n            // Tests for existence of standard globals is to allow style-loader\n            // to operate correctly into non-standard environments\n            // @see https://github.com/webpack-contrib/style-loader/issues/177\n            memo = Boolean(window && document && document.all && !window.atob);\n        }\n        return memo;\n    };\n}();\nconst getTarget = function getTarget() {\n    const memo = {};\n    return function memorize(target) {\n        if (typeof memo[target] === \"undefined\") {\n            let styleTarget = document.querySelector(target);\n            // Special case to return head of iframe instead of iframe itself\n            if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n                try {\n                    // This will throw an exception if access to iframe is blocked\n                    // due to cross-origin restrictions\n                    styleTarget = styleTarget.contentDocument.head;\n                } catch (e) {\n                    // istanbul ignore next\n                    styleTarget = null;\n                }\n            }\n            memo[target] = styleTarget;\n        }\n        return memo[target];\n    };\n}();\nconst stylesInDom = [];\nfunction getIndexByIdentifier(identifier) {\n    let result = -1;\n    for(let i = 0; i < stylesInDom.length; i++){\n        if (stylesInDom[i].identifier === identifier) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\nfunction modulesToDom(list, options) {\n    const idCountMap = {};\n    const identifiers = [];\n    for(let i = 0; i < list.length; i++){\n        const item = list[i];\n        const id = options.base ? item[0] + options.base : item[0];\n        const count = idCountMap[id] || 0;\n        const identifier = id + \" \" + count.toString();\n        idCountMap[id] = count + 1;\n        const index = getIndexByIdentifier(identifier);\n        const obj = {\n            css: item[1],\n            media: item[2],\n            sourceMap: item[3]\n        };\n        if (index !== -1) {\n            stylesInDom[index].references++;\n            stylesInDom[index].updater(obj);\n        } else {\n            stylesInDom.push({\n                identifier: identifier,\n                updater: addStyle(obj, options),\n                references: 1\n            });\n        }\n        identifiers.push(identifier);\n    }\n    return identifiers;\n}\nfunction insertStyleElement(options) {\n    const style = document.createElement(\"style\");\n    const attributes = options.attributes || {};\n    if (typeof attributes.nonce === \"undefined\") {\n        const nonce = // eslint-disable-next-line no-undef\n         true ? __webpack_require__.nc : 0;\n        if (nonce) {\n            attributes.nonce = nonce;\n        }\n    }\n    Object.keys(attributes).forEach(function(key) {\n        style.setAttribute(key, attributes[key]);\n    });\n    if (typeof options.insert === \"function\") {\n        options.insert(style);\n    } else {\n        const target = getTarget(options.insert || \"head\");\n        if (!target) {\n            throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n        }\n        target.appendChild(style);\n    }\n    return style;\n}\nfunction removeStyleElement(style) {\n    // istanbul ignore if\n    if (style.parentNode === null) {\n        return false;\n    }\n    style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */ const replaceText = function replaceText() {\n    const textStore = [];\n    return function replace(index, replacement) {\n        textStore[index] = replacement;\n        return textStore.filter(Boolean).join(\"\\n\");\n    };\n}();\nfunction applyToSingletonTag(style, index, remove, obj) {\n    const css = remove ? \"\" : obj.media ? \"@media \" + obj.media + \" {\" + obj.css + \"}\" : obj.css;\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = replaceText(index, css);\n    } else {\n        const cssNode = document.createTextNode(css);\n        const childNodes = style.childNodes;\n        if (childNodes[index]) {\n            style.removeChild(childNodes[index]);\n        }\n        if (childNodes.length) {\n            style.insertBefore(cssNode, childNodes[index]);\n        } else {\n            style.appendChild(cssNode);\n        }\n    }\n}\nfunction applyToTag(style, options, obj) {\n    let css = obj.css;\n    const media = obj.media;\n    const sourceMap = obj.sourceMap;\n    if (media) {\n        style.setAttribute(\"media\", media);\n    } else {\n        style.removeAttribute(\"media\");\n    }\n    if (sourceMap && typeof btoa !== \"undefined\") {\n        css += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n    }\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n    } else {\n        while(style.firstChild){\n            style.removeChild(style.firstChild);\n        }\n        style.appendChild(document.createTextNode(css));\n    }\n}\nlet singleton = null;\nlet singletonCounter = 0;\nfunction addStyle(obj, options) {\n    let style;\n    let update;\n    let remove;\n    if (options.singleton) {\n        const styleIndex = singletonCounter++;\n        style = singleton || (singleton = insertStyleElement(options));\n        update = applyToSingletonTag.bind(null, style, styleIndex, false);\n        remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n    } else {\n        style = insertStyleElement(options);\n        update = applyToTag.bind(null, style, options);\n        remove = function() {\n            removeStyleElement(style);\n        };\n    }\n    update(obj);\n    return function updateStyle(newObj) {\n        if (newObj) {\n            if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n                return;\n            }\n            update(obj = newObj);\n        } else {\n            remove();\n        }\n    };\n}\nmodule.exports = function(list, options) {\n    options = options || {};\n    // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n    // tags it will allow on a page\n    if (!options.singleton && typeof options.singleton !== \"boolean\") {\n        options.singleton = isOldIE();\n    }\n    list = list || [];\n    let lastIdentifiers = modulesToDom(list, options);\n    return function update(newList) {\n        newList = newList || [];\n        if (Object.prototype.toString.call(newList) !== \"[object Array]\") {\n            return;\n        }\n        for(let i = 0; i < lastIdentifiers.length; i++){\n            const identifier = lastIdentifiers[i];\n            const index = getIndexByIdentifier(identifier);\n            stylesInDom[index].references--;\n        }\n        const newLastIdentifiers = modulesToDom(newList, options);\n        for(let i1 = 0; i1 < lastIdentifiers.length; i1++){\n            const identifier = lastIdentifiers[i1];\n            const index = getIndexByIdentifier(identifier);\n            if (stylesInDom[index].references === 0) {\n                stylesInDom[index].updater();\n                stylesInDom.splice(index, 1);\n            }\n        }\n        lastIdentifiers = newLastIdentifiers;\n    };\n};\n\n//# sourceMappingURL=injectStylesIntoStyleTag.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUF3QyxHQUFHLHNCQUFpQixHQUFHLENBQUk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EscUVBQXFFLGdCQUFnQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcz8yNmVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgaXNPbGRJRSA9IGZ1bmN0aW9uIGlzT2xkSUUoKSB7XG4gICAgbGV0IG1lbW87XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKCkge1xuICAgICAgICBpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG4gICAgICAgICAgICAvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG4gICAgICAgICAgICAvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG4gICAgICAgICAgICAvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuICAgICAgICAgICAgbWVtbyA9IEJvb2xlYW4od2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgIH07XG59KCk7XG5jb25zdCBnZXRUYXJnZXQgPSBmdW5jdGlvbiBnZXRUYXJnZXQoKSB7XG4gICAgY29uc3QgbWVtbyA9IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSh0YXJnZXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGxldCBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG4gICAgICAgICAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVtb1t0YXJnZXRdO1xuICAgIH07XG59KCk7XG5jb25zdCBzdHlsZXNJbkRvbSA9IFtdO1xuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICAgIGxldCByZXN1bHQgPSAtMTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgc3R5bGVzSW5Eb20ubGVuZ3RoOyBpKyspe1xuICAgICAgICBpZiAoc3R5bGVzSW5Eb21baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmVzdWx0ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGlkQ291bnRNYXAgPSB7fTtcbiAgICBjb25zdCBpZGVudGlmaWVycyA9IFtdO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgY29uc3QgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgIGNvbnN0IGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgICAgIGNvbnN0IGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGlkICsgXCIgXCIgKyBjb3VudC50b1N0cmluZygpO1xuICAgICAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgICAgY29uc3Qgb2JqID0ge1xuICAgICAgICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICAgICAgICBzb3VyY2VNYXA6IGl0ZW1bM11cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMrKztcbiAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZXNJbkRvbS5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuICAgIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25zdCBub25jZSA9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgICB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG4gICAgICAgIGlmIChub25jZSkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5ub25jZSA9IG5vbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQob3B0aW9ucy5pbnNlcnQgfHwgXCJoZWFkXCIpO1xuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGU7XG59XG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgICBpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovIGNvbnN0IHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gcmVwbGFjZVRleHQoKSB7XG4gICAgY29uc3QgdGV4dFN0b3JlID0gW107XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbihcIlxcblwiKTtcbiAgICB9O1xufSgpO1xuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gICAgY29uc3QgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5tZWRpYSA/IFwiQG1lZGlhIFwiICsgb2JqLm1lZGlhICsgXCIge1wiICsgb2JqLmNzcyArIFwifVwiIDogb2JqLmNzcztcbiAgICAvLyBGb3Igb2xkIElFXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqLyBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG4gICAgICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZSwgb3B0aW9ucywgb2JqKSB7XG4gICAgbGV0IGNzcyA9IG9iai5jc3M7XG4gICAgY29uc3QgbWVkaWEgPSBvYmoubWVkaWE7XG4gICAgY29uc3Qgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZShcIm1lZGlhXCIpO1xuICAgIH1cbiAgICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcbiAgICB9XG4gICAgLy8gRm9yIG9sZCBJRVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi8gaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpe1xuICAgICAgICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gICAgfVxufVxubGV0IHNpbmdsZXRvbiA9IG51bGw7XG5sZXQgc2luZ2xldG9uQ291bnRlciA9IDA7XG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgICBsZXQgc3R5bGU7XG4gICAgbGV0IHVwZGF0ZTtcbiAgICBsZXQgcmVtb3ZlO1xuICAgIGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuICAgICAgICBjb25zdCBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuICAgICAgICBzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcbiAgICAgICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG4gICAgICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUgPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gICAgICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG4gICAgICAgIHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdXBkYXRlKG9iaik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuICAgICAgICBpZiAobmV3T2JqKSB7XG4gICAgICAgICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbiAgICAvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG4gICAgaWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuICAgIH1cbiAgICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgICBsZXQgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgICAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdMaXN0KSAhPT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuICAgICAgICBmb3IobGV0IGkxID0gMDsgaTEgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpMSsrKXtcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaTFdO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgICAgICAgIGlmIChzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKCk7XG4gICAgICAgICAgICAgICAgc3R5bGVzSW5Eb20uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gICAgfTtcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\n"));

/***/ }),

/***/ "./pages/_app.js":
/*!***********************!*\
  !*** ./pages/_app.js ***!
  \***********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _src_context_Context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/context/Context */ \"./src/context/Context.js\");\n/* harmony import */ var _src_layout_PreLoader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/layout/PreLoader */ \"./src/layout/PreLoader.js\");\n/* harmony import */ var _src_layout_WatsonHead__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/layout/WatsonHead */ \"./src/layout/WatsonHead.js\");\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../styles/globals.css */ \"./styles/globals.css\");\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_styles_globals_css__WEBPACK_IMPORTED_MODULE_5__);\n\nvar _s = $RefreshSig$();\n\n\n\n\n\nconst App = (param)=>{\n    let { Component , pageProps  } = param;\n    _s();\n    const [loader, setLoader] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setTimeout(()=>{\n            setLoader(false);\n        }, 1000);\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_src_context_Context__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_src_layout_WatsonHead__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {}, void 0, false, {\n                fileName: \"C:\\\\Users\\\\sayid\\\\OneDrive\\\\Desktop\\\\myportfolio\\\\pages\\\\_app.js\",\n                lineNumber: 16,\n                columnNumber: 7\n            }, undefined),\n            loader && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_src_layout_PreLoader__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {}, void 0, false, {\n                fileName: \"C:\\\\Users\\\\sayid\\\\OneDrive\\\\Desktop\\\\myportfolio\\\\pages\\\\_app.js\",\n                lineNumber: 17,\n                columnNumber: 18\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Component, {\n                ...pageProps\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\sayid\\\\OneDrive\\\\Desktop\\\\myportfolio\\\\pages\\\\_app.js\",\n                lineNumber: 18,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\sayid\\\\OneDrive\\\\Desktop\\\\myportfolio\\\\pages\\\\_app.js\",\n        lineNumber: 15,\n        columnNumber: 5\n    }, undefined);\n};\n_s(App, \"v9Gmr36LIRqHprS819AlpxmZHdc=\");\n_c = App;\n/* harmony default export */ __webpack_exports__[\"default\"] = (App);\nvar _c;\n$RefreshReg$(_c, \"App\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9fYXBwLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7QUFBbUQ7QUFDRjtBQUNEO0FBQ0U7QUFDbkI7QUFDL0IsTUFBTU0sTUFBTSxTQUE4QjtRQUE3QixFQUFFQyxVQUFTLEVBQUVDLFVBQVMsRUFBRTs7SUFDbkMsTUFBTSxDQUFDQyxRQUFRQyxVQUFVLEdBQUdSLCtDQUFRQSxDQUFDLElBQUk7SUFDekNELGdEQUFTQSxDQUFDLElBQU07UUFDZFUsV0FBVyxJQUFNO1lBQ2ZELFVBQVUsS0FBSztRQUNqQixHQUFHO0lBQ0wsR0FBRyxFQUFFO0lBRUwscUJBQ0UsOERBQUNQLDREQUFXQTs7MEJBQ1YsOERBQUNFLDhEQUFVQTs7Ozs7WUFDVkksd0JBQVUsOERBQUNMLDZEQUFTQTs7Ozs7MEJBQ3JCLDhEQUFDRztnQkFBVyxHQUFHQyxTQUFTOzs7Ozs7Ozs7Ozs7QUFHOUI7R0FmTUY7S0FBQUE7QUFnQk4sK0RBQWVBLEdBQUdBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvX2FwcC5qcz9lMGFkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCBXYXRzb25TdGF0ZSBmcm9tIFwiLi4vc3JjL2NvbnRleHQvQ29udGV4dFwiO1xyXG5pbXBvcnQgUHJlTG9hZGVyIGZyb20gXCIuLi9zcmMvbGF5b3V0L1ByZUxvYWRlclwiO1xyXG5pbXBvcnQgV2F0c29uSGVhZCBmcm9tIFwiLi4vc3JjL2xheW91dC9XYXRzb25IZWFkXCI7XHJcbmltcG9ydCBcIi4uL3N0eWxlcy9nbG9iYWxzLmNzc1wiO1xyXG5jb25zdCBBcHAgPSAoeyBDb21wb25lbnQsIHBhZ2VQcm9wcyB9KSA9PiB7XHJcbiAgY29uc3QgW2xvYWRlciwgc2V0TG9hZGVyXSA9IHVzZVN0YXRlKHRydWUpO1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgc2V0TG9hZGVyKGZhbHNlKTtcclxuICAgIH0sIDEwMDApO1xyXG4gIH0sIFtdKTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxXYXRzb25TdGF0ZT5cclxuICAgICAgPFdhdHNvbkhlYWQgLz5cclxuICAgICAge2xvYWRlciAmJiA8UHJlTG9hZGVyIC8+fVxyXG4gICAgICA8Q29tcG9uZW50IHsuLi5wYWdlUHJvcHN9IC8+XHJcbiAgICA8L1dhdHNvblN0YXRlPlxyXG4gICk7XHJcbn07XHJcbmV4cG9ydCBkZWZhdWx0IEFwcDtcclxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJXYXRzb25TdGF0ZSIsIlByZUxvYWRlciIsIldhdHNvbkhlYWQiLCJBcHAiLCJDb21wb25lbnQiLCJwYWdlUHJvcHMiLCJsb2FkZXIiLCJzZXRMb2FkZXIiLCJzZXRUaW1lb3V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./pages/_app.js\n"));

/***/ }),

/***/ "./src/context/Context.js":
/*!********************************!*\
  !*** ./src/context/Context.js ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WatsonContext\": function() { return /* binding */ WatsonContext; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ \"./src/utils.js\");\n\nvar _s = $RefreshSig$();\n\n\n// Create Context\nconst WatsonContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)();\n// Type\nconst type = {\n    SECTION: \"SECTION\",\n    ANIMATION_NAME: \"ANIMATION_NAME\",\n    COLOR: \"COLOR\",\n    THEME: \"THEME\"\n};\nconst { SECTION , ANIMATION_NAME , COLOR , THEME  } = type;\n// Initial Value\nconst initialState = {\n    section: \"home\",\n    pageTransitionAnimation: {\n        inClass: \"pt-page-scaleUp\",\n        outClass: \"pt-page-scaleDown\"\n    },\n    color: \"blue\",\n    theme: \"dark\"\n};\n// Reducer\nconst reducer = (state, action)=>{\n    const { type , payload  } = action;\n    switch(type){\n        case SECTION:\n            return {\n                ...state,\n                section: payload\n            };\n        case ANIMATION_NAME:\n            return {\n                ...state,\n                pageTransitionAnimation: payload\n            };\n        case COLOR:\n            return {\n                ...state,\n                color: payload\n            };\n        case THEME:\n            return {\n                ...state,\n                theme: payload\n            };\n        default:\n            return state;\n    }\n};\n// Watson State\nconst WatsonState = (param)=>{\n    let { children  } = param;\n    _s();\n    const [state, dispatch] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useReducer)(reducer, initialState);\n    // Sidebar Change\n    const changeSection = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((value)=>{\n        dispatch({\n            type: SECTION,\n            payload: value\n        });\n    }, []);\n    // Page Animation\n    const pageAnimationChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((value)=>{\n        let animation = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.findAnimation)(value);\n        dispatch({\n            type: ANIMATION_NAME,\n            payload: animation\n        });\n    }, []);\n    // Page Animation\n    const colorChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((value)=>{\n        dispatch({\n            type: COLOR,\n            payload: value\n        });\n    }, []);\n    // Theme Dark / Light\n    const changeThemeVersion = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((value)=>{\n        dispatch({\n            type: THEME,\n            payload: value\n        });\n    }, []);\n    const { section , pageTransitionAnimation , color , theme  } = state;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(WatsonContext.Provider, {\n        value: {\n            section,\n            changeSection,\n            pageTransitionAnimation,\n            pageAnimationChange,\n            color,\n            colorChange,\n            changeThemeVersion,\n            theme\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\sayid\\\\OneDrive\\\\Desktop\\\\myportfolio\\\\src\\\\context\\\\Context.js\",\n        lineNumber: 94,\n        columnNumber: 5\n    }, undefined);\n};\n_s(WatsonState, \"ZE69ML51t/owsDAX32xuOfXGu1A=\");\n_c = WatsonState;\n/* harmony default export */ __webpack_exports__[\"default\"] = (WatsonState);\n\nvar _c;\n$RefreshReg$(_c, \"WatsonState\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29udGV4dC9Db250ZXh0LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOztBQUErRDtBQUN0QjtBQUV6QyxpQkFBaUI7QUFDakIsTUFBTUksOEJBQWdCSixvREFBYUE7QUFFbkMsT0FBTztBQUNQLE1BQU1LLE9BQU87SUFDWEMsU0FBUztJQUNUQyxnQkFBZ0I7SUFDaEJDLE9BQU87SUFDUEMsT0FBTztBQUNUO0FBQ0EsTUFBTSxFQUFFSCxRQUFPLEVBQUVDLGVBQWMsRUFBRUMsTUFBSyxFQUFFQyxNQUFLLEVBQUUsR0FBR0o7QUFFbEQsZ0JBQWdCO0FBQ2hCLE1BQU1LLGVBQWU7SUFDbkJDLFNBQVM7SUFDVEMseUJBQXlCO1FBQ3ZCQyxTQUFTO1FBQ1RDLFVBQVU7SUFDWjtJQUNBQyxPQUFPO0lBQ1BDLE9BQU87QUFDVDtBQUVBLFVBQVU7QUFDVixNQUFNQyxVQUFVLENBQUNDLE9BQU9DLFNBQVc7SUFDakMsTUFBTSxFQUFFZCxLQUFJLEVBQUVlLFFBQU8sRUFBRSxHQUFHRDtJQUMxQixPQUFRZDtRQUNOLEtBQUtDO1lBQ0gsT0FBTztnQkFDTCxHQUFHWSxLQUFLO2dCQUNSUCxTQUFTUztZQUNYO1FBQ0YsS0FBS2I7WUFDSCxPQUFPO2dCQUNMLEdBQUdXLEtBQUs7Z0JBQ1JOLHlCQUF5QlE7WUFDM0I7UUFDRixLQUFLWjtZQUNILE9BQU87Z0JBQ0wsR0FBR1UsS0FBSztnQkFDUkgsT0FBT0s7WUFDVDtRQUNGLEtBQUtYO1lBQ0gsT0FBTztnQkFDTCxHQUFHUyxLQUFLO2dCQUNSRixPQUFPSTtZQUNUO1FBQ0Y7WUFDRSxPQUFPRjtJQUNYO0FBQ0Y7QUFFQSxlQUFlO0FBQ2YsTUFBTUcsY0FBYyxTQUFrQjtRQUFqQixFQUFFQyxTQUFRLEVBQUU7O0lBQy9CLE1BQU0sQ0FBQ0osT0FBT0ssU0FBUyxHQUFHckIsaURBQVVBLENBQUNlLFNBQVNQO0lBRTlDLGlCQUFpQjtJQUNqQixNQUFNYyxnQkFBZ0J2QixrREFBV0EsQ0FBQyxDQUFDd0IsUUFBVTtRQUMzQ0YsU0FBUztZQUNQbEIsTUFBTUM7WUFDTmMsU0FBU0s7UUFDWDtJQUNGLEdBQUcsRUFBRTtJQUVMLGlCQUFpQjtJQUNqQixNQUFNQyxzQkFBc0J6QixrREFBV0EsQ0FBQyxDQUFDd0IsUUFBVTtRQUNqRCxJQUFJRSxZQUFZeEIscURBQWFBLENBQUNzQjtRQUM5QkYsU0FBUztZQUNQbEIsTUFBTUU7WUFDTmEsU0FBU087UUFDWDtJQUNGLEdBQUcsRUFBRTtJQUVMLGlCQUFpQjtJQUNqQixNQUFNQyxjQUFjM0Isa0RBQVdBLENBQUMsQ0FBQ3dCLFFBQVU7UUFDekNGLFNBQVM7WUFDUGxCLE1BQU1HO1lBQ05ZLFNBQVNLO1FBQ1g7SUFDRixHQUFHLEVBQUU7SUFFTCxxQkFBcUI7SUFDckIsTUFBTUkscUJBQXFCNUIsa0RBQVdBLENBQUMsQ0FBQ3dCLFFBQVU7UUFDaERGLFNBQVM7WUFDUGxCLE1BQU1JO1lBQ05XLFNBQVNLO1FBQ1g7SUFDRixHQUFHLEVBQUU7SUFDTCxNQUFNLEVBQUVkLFFBQU8sRUFBRUMsd0JBQXVCLEVBQUVHLE1BQUssRUFBRUMsTUFBSyxFQUFFLEdBQUdFO0lBQzNELHFCQUNFLDhEQUFDZCxjQUFjMEIsUUFBUTtRQUNyQkwsT0FBTztZQUNMZDtZQUNBYTtZQUNBWjtZQUNBYztZQUNBWDtZQUNBYTtZQUNBQztZQUNBYjtRQUNGO2tCQUVDTTs7Ozs7O0FBR1A7R0FwRE1EO0tBQUFBO0FBc0ROLCtEQUFlQSxXQUFXQSxFQUFDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbnRleHQvQ29udGV4dC5qcz8yNWI4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNhbGxiYWNrLCB1c2VSZWR1Y2VyIH0gZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCB7IGZpbmRBbmltYXRpb24gfSBmcm9tIFwiLi4vdXRpbHNcIjtcclxuXHJcbi8vIENyZWF0ZSBDb250ZXh0XHJcbmNvbnN0IFdhdHNvbkNvbnRleHQgPSBjcmVhdGVDb250ZXh0KCk7XHJcblxyXG4vLyBUeXBlXHJcbmNvbnN0IHR5cGUgPSB7XHJcbiAgU0VDVElPTjogXCJTRUNUSU9OXCIsXHJcbiAgQU5JTUFUSU9OX05BTUU6IFwiQU5JTUFUSU9OX05BTUVcIixcclxuICBDT0xPUjogXCJDT0xPUlwiLFxyXG4gIFRIRU1FOiBcIlRIRU1FXCIsXHJcbn07XHJcbmNvbnN0IHsgU0VDVElPTiwgQU5JTUFUSU9OX05BTUUsIENPTE9SLCBUSEVNRSB9ID0gdHlwZTtcclxuXHJcbi8vIEluaXRpYWwgVmFsdWVcclxuY29uc3QgaW5pdGlhbFN0YXRlID0ge1xyXG4gIHNlY3Rpb246IFwiaG9tZVwiLFxyXG4gIHBhZ2VUcmFuc2l0aW9uQW5pbWF0aW9uOiB7XHJcbiAgICBpbkNsYXNzOiBcInB0LXBhZ2Utc2NhbGVVcFwiLFxyXG4gICAgb3V0Q2xhc3M6IFwicHQtcGFnZS1zY2FsZURvd25cIixcclxuICB9LFxyXG4gIGNvbG9yOiBcImJsdWVcIixcclxuICB0aGVtZTogXCJkYXJrXCIsXHJcbn07XHJcblxyXG4vLyBSZWR1Y2VyXHJcbmNvbnN0IHJlZHVjZXIgPSAoc3RhdGUsIGFjdGlvbikgPT4ge1xyXG4gIGNvbnN0IHsgdHlwZSwgcGF5bG9hZCB9ID0gYWN0aW9uO1xyXG4gIHN3aXRjaCAodHlwZSkge1xyXG4gICAgY2FzZSBTRUNUSU9OOlxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLnN0YXRlLFxyXG4gICAgICAgIHNlY3Rpb246IHBheWxvYWQsXHJcbiAgICAgIH07XHJcbiAgICBjYXNlIEFOSU1BVElPTl9OQU1FOlxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLnN0YXRlLFxyXG4gICAgICAgIHBhZ2VUcmFuc2l0aW9uQW5pbWF0aW9uOiBwYXlsb2FkLFxyXG4gICAgICB9O1xyXG4gICAgY2FzZSBDT0xPUjpcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAuLi5zdGF0ZSxcclxuICAgICAgICBjb2xvcjogcGF5bG9hZCxcclxuICAgICAgfTtcclxuICAgIGNhc2UgVEhFTUU6XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4uc3RhdGUsXHJcbiAgICAgICAgdGhlbWU6IHBheWxvYWQsXHJcbiAgICAgIH07XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gc3RhdGU7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gV2F0c29uIFN0YXRlXHJcbmNvbnN0IFdhdHNvblN0YXRlID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xyXG4gIGNvbnN0IFtzdGF0ZSwgZGlzcGF0Y2hdID0gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsU3RhdGUpO1xyXG5cclxuICAvLyBTaWRlYmFyIENoYW5nZVxyXG4gIGNvbnN0IGNoYW5nZVNlY3Rpb24gPSB1c2VDYWxsYmFjaygodmFsdWUpID0+IHtcclxuICAgIGRpc3BhdGNoKHtcclxuICAgICAgdHlwZTogU0VDVElPTixcclxuICAgICAgcGF5bG9hZDogdmFsdWUsXHJcbiAgICB9KTtcclxuICB9LCBbXSk7XHJcblxyXG4gIC8vIFBhZ2UgQW5pbWF0aW9uXHJcbiAgY29uc3QgcGFnZUFuaW1hdGlvbkNoYW5nZSA9IHVzZUNhbGxiYWNrKCh2YWx1ZSkgPT4ge1xyXG4gICAgbGV0IGFuaW1hdGlvbiA9IGZpbmRBbmltYXRpb24odmFsdWUpO1xyXG4gICAgZGlzcGF0Y2goe1xyXG4gICAgICB0eXBlOiBBTklNQVRJT05fTkFNRSxcclxuICAgICAgcGF5bG9hZDogYW5pbWF0aW9uLFxyXG4gICAgfSk7XHJcbiAgfSwgW10pO1xyXG5cclxuICAvLyBQYWdlIEFuaW1hdGlvblxyXG4gIGNvbnN0IGNvbG9yQ2hhbmdlID0gdXNlQ2FsbGJhY2soKHZhbHVlKSA9PiB7XHJcbiAgICBkaXNwYXRjaCh7XHJcbiAgICAgIHR5cGU6IENPTE9SLFxyXG4gICAgICBwYXlsb2FkOiB2YWx1ZSxcclxuICAgIH0pO1xyXG4gIH0sIFtdKTtcclxuXHJcbiAgLy8gVGhlbWUgRGFyayAvIExpZ2h0XHJcbiAgY29uc3QgY2hhbmdlVGhlbWVWZXJzaW9uID0gdXNlQ2FsbGJhY2soKHZhbHVlKSA9PiB7XHJcbiAgICBkaXNwYXRjaCh7XHJcbiAgICAgIHR5cGU6IFRIRU1FLFxyXG4gICAgICBwYXlsb2FkOiB2YWx1ZSxcclxuICAgIH0pO1xyXG4gIH0sIFtdKTtcclxuICBjb25zdCB7IHNlY3Rpb24sIHBhZ2VUcmFuc2l0aW9uQW5pbWF0aW9uLCBjb2xvciwgdGhlbWUgfSA9IHN0YXRlO1xyXG4gIHJldHVybiAoXHJcbiAgICA8V2F0c29uQ29udGV4dC5Qcm92aWRlclxyXG4gICAgICB2YWx1ZT17e1xyXG4gICAgICAgIHNlY3Rpb24sXHJcbiAgICAgICAgY2hhbmdlU2VjdGlvbixcclxuICAgICAgICBwYWdlVHJhbnNpdGlvbkFuaW1hdGlvbixcclxuICAgICAgICBwYWdlQW5pbWF0aW9uQ2hhbmdlLFxyXG4gICAgICAgIGNvbG9yLFxyXG4gICAgICAgIGNvbG9yQ2hhbmdlLFxyXG4gICAgICAgIGNoYW5nZVRoZW1lVmVyc2lvbixcclxuICAgICAgICB0aGVtZSxcclxuICAgICAgfX1cclxuICAgID5cclxuICAgICAge2NoaWxkcmVufVxyXG4gICAgPC9XYXRzb25Db250ZXh0LlByb3ZpZGVyPlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBXYXRzb25TdGF0ZTtcclxuZXhwb3J0IHsgV2F0c29uQ29udGV4dCB9O1xyXG4iXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsInVzZUNhbGxiYWNrIiwidXNlUmVkdWNlciIsImZpbmRBbmltYXRpb24iLCJXYXRzb25Db250ZXh0IiwidHlwZSIsIlNFQ1RJT04iLCJBTklNQVRJT05fTkFNRSIsIkNPTE9SIiwiVEhFTUUiLCJpbml0aWFsU3RhdGUiLCJzZWN0aW9uIiwicGFnZVRyYW5zaXRpb25BbmltYXRpb24iLCJpbkNsYXNzIiwib3V0Q2xhc3MiLCJjb2xvciIsInRoZW1lIiwicmVkdWNlciIsInN0YXRlIiwiYWN0aW9uIiwicGF5bG9hZCIsIldhdHNvblN0YXRlIiwiY2hpbGRyZW4iLCJkaXNwYXRjaCIsImNoYW5nZVNlY3Rpb24iLCJ2YWx1ZSIsInBhZ2VBbmltYXRpb25DaGFuZ2UiLCJhbmltYXRpb24iLCJjb2xvckNoYW5nZSIsImNoYW5nZVRoZW1lVmVyc2lvbiIsIlByb3ZpZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/context/Context.js\n"));

/***/ }),

/***/ "./src/layout/PreLoader.js":
/*!*********************************!*\
  !*** ./src/layout/PreLoader.js ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n\nconst PreLoader = ()=>{\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"preloader\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"loader\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h4\", {\n                    children: \"SAYID ELHADI\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\sayid\\\\OneDrive\\\\Desktop\\\\myportfolio\\\\src\\\\layout\\\\PreLoader.js\",\n                    lineNumber: 6,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h4\", {\n                    children: \"Web Development / Data Gathering / Digital Marketing\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\sayid\\\\OneDrive\\\\Desktop\\\\myportfolio\\\\src\\\\layout\\\\PreLoader.js\",\n                    lineNumber: 7,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {}, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\sayid\\\\OneDrive\\\\Desktop\\\\myportfolio\\\\src\\\\layout\\\\PreLoader.js\",\n                    lineNumber: 8,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {}, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\sayid\\\\OneDrive\\\\Desktop\\\\myportfolio\\\\src\\\\layout\\\\PreLoader.js\",\n                    lineNumber: 9,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {}, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\sayid\\\\OneDrive\\\\Desktop\\\\myportfolio\\\\src\\\\layout\\\\PreLoader.js\",\n                    lineNumber: 10,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {}, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\sayid\\\\OneDrive\\\\Desktop\\\\myportfolio\\\\src\\\\layout\\\\PreLoader.js\",\n                    lineNumber: 11,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {}, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\sayid\\\\OneDrive\\\\Desktop\\\\myportfolio\\\\src\\\\layout\\\\PreLoader.js\",\n                    lineNumber: 12,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {}, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\sayid\\\\OneDrive\\\\Desktop\\\\myportfolio\\\\src\\\\layout\\\\PreLoader.js\",\n                    lineNumber: 13,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {}, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\sayid\\\\OneDrive\\\\Desktop\\\\myportfolio\\\\src\\\\layout\\\\PreLoader.js\",\n                    lineNumber: 14,\n                    columnNumber: 9\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Users\\\\sayid\\\\OneDrive\\\\Desktop\\\\myportfolio\\\\src\\\\layout\\\\PreLoader.js\",\n            lineNumber: 4,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\sayid\\\\OneDrive\\\\Desktop\\\\myportfolio\\\\src\\\\layout\\\\PreLoader.js\",\n        lineNumber: 3,\n        columnNumber: 5\n    }, undefined);\n};\n_c = PreLoader;\n/* harmony default export */ __webpack_exports__[\"default\"] = (PreLoader);\nvar _c;\n$RefreshReg$(_c, \"PreLoader\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbGF5b3V0L1ByZUxvYWRlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUFBLE1BQU1BLFlBQVksSUFBTTtJQUN0QixxQkFDRSw4REFBQ0M7UUFBSUMsV0FBVTtrQkFDYiw0RUFBQ0Q7WUFBSUMsV0FBVTs7OEJBRWIsOERBQUNDOzhCQUFHOzs7Ozs7OEJBQ0osOERBQUNBOzhCQUFHOzs7Ozs7OEJBQ0osOERBQUNDOzs7Ozs4QkFDRCw4REFBQ0E7Ozs7OzhCQUNELDhEQUFDQTs7Ozs7OEJBQ0QsOERBQUNBOzs7Ozs4QkFDRCw4REFBQ0E7Ozs7OzhCQUNELDhEQUFDQTs7Ozs7OEJBQ0QsOERBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBSVQ7S0FqQk1KO0FBa0JOLCtEQUFlQSxTQUFTQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9sYXlvdXQvUHJlTG9hZGVyLmpzPzM2ODUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUHJlTG9hZGVyID0gKCkgPT4ge1xyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInByZWxvYWRlclwiPlxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImxvYWRlclwiPlxyXG4gICAgICAgIHsvKllvdXIgTmFtZSovfVxyXG4gICAgICAgIDxoND5TQVlJRCBFTEhBREk8L2g0PlxyXG4gICAgICAgIDxoND5XZWIgRGV2ZWxvcG1lbnQgLyBEYXRhIEdhdGhlcmluZyAvIERpZ2l0YWwgTWFya2V0aW5nPC9oND5cclxuICAgICAgICA8c3BhbiAvPlxyXG4gICAgICAgIDxzcGFuIC8+XHJcbiAgICAgICAgPHNwYW4gLz5cclxuICAgICAgICA8c3BhbiAvPlxyXG4gICAgICAgIDxzcGFuIC8+XHJcbiAgICAgICAgPHNwYW4gLz5cclxuICAgICAgICA8c3BhbiAvPlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gICk7XHJcbn07XHJcbmV4cG9ydCBkZWZhdWx0IFByZUxvYWRlcjtcclxuIl0sIm5hbWVzIjpbIlByZUxvYWRlciIsImRpdiIsImNsYXNzTmFtZSIsImg0Iiwic3BhbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/layout/PreLoader.js\n"));

/***/ }),

/***/ "./src/layout/WatsonHead.js":
/*!**********************************!*\
  !*** ./src/layout/WatsonHead.js ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ \"./node_modules/next/head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _context_Context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../context/Context */ \"./src/context/Context.js\");\n\nvar _s = $RefreshSig$();\n\n\n\nconst WatsonHead = ()=>{\n    _s();\n    const { color , theme  } = (0,react__WEBPACK_IMPORTED_MODULE_2__.useContext)(_context_Context__WEBPACK_IMPORTED_MODULE_3__.WatsonContext);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_1___default()), {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                charSet: \"utf-8\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\sayid\\\\OneDrive\\\\Desktop\\\\myportfolio\\\\src\\\\layout\\\\WatsonHead.js\",\n                lineNumber: 10,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                httpEquiv: \"X-UA-Compatible\",\n                content: \"IE=edge\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\sayid\\\\OneDrive\\\\Desktop\\\\myportfolio\\\\src\\\\layout\\\\WatsonHead.js\",\n                lineNumber: 11,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                name: \"viewport\",\n                content: \"width=device-width, initial-scale=1\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\sayid\\\\OneDrive\\\\Desktop\\\\myportfolio\\\\src\\\\layout\\\\WatsonHead.js\",\n                lineNumber: 12,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                name: \"keywords\",\n                content: \"vcard, resume, personal, portfolio, cv, card, responsive, freelancer, web developer, web designer, digital marketer\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\sayid\\\\OneDrive\\\\Desktop\\\\myportfolio\\\\src\\\\layout\\\\WatsonHead.js\",\n                lineNumber: 13,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                name: \"description\",\n                content: \"vCard / Resume / Personal Template\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\sayid\\\\OneDrive\\\\Desktop\\\\myportfolio\\\\src\\\\layout\\\\WatsonHead.js\",\n                lineNumber: 17,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                name: \"author\",\n                content: \"cosmos-themes\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\sayid\\\\OneDrive\\\\Desktop\\\\myportfolio\\\\src\\\\layout\\\\WatsonHead.js\",\n                lineNumber: 18,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                children: \"SAYID - Portfolio/Resume\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\sayid\\\\OneDrive\\\\Desktop\\\\myportfolio\\\\src\\\\layout\\\\WatsonHead.js\",\n                lineNumber: 20,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                rel: \"stylesheet\",\n                href: \"css/plugins.css\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\sayid\\\\OneDrive\\\\Desktop\\\\myportfolio\\\\src\\\\layout\\\\WatsonHead.js\",\n                lineNumber: 22,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                rel: \"stylesheet\",\n                href: \"css/style-\".concat(theme, \".css\")\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\sayid\\\\OneDrive\\\\Desktop\\\\myportfolio\\\\src\\\\layout\\\\WatsonHead.js\",\n                lineNumber: 24,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                rel: \"stylesheet\",\n                href: \"css/style-demo.css\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\sayid\\\\OneDrive\\\\Desktop\\\\myportfolio\\\\src\\\\layout\\\\WatsonHead.js\",\n                lineNumber: 25,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                className: \"site-color\",\n                rel: \"stylesheet\",\n                href: \"css/\".concat(color, \"-color.css\")\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\sayid\\\\OneDrive\\\\Desktop\\\\myportfolio\\\\src\\\\layout\\\\WatsonHead.js\",\n                lineNumber: 27,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                rel: \"shortcut icon\",\n                href: \"img/favicon.ico\",\n                type: \"image/x-icon\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\sayid\\\\OneDrive\\\\Desktop\\\\myportfolio\\\\src\\\\layout\\\\WatsonHead.js\",\n                lineNumber: 34,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\sayid\\\\OneDrive\\\\Desktop\\\\myportfolio\\\\src\\\\layout\\\\WatsonHead.js\",\n        lineNumber: 9,\n        columnNumber: 5\n    }, undefined);\n};\n_s(WatsonHead, \"BQjSrNkjZ6nsss5FBtWrL0WncYk=\");\n_c = WatsonHead;\n/* harmony default export */ __webpack_exports__[\"default\"] = (/*#__PURE__*/_c1 = (0,react__WEBPACK_IMPORTED_MODULE_2__.memo)(WatsonHead));\nvar _c, _c1;\n$RefreshReg$(_c, \"WatsonHead\");\n$RefreshReg$(_c1, \"%default%\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbGF5b3V0L1dhdHNvbkhlYWQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7QUFBNkI7QUFDWTtBQUNVO0FBRW5ELE1BQU1JLGFBQWEsSUFBTTs7SUFDdkIsTUFBTSxFQUFFQyxNQUFLLEVBQUVDLE1BQUssRUFBRSxHQUFHSixpREFBVUEsQ0FBQ0MsMkRBQWFBO0lBRWpELHFCQUNFLDhEQUFDSCxrREFBSUE7OzBCQUNILDhEQUFDTztnQkFBS0MsU0FBUTs7Ozs7OzBCQUNkLDhEQUFDRDtnQkFBS0UsV0FBVTtnQkFBa0JDLFNBQVE7Ozs7OzswQkFDMUMsOERBQUNIO2dCQUFLSSxNQUFLO2dCQUFXRCxTQUFROzs7Ozs7MEJBQzlCLDhEQUFDSDtnQkFDQ0ksTUFBSztnQkFDTEQsU0FBUTs7Ozs7OzBCQUVWLDhEQUFDSDtnQkFBS0ksTUFBSztnQkFBY0QsU0FBUTs7Ozs7OzBCQUNqQyw4REFBQ0g7Z0JBQUtJLE1BQUs7Z0JBQVNELFNBQVE7Ozs7OzswQkFFNUIsOERBQUNFOzBCQUFNOzs7Ozs7MEJBRVAsOERBQUNDO2dCQUFLQyxLQUFJO2dCQUFhQyxNQUFLOzs7Ozs7MEJBRTVCLDhEQUFDRjtnQkFBS0MsS0FBSTtnQkFBYUMsTUFBTSxhQUFtQixPQUFOVCxPQUFNOzs7Ozs7MEJBQ2hELDhEQUFDTztnQkFBS0MsS0FBSTtnQkFBYUMsTUFBSzs7Ozs7OzBCQUU1Qiw4REFBQ0Y7Z0JBQ0NHLFdBQVU7Z0JBQ1ZGLEtBQUk7Z0JBQ0pDLE1BQU0sT0FBYSxPQUFOVixPQUFNOzs7Ozs7MEJBSXJCLDhEQUFDUTtnQkFBS0MsS0FBSTtnQkFBZ0JDLE1BQUs7Z0JBQWtCRSxNQUFLOzs7Ozs7Ozs7Ozs7QUFHNUQ7R0FoQ01iO0tBQUFBO0FBaUNOLGtGQUFlSCwyQ0FBSUEsQ0FBQ0csV0FBV0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGF5b3V0L1dhdHNvbkhlYWQuanM/MGZjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSGVhZCBmcm9tIFwibmV4dC9oZWFkXCI7XHJcbmltcG9ydCB7IG1lbW8sIHVzZUNvbnRleHQgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHsgV2F0c29uQ29udGV4dCB9IGZyb20gXCIuLi9jb250ZXh0L0NvbnRleHRcIjtcclxuXHJcbmNvbnN0IFdhdHNvbkhlYWQgPSAoKSA9PiB7XHJcbiAgY29uc3QgeyBjb2xvciwgdGhlbWUgfSA9IHVzZUNvbnRleHQoV2F0c29uQ29udGV4dCk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8SGVhZD5cclxuICAgICAgPG1ldGEgY2hhclNldD1cInV0Zi04XCIgLz5cclxuICAgICAgPG1ldGEgaHR0cEVxdWl2PVwiWC1VQS1Db21wYXRpYmxlXCIgY29udGVudD1cIklFPWVkZ2VcIiAvPlxyXG4gICAgICA8bWV0YSBuYW1lPVwidmlld3BvcnRcIiBjb250ZW50PVwid2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTFcIiAvPlxyXG4gICAgICA8bWV0YVxyXG4gICAgICAgIG5hbWU9XCJrZXl3b3Jkc1wiXHJcbiAgICAgICAgY29udGVudD1cInZjYXJkLCByZXN1bWUsIHBlcnNvbmFsLCBwb3J0Zm9saW8sIGN2LCBjYXJkLCByZXNwb25zaXZlLCBmcmVlbGFuY2VyLCB3ZWIgZGV2ZWxvcGVyLCB3ZWIgZGVzaWduZXIsIGRpZ2l0YWwgbWFya2V0ZXJcIlxyXG4gICAgICAvPlxyXG4gICAgICA8bWV0YSBuYW1lPVwiZGVzY3JpcHRpb25cIiBjb250ZW50PVwidkNhcmQgLyBSZXN1bWUgLyBQZXJzb25hbCBUZW1wbGF0ZVwiIC8+XHJcbiAgICAgIDxtZXRhIG5hbWU9XCJhdXRob3JcIiBjb250ZW50PVwiY29zbW9zLXRoZW1lc1wiIC8+XHJcbiAgICAgIHsvKlBhZ2UgVGl0bGUqL31cclxuICAgICAgPHRpdGxlPlNBWUlEIC0gUG9ydGZvbGlvL1Jlc3VtZTwvdGl0bGU+XHJcbiAgICAgIHsvKlBsdWdpbnMgQ3NzKi99XHJcbiAgICAgIDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiBocmVmPVwiY3NzL3BsdWdpbnMuY3NzXCIgLz5cclxuICAgICAgey8qTWFpbiBTdHlsZXMgQ3NzKi99XHJcbiAgICAgIDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiBocmVmPXtgY3NzL3N0eWxlLSR7dGhlbWV9LmNzc2B9IC8+XHJcbiAgICAgIDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiBocmVmPVwiY3NzL3N0eWxlLWRlbW8uY3NzXCIgLz5cclxuICAgICAgey8qQ29sb3IgQ3NzKi99XHJcbiAgICAgIDxsaW5rXHJcbiAgICAgICAgY2xhc3NOYW1lPVwic2l0ZS1jb2xvclwiXHJcbiAgICAgICAgcmVsPVwic3R5bGVzaGVldFwiXHJcbiAgICAgICAgaHJlZj17YGNzcy8ke2NvbG9yfS1jb2xvci5jc3NgfVxyXG4gICAgICAvPlxyXG4gICAgICB7LypNb2Rlcm5penIgSnMqL31cclxuICAgICAgey8qRmF2aWNvbnMqL31cclxuICAgICAgPGxpbmsgcmVsPVwic2hvcnRjdXQgaWNvblwiIGhyZWY9XCJpbWcvZmF2aWNvbi5pY29cIiB0eXBlPVwiaW1hZ2UveC1pY29uXCIgLz5cclxuICAgIDwvSGVhZD5cclxuICApO1xyXG59O1xyXG5leHBvcnQgZGVmYXVsdCBtZW1vKFdhdHNvbkhlYWQpO1xyXG4iXSwibmFtZXMiOlsiSGVhZCIsIm1lbW8iLCJ1c2VDb250ZXh0IiwiV2F0c29uQ29udGV4dCIsIldhdHNvbkhlYWQiLCJjb2xvciIsInRoZW1lIiwibWV0YSIsImNoYXJTZXQiLCJodHRwRXF1aXYiLCJjb250ZW50IiwibmFtZSIsInRpdGxlIiwibGluayIsInJlbCIsImhyZWYiLCJjbGFzc05hbWUiLCJ0eXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/layout/WatsonHead.js\n"));

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaultPageAnimationByPageName\": function() { return /* binding */ defaultPageAnimationByPageName; },\n/* harmony export */   \"findAnimation\": function() { return /* binding */ findAnimation; },\n/* harmony export */   \"pageActiveAnimation\": function() { return /* binding */ pageActiveAnimation; },\n/* harmony export */   \"simpleBar\": function() { return /* binding */ simpleBar; }\n/* harmony export */ });\nconst pageActiveAnimation = (section, pageTransitionAnimation)=>{\n    const sections = document.querySelectorAll(\".pt-page\"), delay = \"pt-page-delay300\", activeClass = \"page-active\", inClass = pageTransitionAnimation.inClass.split(\" \"), outClass = pageTransitionAnimation.outClass.split(\" \");\n    for(let i = 0; i < sections.length; i++){\n        const sectionDom = sections[i];\n        if (section == sectionDom.getAttribute(\"id\")) {\n            sectionDom.classList.add(delay, activeClass, ...inClass);\n            setTimeout(()=>{\n                sectionDom.classList.remove(delay, ...inClass);\n            }, 1000);\n        } else {\n            sectionDom.classList.add(...outClass, delay);\n            setTimeout(()=>{\n                sectionDom.classList.remove(activeClass, ...outClass, delay);\n            }, 1000);\n        }\n    }\n};\nconst simpleBar = ()=>{\n    window.SimpleBar = __webpack_require__(/*! simplebar/dist/simplebar */ \"./node_modules/simplebar/dist/simplebar.js\");\n    Array.prototype.forEach.call(document.querySelectorAll(\".pt-page\"), (el)=>new window.SimpleBar(el));\n};\nconst defaultPageAnimationByPageName = {\n    indexDark: 4,\n    indexDarkSlider: 32,\n    indexDarkParticles1: 42,\n    indexDarkParticles2: 12,\n    indexDarkHtml5Video: 36,\n    indexDarkYoutubeVideo: 36,\n    indexLight: 40,\n    indexLightSlider: 33,\n    indexLightParticles1: 18,\n    indexLightParticles2: 15,\n    indexLightHtml5Video: 37,\n    indexLightYoutubeVideo: 26\n};\nconst findAnimation = (animation)=>{\n    let outClass = \"\", inClass = \"\";\n    switch(animation){\n        case 1:\n            outClass = \"pt-page-moveToRight\";\n            inClass = \"pt-page-moveFromLeft\";\n            break;\n        case 2:\n            outClass = \"pt-page-moveToBottom\";\n            inClass = \"pt-page-moveFromTop\";\n            break;\n        case 3:\n            outClass = \"pt-page-fade\";\n            inClass = \"pt-page-moveFromLeft pt-page-ontop\";\n            break;\n        case 4:\n            outClass = \"pt-page-fade\";\n            inClass = \"pt-page-moveFromTop pt-page-ontop\";\n            break;\n        case 5:\n            outClass = \"pt-page-moveToRightFade\";\n            inClass = \"pt-page-moveFromLeftFade\";\n            break;\n        case 6:\n            outClass = \"pt-page-moveToBottomFade\";\n            inClass = \"pt-page-moveFromTopFade\";\n            break;\n        case 7:\n            outClass = \"pt-page-moveToRightEasing pt-page-ontop\";\n            inClass = \"pt-page-moveFromLeft\";\n            break;\n        case 8:\n            outClass = \"pt-page-moveToBottomEasing pt-page-ontop\";\n            inClass = \"pt-page-moveFromTop\";\n            break;\n        case 9:\n            outClass = \"pt-page-scaleDown\";\n            inClass = \"pt-page-moveFromLeft pt-page-ontop\";\n            break;\n        case 10:\n            outClass = \"pt-page-scaleDown\";\n            inClass = \"pt-page-moveFromTop pt-page-ontop\";\n            break;\n        case 11:\n            outClass = \"pt-page-scaleDown\";\n            inClass = \"pt-page-scaleUpDown pt-page-delay300\";\n            break;\n        case 12:\n            outClass = \"pt-page-scaleDownUp\";\n            inClass = \"pt-page-scaleUp pt-page-delay300\";\n            break;\n        case 13:\n            outClass = \"pt-page-moveToLeft pt-page-ontop\";\n            inClass = \"pt-page-scaleUp\";\n            break;\n        case 14:\n            outClass = \"pt-page-moveToRight pt-page-ontop\";\n            inClass = \"pt-page-scaleUp\";\n            break;\n        case 15:\n            outClass = \"pt-page-moveToTop pt-page-ontop\";\n            inClass = \"pt-page-scaleUp\";\n            break;\n        case 16:\n            outClass = \"pt-page-moveToBottom pt-page-ontop\";\n            inClass = \"pt-page-scaleUp\";\n            break;\n        case 17:\n            outClass = \"pt-page-scaleDownCenter\";\n            inClass = \"pt-page-scaleUpCenter pt-page-delay400\";\n            break;\n        case 18:\n            outClass = \"pt-page-rotateLeftSideFirst\";\n            inClass = \"pt-page-moveFromLeft pt-page-delay200 pt-page-ontop\";\n            break;\n        case 19:\n            outClass = \"pt-page-rotateTopSideFirst\";\n            inClass = \"pt-page-moveFromTop pt-page-delay200 pt-page-ontop\";\n            break;\n        case 20:\n            outClass = \"pt-page-flipOutRight\";\n            inClass = \"pt-page-flipInLeft pt-page-delay500\";\n            break;\n        case 21:\n            outClass = \"pt-page-flipOutLeft\";\n            inClass = \"pt-page-flipInRight pt-page-delay500\";\n            break;\n        case 22:\n            outClass = \"pt-page-flipOutTop\";\n            inClass = \"pt-page-flipInBottom pt-page-delay500\";\n            break;\n        case 23:\n            outClass = \"pt-page-flipOutBottom\";\n            inClass = \"pt-page-flipInTop pt-page-delay500\";\n            break;\n        case 24:\n            outClass = \"pt-page-rotateFall pt-page-ontop\";\n            inClass = \"pt-page-scaleUp\";\n            break;\n        case 25:\n            outClass = \"pt-page-rotateOutNewspaper\";\n            inClass = \"pt-page-rotateInNewspaper pt-page-delay500\";\n            break;\n        case 26:\n            outClass = \"pt-page-rotatePushRight\";\n            inClass = \"pt-page-moveFromLeft pt-page-ontop\";\n            break;\n        case 27:\n            outClass = \"pt-page-rotatePushLeft\";\n            inClass = \"pt-page-rotatePullRight pt-page-delay180\";\n            break;\n        case 28:\n            outClass = \"pt-page-rotatePushRight\";\n            inClass = \"pt-page-rotatePullLeft pt-page-delay180\";\n            break;\n        case 29:\n            outClass = \"pt-page-rotatePushTop\";\n            inClass = \"pt-page-rotatePullBottom pt-page-delay180\";\n            break;\n        case 30:\n            outClass = \"pt-page-rotatePushBottom\";\n            inClass = \"pt-page-rotatePullTop pt-page-delay180\";\n            break;\n        case 31:\n            outClass = \"pt-page-rotateFoldRight\";\n            inClass = \"pt-page-moveFromLeftFade\";\n            break;\n        case 32:\n            outClass = \"pt-page-rotateFoldBottom\";\n            inClass = \"pt-page-moveFromTopFade\";\n            break;\n        case 33:\n            outClass = \"pt-page-moveToRightFade\";\n            inClass = \"pt-page-rotateUnfoldLeft\";\n            break;\n        case 34:\n            outClass = \"pt-page-moveToLeftFade\";\n            inClass = \"pt-page-rotateUnfoldRight\";\n            break;\n        case 35:\n            outClass = \"pt-page-moveToBottomFade\";\n            inClass = \"pt-page-rotateUnfoldTop\";\n            break;\n        case 36:\n            outClass = \"pt-page-moveToTopFade\";\n            inClass = \"pt-page-rotateUnfoldBottom\";\n            break;\n        case 37:\n            outClass = \"pt-page-rotateRoomLeftOut pt-page-ontop\";\n            inClass = \"pt-page-rotateRoomLeftIn\";\n            break;\n        case 38:\n            outClass = \"pt-page-rotateRoomRightOut pt-page-ontop\";\n            inClass = \"pt-page-rotateRoomRightIn\";\n            break;\n        case 39:\n            outClass = \"pt-page-rotateRoomBottomOut pt-page-ontop\";\n            inClass = \"pt-page-rotateRoomBottomIn\";\n            break;\n        case 40:\n            outClass = \"pt-page-rotateCubeLeftOut pt-page-ontop\";\n            inClass = \"pt-page-rotateCubeLeftIn\";\n            break;\n        case 41:\n            outClass = \"pt-page-rotateCubeRightOut pt-page-ontop\";\n            inClass = \"pt-page-rotateCubeRightIn\";\n            break;\n        case 42:\n            outClass = \"pt-page-rotateCubeTopOut pt-page-ontop\";\n            inClass = \"pt-page-rotateCubeTopIn\";\n            break;\n        case 43:\n            outClass = \"pt-page-rotateCubeBottomOut pt-page-ontop\";\n            inClass = \"pt-page-rotateCubeBottomIn\";\n            break;\n        case 44:\n            outClass = \"pt-page-rotateCarouselRightOut pt-page-ontop\";\n            inClass = \"pt-page-rotateCarouselRightIn\";\n            break;\n        case 45:\n            outClass = \"pt-page-rotateCarouselTopOut pt-page-ontop\";\n            inClass = \"pt-page-rotateCarouselTopIn\";\n            break;\n        case 46:\n            outClass = \"pt-page-rotateCarouselBottomOut pt-page-ontop\";\n            inClass = \"pt-page-rotateCarouselBottomIn\";\n            break;\n        case 47:\n            outClass = \"pt-page-rotateSidesOut\";\n            inClass = \"pt-page-rotateSidesIn pt-page-delay200\";\n            break;\n        case 48:\n            outClass = \"pt-page-rotateSlideOutToRight\";\n            inClass = \"pt-page-rotateSlideInFromLeft\";\n            break;\n    }\n    return {\n        outClass,\n        inClass\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUNSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUVSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUNSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUNSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUNSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUNSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUNSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUVSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUVSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUNSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUNSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUNSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUVSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUVSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUNSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUNSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUNSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUNSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUNSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUNSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUVSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUNSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUNSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUNSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUNSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUVSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUNSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUNSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUNSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtRQUVSLEtBQUs7WUFDSEUsV0FBVztZQUNYRixVQUFVO1lBQ1YsS0FBTTtJQUNWO0lBQ0EsT0FBTztRQUFFRTtRQUFVRjtJQUFRO0FBQzdCLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzLmpzPzVkODAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHBhZ2VBY3RpdmVBbmltYXRpb24gPSAoc2VjdGlvbiwgcGFnZVRyYW5zaXRpb25BbmltYXRpb24pID0+IHtcclxuICBjb25zdCBzZWN0aW9ucyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIucHQtcGFnZVwiKSxcclxuICAgIGRlbGF5ID0gXCJwdC1wYWdlLWRlbGF5MzAwXCIsXHJcbiAgICBhY3RpdmVDbGFzcyA9IFwicGFnZS1hY3RpdmVcIixcclxuICAgIGluQ2xhc3MgPSBwYWdlVHJhbnNpdGlvbkFuaW1hdGlvbi5pbkNsYXNzLnNwbGl0KFwiIFwiKSxcclxuICAgIG91dENsYXNzID0gcGFnZVRyYW5zaXRpb25BbmltYXRpb24ub3V0Q2xhc3Muc3BsaXQoXCIgXCIpO1xyXG5cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBzZWN0aW9uRG9tID0gc2VjdGlvbnNbaV07XHJcbiAgICBpZiAoc2VjdGlvbiA9PSBzZWN0aW9uRG9tLmdldEF0dHJpYnV0ZShcImlkXCIpKSB7XHJcbiAgICAgIHNlY3Rpb25Eb20uY2xhc3NMaXN0LmFkZChkZWxheSwgYWN0aXZlQ2xhc3MsIC4uLmluQ2xhc3MpO1xyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBzZWN0aW9uRG9tLmNsYXNzTGlzdC5yZW1vdmUoZGVsYXksIC4uLmluQ2xhc3MpO1xyXG4gICAgICB9LCAxMDAwKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHNlY3Rpb25Eb20uY2xhc3NMaXN0LmFkZCguLi5vdXRDbGFzcywgZGVsYXkpO1xyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBzZWN0aW9uRG9tLmNsYXNzTGlzdC5yZW1vdmUoYWN0aXZlQ2xhc3MsIC4uLm91dENsYXNzLCBkZWxheSk7XHJcbiAgICAgIH0sIDEwMDApO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBzaW1wbGVCYXIgPSAoKSA9PiB7XHJcbiAgd2luZG93LlNpbXBsZUJhciA9IHJlcXVpcmUoXCJzaW1wbGViYXIvZGlzdC9zaW1wbGViYXJcIik7XHJcbiAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChcclxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIucHQtcGFnZVwiKSxcclxuICAgIChlbCkgPT4gbmV3IHdpbmRvdy5TaW1wbGVCYXIoZWwpXHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBkZWZhdWx0UGFnZUFuaW1hdGlvbkJ5UGFnZU5hbWUgPSB7XHJcbiAgaW5kZXhEYXJrOiA0LFxyXG4gIGluZGV4RGFya1NsaWRlcjogMzIsXHJcbiAgaW5kZXhEYXJrUGFydGljbGVzMTogNDIsXHJcbiAgaW5kZXhEYXJrUGFydGljbGVzMjogMTIsXHJcbiAgaW5kZXhEYXJrSHRtbDVWaWRlbzogMzYsXHJcbiAgaW5kZXhEYXJrWW91dHViZVZpZGVvOiAzNixcclxuICBpbmRleExpZ2h0OiA0MCxcclxuICBpbmRleExpZ2h0U2xpZGVyOiAzMyxcclxuICBpbmRleExpZ2h0UGFydGljbGVzMTogMTgsXHJcbiAgaW5kZXhMaWdodFBhcnRpY2xlczI6IDE1LFxyXG4gIGluZGV4TGlnaHRIdG1sNVZpZGVvOiAzNyxcclxuICBpbmRleExpZ2h0WW91dHViZVZpZGVvOiAyNixcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBmaW5kQW5pbWF0aW9uID0gKGFuaW1hdGlvbikgPT4ge1xyXG4gIGxldCBvdXRDbGFzcyA9IFwiXCIsXHJcbiAgICBpbkNsYXNzID0gXCJcIjtcclxuICBzd2l0Y2ggKGFuaW1hdGlvbikge1xyXG4gICAgY2FzZSAxOlxyXG4gICAgICBvdXRDbGFzcyA9IFwicHQtcGFnZS1tb3ZlVG9SaWdodFwiO1xyXG4gICAgICBpbkNsYXNzID0gXCJwdC1wYWdlLW1vdmVGcm9tTGVmdFwiO1xyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBjYXNlIDI6XHJcbiAgICAgIG91dENsYXNzID0gXCJwdC1wYWdlLW1vdmVUb0JvdHRvbVwiO1xyXG4gICAgICBpbkNsYXNzID0gXCJwdC1wYWdlLW1vdmVGcm9tVG9wXCI7XHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgMzpcclxuICAgICAgb3V0Q2xhc3MgPSBcInB0LXBhZ2UtZmFkZVwiO1xyXG4gICAgICBpbkNsYXNzID0gXCJwdC1wYWdlLW1vdmVGcm9tTGVmdCBwdC1wYWdlLW9udG9wXCI7XHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgNDpcclxuICAgICAgb3V0Q2xhc3MgPSBcInB0LXBhZ2UtZmFkZVwiO1xyXG4gICAgICBpbkNsYXNzID0gXCJwdC1wYWdlLW1vdmVGcm9tVG9wIHB0LXBhZ2Utb250b3BcIjtcclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSA1OlxyXG4gICAgICBvdXRDbGFzcyA9IFwicHQtcGFnZS1tb3ZlVG9SaWdodEZhZGVcIjtcclxuICAgICAgaW5DbGFzcyA9IFwicHQtcGFnZS1tb3ZlRnJvbUxlZnRGYWRlXCI7XHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgNjpcclxuICAgICAgb3V0Q2xhc3MgPSBcInB0LXBhZ2UtbW92ZVRvQm90dG9tRmFkZVwiO1xyXG4gICAgICBpbkNsYXNzID0gXCJwdC1wYWdlLW1vdmVGcm9tVG9wRmFkZVwiO1xyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBjYXNlIDc6XHJcbiAgICAgIG91dENsYXNzID0gXCJwdC1wYWdlLW1vdmVUb1JpZ2h0RWFzaW5nIHB0LXBhZ2Utb250b3BcIjtcclxuICAgICAgaW5DbGFzcyA9IFwicHQtcGFnZS1tb3ZlRnJvbUxlZnRcIjtcclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSA4OlxyXG4gICAgICBvdXRDbGFzcyA9IFwicHQtcGFnZS1tb3ZlVG9Cb3R0b21FYXNpbmcgcHQtcGFnZS1vbnRvcFwiO1xyXG4gICAgICBpbkNsYXNzID0gXCJwdC1wYWdlLW1vdmVGcm9tVG9wXCI7XHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgOTpcclxuICAgICAgb3V0Q2xhc3MgPSBcInB0LXBhZ2Utc2NhbGVEb3duXCI7XHJcbiAgICAgIGluQ2xhc3MgPSBcInB0LXBhZ2UtbW92ZUZyb21MZWZ0IHB0LXBhZ2Utb250b3BcIjtcclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSAxMDpcclxuICAgICAgb3V0Q2xhc3MgPSBcInB0LXBhZ2Utc2NhbGVEb3duXCI7XHJcbiAgICAgIGluQ2xhc3MgPSBcInB0LXBhZ2UtbW92ZUZyb21Ub3AgcHQtcGFnZS1vbnRvcFwiO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMTE6XHJcbiAgICAgIG91dENsYXNzID0gXCJwdC1wYWdlLXNjYWxlRG93blwiO1xyXG4gICAgICBpbkNsYXNzID0gXCJwdC1wYWdlLXNjYWxlVXBEb3duIHB0LXBhZ2UtZGVsYXkzMDBcIjtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDEyOlxyXG4gICAgICBvdXRDbGFzcyA9IFwicHQtcGFnZS1zY2FsZURvd25VcFwiO1xyXG4gICAgICBpbkNsYXNzID0gXCJwdC1wYWdlLXNjYWxlVXAgcHQtcGFnZS1kZWxheTMwMFwiO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMTM6XHJcbiAgICAgIG91dENsYXNzID0gXCJwdC1wYWdlLW1vdmVUb0xlZnQgcHQtcGFnZS1vbnRvcFwiO1xyXG4gICAgICBpbkNsYXNzID0gXCJwdC1wYWdlLXNjYWxlVXBcIjtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDE0OlxyXG4gICAgICBvdXRDbGFzcyA9IFwicHQtcGFnZS1tb3ZlVG9SaWdodCBwdC1wYWdlLW9udG9wXCI7XHJcbiAgICAgIGluQ2xhc3MgPSBcInB0LXBhZ2Utc2NhbGVVcFwiO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMTU6XHJcbiAgICAgIG91dENsYXNzID0gXCJwdC1wYWdlLW1vdmVUb1RvcCBwdC1wYWdlLW9udG9wXCI7XHJcbiAgICAgIGluQ2xhc3MgPSBcInB0LXBhZ2Utc2NhbGVVcFwiO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMTY6XHJcbiAgICAgIG91dENsYXNzID0gXCJwdC1wYWdlLW1vdmVUb0JvdHRvbSBwdC1wYWdlLW9udG9wXCI7XHJcbiAgICAgIGluQ2xhc3MgPSBcInB0LXBhZ2Utc2NhbGVVcFwiO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMTc6XHJcbiAgICAgIG91dENsYXNzID0gXCJwdC1wYWdlLXNjYWxlRG93bkNlbnRlclwiO1xyXG4gICAgICBpbkNsYXNzID0gXCJwdC1wYWdlLXNjYWxlVXBDZW50ZXIgcHQtcGFnZS1kZWxheTQwMFwiO1xyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBjYXNlIDE4OlxyXG4gICAgICBvdXRDbGFzcyA9IFwicHQtcGFnZS1yb3RhdGVMZWZ0U2lkZUZpcnN0XCI7XHJcbiAgICAgIGluQ2xhc3MgPSBcInB0LXBhZ2UtbW92ZUZyb21MZWZ0IHB0LXBhZ2UtZGVsYXkyMDAgcHQtcGFnZS1vbnRvcFwiO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMTk6XHJcbiAgICAgIG91dENsYXNzID0gXCJwdC1wYWdlLXJvdGF0ZVRvcFNpZGVGaXJzdFwiO1xyXG4gICAgICBpbkNsYXNzID0gXCJwdC1wYWdlLW1vdmVGcm9tVG9wIHB0LXBhZ2UtZGVsYXkyMDAgcHQtcGFnZS1vbnRvcFwiO1xyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBjYXNlIDIwOlxyXG4gICAgICBvdXRDbGFzcyA9IFwicHQtcGFnZS1mbGlwT3V0UmlnaHRcIjtcclxuICAgICAgaW5DbGFzcyA9IFwicHQtcGFnZS1mbGlwSW5MZWZ0IHB0LXBhZ2UtZGVsYXk1MDBcIjtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDIxOlxyXG4gICAgICBvdXRDbGFzcyA9IFwicHQtcGFnZS1mbGlwT3V0TGVmdFwiO1xyXG4gICAgICBpbkNsYXNzID0gXCJwdC1wYWdlLWZsaXBJblJpZ2h0IHB0LXBhZ2UtZGVsYXk1MDBcIjtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDIyOlxyXG4gICAgICBvdXRDbGFzcyA9IFwicHQtcGFnZS1mbGlwT3V0VG9wXCI7XHJcbiAgICAgIGluQ2xhc3MgPSBcInB0LXBhZ2UtZmxpcEluQm90dG9tIHB0LXBhZ2UtZGVsYXk1MDBcIjtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDIzOlxyXG4gICAgICBvdXRDbGFzcyA9IFwicHQtcGFnZS1mbGlwT3V0Qm90dG9tXCI7XHJcbiAgICAgIGluQ2xhc3MgPSBcInB0LXBhZ2UtZmxpcEluVG9wIHB0LXBhZ2UtZGVsYXk1MDBcIjtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDI0OlxyXG4gICAgICBvdXRDbGFzcyA9IFwicHQtcGFnZS1yb3RhdGVGYWxsIHB0LXBhZ2Utb250b3BcIjtcclxuICAgICAgaW5DbGFzcyA9IFwicHQtcGFnZS1zY2FsZVVwXCI7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAyNTpcclxuICAgICAgb3V0Q2xhc3MgPSBcInB0LXBhZ2Utcm90YXRlT3V0TmV3c3BhcGVyXCI7XHJcbiAgICAgIGluQ2xhc3MgPSBcInB0LXBhZ2Utcm90YXRlSW5OZXdzcGFwZXIgcHQtcGFnZS1kZWxheTUwMFwiO1xyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBjYXNlIDI2OlxyXG4gICAgICBvdXRDbGFzcyA9IFwicHQtcGFnZS1yb3RhdGVQdXNoUmlnaHRcIjtcclxuICAgICAgaW5DbGFzcyA9IFwicHQtcGFnZS1tb3ZlRnJvbUxlZnQgcHQtcGFnZS1vbnRvcFwiO1xyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBjYXNlIDI3OlxyXG4gICAgICBvdXRDbGFzcyA9IFwicHQtcGFnZS1yb3RhdGVQdXNoTGVmdFwiO1xyXG4gICAgICBpbkNsYXNzID0gXCJwdC1wYWdlLXJvdGF0ZVB1bGxSaWdodCBwdC1wYWdlLWRlbGF5MTgwXCI7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAyODpcclxuICAgICAgb3V0Q2xhc3MgPSBcInB0LXBhZ2Utcm90YXRlUHVzaFJpZ2h0XCI7XHJcbiAgICAgIGluQ2xhc3MgPSBcInB0LXBhZ2Utcm90YXRlUHVsbExlZnQgcHQtcGFnZS1kZWxheTE4MFwiO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMjk6XHJcbiAgICAgIG91dENsYXNzID0gXCJwdC1wYWdlLXJvdGF0ZVB1c2hUb3BcIjtcclxuICAgICAgaW5DbGFzcyA9IFwicHQtcGFnZS1yb3RhdGVQdWxsQm90dG9tIHB0LXBhZ2UtZGVsYXkxODBcIjtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDMwOlxyXG4gICAgICBvdXRDbGFzcyA9IFwicHQtcGFnZS1yb3RhdGVQdXNoQm90dG9tXCI7XHJcbiAgICAgIGluQ2xhc3MgPSBcInB0LXBhZ2Utcm90YXRlUHVsbFRvcCBwdC1wYWdlLWRlbGF5MTgwXCI7XHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgMzE6XHJcbiAgICAgIG91dENsYXNzID0gXCJwdC1wYWdlLXJvdGF0ZUZvbGRSaWdodFwiO1xyXG4gICAgICBpbkNsYXNzID0gXCJwdC1wYWdlLW1vdmVGcm9tTGVmdEZhZGVcIjtcclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSAzMjpcclxuICAgICAgb3V0Q2xhc3MgPSBcInB0LXBhZ2Utcm90YXRlRm9sZEJvdHRvbVwiO1xyXG4gICAgICBpbkNsYXNzID0gXCJwdC1wYWdlLW1vdmVGcm9tVG9wRmFkZVwiO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMzM6XHJcbiAgICAgIG91dENsYXNzID0gXCJwdC1wYWdlLW1vdmVUb1JpZ2h0RmFkZVwiO1xyXG4gICAgICBpbkNsYXNzID0gXCJwdC1wYWdlLXJvdGF0ZVVuZm9sZExlZnRcIjtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDM0OlxyXG4gICAgICBvdXRDbGFzcyA9IFwicHQtcGFnZS1tb3ZlVG9MZWZ0RmFkZVwiO1xyXG4gICAgICBpbkNsYXNzID0gXCJwdC1wYWdlLXJvdGF0ZVVuZm9sZFJpZ2h0XCI7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAzNTpcclxuICAgICAgb3V0Q2xhc3MgPSBcInB0LXBhZ2UtbW92ZVRvQm90dG9tRmFkZVwiO1xyXG4gICAgICBpbkNsYXNzID0gXCJwdC1wYWdlLXJvdGF0ZVVuZm9sZFRvcFwiO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMzY6XHJcbiAgICAgIG91dENsYXNzID0gXCJwdC1wYWdlLW1vdmVUb1RvcEZhZGVcIjtcclxuICAgICAgaW5DbGFzcyA9IFwicHQtcGFnZS1yb3RhdGVVbmZvbGRCb3R0b21cIjtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDM3OlxyXG4gICAgICBvdXRDbGFzcyA9IFwicHQtcGFnZS1yb3RhdGVSb29tTGVmdE91dCBwdC1wYWdlLW9udG9wXCI7XHJcbiAgICAgIGluQ2xhc3MgPSBcInB0LXBhZ2Utcm90YXRlUm9vbUxlZnRJblwiO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMzg6XHJcbiAgICAgIG91dENsYXNzID0gXCJwdC1wYWdlLXJvdGF0ZVJvb21SaWdodE91dCBwdC1wYWdlLW9udG9wXCI7XHJcbiAgICAgIGluQ2xhc3MgPSBcInB0LXBhZ2Utcm90YXRlUm9vbVJpZ2h0SW5cIjtcclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSAzOTpcclxuICAgICAgb3V0Q2xhc3MgPSBcInB0LXBhZ2Utcm90YXRlUm9vbUJvdHRvbU91dCBwdC1wYWdlLW9udG9wXCI7XHJcbiAgICAgIGluQ2xhc3MgPSBcInB0LXBhZ2Utcm90YXRlUm9vbUJvdHRvbUluXCI7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSA0MDpcclxuICAgICAgb3V0Q2xhc3MgPSBcInB0LXBhZ2Utcm90YXRlQ3ViZUxlZnRPdXQgcHQtcGFnZS1vbnRvcFwiO1xyXG4gICAgICBpbkNsYXNzID0gXCJwdC1wYWdlLXJvdGF0ZUN1YmVMZWZ0SW5cIjtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDQxOlxyXG4gICAgICBvdXRDbGFzcyA9IFwicHQtcGFnZS1yb3RhdGVDdWJlUmlnaHRPdXQgcHQtcGFnZS1vbnRvcFwiO1xyXG4gICAgICBpbkNsYXNzID0gXCJwdC1wYWdlLXJvdGF0ZUN1YmVSaWdodEluXCI7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSA0MjpcclxuICAgICAgb3V0Q2xhc3MgPSBcInB0LXBhZ2Utcm90YXRlQ3ViZVRvcE91dCBwdC1wYWdlLW9udG9wXCI7XHJcbiAgICAgIGluQ2xhc3MgPSBcInB0LXBhZ2Utcm90YXRlQ3ViZVRvcEluXCI7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSA0MzpcclxuICAgICAgb3V0Q2xhc3MgPSBcInB0LXBhZ2Utcm90YXRlQ3ViZUJvdHRvbU91dCBwdC1wYWdlLW9udG9wXCI7XHJcbiAgICAgIGluQ2xhc3MgPSBcInB0LXBhZ2Utcm90YXRlQ3ViZUJvdHRvbUluXCI7XHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgNDQ6XHJcbiAgICAgIG91dENsYXNzID0gXCJwdC1wYWdlLXJvdGF0ZUNhcm91c2VsUmlnaHRPdXQgcHQtcGFnZS1vbnRvcFwiO1xyXG4gICAgICBpbkNsYXNzID0gXCJwdC1wYWdlLXJvdGF0ZUNhcm91c2VsUmlnaHRJblwiO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgNDU6XHJcbiAgICAgIG91dENsYXNzID0gXCJwdC1wYWdlLXJvdGF0ZUNhcm91c2VsVG9wT3V0IHB0LXBhZ2Utb250b3BcIjtcclxuICAgICAgaW5DbGFzcyA9IFwicHQtcGFnZS1yb3RhdGVDYXJvdXNlbFRvcEluXCI7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSA0NjpcclxuICAgICAgb3V0Q2xhc3MgPSBcInB0LXBhZ2Utcm90YXRlQ2Fyb3VzZWxCb3R0b21PdXQgcHQtcGFnZS1vbnRvcFwiO1xyXG4gICAgICBpbkNsYXNzID0gXCJwdC1wYWdlLXJvdGF0ZUNhcm91c2VsQm90dG9tSW5cIjtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDQ3OlxyXG4gICAgICBvdXRDbGFzcyA9IFwicHQtcGFnZS1yb3RhdGVTaWRlc091dFwiO1xyXG4gICAgICBpbkNsYXNzID0gXCJwdC1wYWdlLXJvdGF0ZVNpZGVzSW4gcHQtcGFnZS1kZWxheTIwMFwiO1xyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBjYXNlIDQ4OlxyXG4gICAgICBvdXRDbGFzcyA9IFwicHQtcGFnZS1yb3RhdGVTbGlkZU91dFRvUmlnaHRcIjtcclxuICAgICAgaW5DbGFzcyA9IFwicHQtcGFnZS1yb3RhdGVTbGlkZUluRnJvbUxlZnRcIjtcclxuICAgICAgYnJlYWs7XHJcbiAgfVxyXG4gIHJldHVybiB7IG91dENsYXNzLCBpbkNsYXNzIH07XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJwYWdlQWN0aXZlQW5pbWF0aW9uIiwic2VjdGlvbiIsInBhZ2VUcmFuc2l0aW9uQW5pbWF0aW9uIiwic2VjdGlvbnMiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJkZWxheSIsImFjdGl2ZUNsYXNzIiwiaW5DbGFzcyIsInNwbGl0Iiwib3V0Q2xhc3MiLCJpIiwibGVuZ3RoIiwic2VjdGlvbkRvbSIsImdldEF0dHJpYnV0ZSIsImNsYXNzTGlzdCIsImFkZCIsInNldFRpbWVvdXQiLCJyZW1vdmUiLCJzaW1wbGVCYXIiLCJ3aW5kb3ciLCJTaW1wbGVCYXIiLCJyZXF1aXJlIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJmb3JFYWNoIiwiY2FsbCIsImVsIiwiZGVmYXVsdFBhZ2VBbmltYXRpb25CeVBhZ2VOYW1lIiwiaW5kZXhEYXJrIiwiaW5kZXhEYXJrU2xpZGVyIiwiaW5kZXhEYXJrUGFydGljbGVzMSIsImluZGV4RGFya1BhcnRpY2xlczIiLCJpbmRleERhcmtIdG1sNVZpZGVvIiwiaW5kZXhEYXJrWW91dHViZVZpZGVvIiwiaW5kZXhMaWdodCIsImluZGV4TGlnaHRTbGlkZXIiLCJpbmRleExpZ2h0UGFydGljbGVzMSIsImluZGV4TGlnaHRQYXJ0aWNsZXMyIiwiaW5kZXhMaWdodEh0bWw1VmlkZW8iLCJpbmRleExpZ2h0WW91dHViZVZpZGVvIiwiZmluZEFuaW1hdGlvbiIsImFuaW1hdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/utils.js\n"));

/***/ }),

/***/ "./node_modules/next/head.js":
/*!***********************************!*\
  !*** ./node_modules/next/head.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlIQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzPzg4NDkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3Qvc2hhcmVkL2xpYi9oZWFkJylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/head.js\n"));

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_MODULE_REFERENCE;\n\n{\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n}\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      // eslint-disable-next-line no-fallthrough\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if ( !fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n    return type;\n  }\n} // $FlowFixMe only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner$1.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement$1(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement$1(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object') {\n      return;\n    }\n\n    if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else if (node) {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement$1(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement$1(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement$1(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement$1(null);\n    }\n  }\n}\n\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n\nvar jsxDEV$1 =  jsxWithValidation ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV$1;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyw0Q0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsZUFBZTtBQUNoSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQSxxQ0FBcUM7O0FBRXJDLGdDQUFnQztBQUNoQztBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxlQUFlO0FBQzFCLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBLGtCQUFr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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUEsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZCxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/MTdlMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG4vLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXG4vLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cblxudmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlOyAvLyBUcmFjayB3aGljaCBGaWJlcihzKSBzY2hlZHVsZSByZW5kZXIgd29yay5cblxudmFyIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0U7XG5cbntcbiAgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1vZHVsZS5yZWZlcmVuY2UnKTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgIC8vIHdpdGguXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn0gLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoICFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcbiAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cblxuXG4gICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIF9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSkge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKGhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnO1xuICAgIHJldHVybiB0eXBlO1xuICB9XG59IC8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5cblxuZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAge1xuICAgIHRyeSB7XG4gICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgLy8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG4gIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXG4gIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cbiAgLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4gIC8vXG4gIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuICAvLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcbiAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG4gIC8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxuICAvL1xuICAvLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG4gIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cbiAgLy9cbiAgLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cbiAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XG4gIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcbiAgLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xuICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG4gIC8vXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICByZXR1cm4gJycgKyB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBzZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSksIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYodHlwZSwgY29uZmlnLCBtYXliZUtleSwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICB7XG4gICAgaWYgKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICB7XG4gICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gICAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gICAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSk7XG5cbiAgICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgICAgfVxuXG4gICAgICBlcnJvcignUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIHNvdXJjZSwgc2VsZik7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpXSwgdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn0gLy8gVGhlc2UgdHdvIGZ1bmN0aW9ucyBleGlzdCB0byBzdGlsbCBnZXQgY2hpbGQgd2FybmluZ3MgaW4gZGV2XG5cbnZhciBqc3hERVYkMSA9ICBqc3hXaXRoVmFsaWRhdGlvbiA7XG5cbmV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuZXhwb3J0cy5qc3hERVYgPSBqc3hERVYkMTtcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"./node_modules/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSx1SkFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz81Nzc3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "./node_modules/simplebar/dist/simplebar.js":
/*!**************************************************!*\
  !*** ./node_modules/simplebar/dist/simplebar.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * SimpleBar.js - v5.3.9\n * Scrollbars, simpler.\n * https://grsmto.github.io/simplebar/\n *\n * Made by Adrien Denat from a fork by Jonathan Nicol\n * Under MIT License\n */\n\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\t0;\n}(this, (function () { 'use strict';\n\n\tvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};\n\n\tfunction createCommonjsModule(fn, module) {\n\t\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n\t}\n\n\tvar check = function (it) {\n\t  return it && it.Math == Math && it;\n\t};\n\n\t// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\tvar global_1 =\n\t  // eslint-disable-next-line es-x/no-global-this -- safe\n\t  check(typeof globalThis == 'object' && globalThis) ||\n\t  check(typeof window == 'object' && window) ||\n\t  // eslint-disable-next-line no-restricted-globals -- safe\n\t  check(typeof self == 'object' && self) ||\n\t  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||\n\t  // eslint-disable-next-line no-new-func -- fallback\n\t  (function () { return this; })() || Function('return this')();\n\n\t// eslint-disable-next-line es-x/no-object-defineproperty -- safe\n\tvar defineProperty = Object.defineProperty;\n\n\tvar defineGlobalProperty = function (key, value) {\n\t  try {\n\t    defineProperty(global_1, key, { value: value, configurable: true, writable: true });\n\t  } catch (error) {\n\t    global_1[key] = value;\n\t  } return value;\n\t};\n\n\tvar SHARED = '__core-js_shared__';\n\tvar store = global_1[SHARED] || defineGlobalProperty(SHARED, {});\n\n\tvar sharedStore = store;\n\n\tvar shared = createCommonjsModule(function (module) {\n\t(module.exports = function (key, value) {\n\t  return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});\n\t})('versions', []).push({\n\t  version: '3.22.6',\n\t  mode:  'global',\n\t  copyright: ' 2014-2022 Denis Pushkarev (zloirock.ru)',\n\t  license: 'https://github.com/zloirock/core-js/blob/v3.22.6/LICENSE',\n\t  source: 'https://github.com/zloirock/core-js'\n\t});\n\t});\n\n\tvar fails = function (exec) {\n\t  try {\n\t    return !!exec();\n\t  } catch (error) {\n\t    return true;\n\t  }\n\t};\n\n\tvar functionBindNative = !fails(function () {\n\t  // eslint-disable-next-line es-x/no-function-prototype-bind -- safe\n\t  var test = (function () { /* empty */ }).bind();\n\t  // eslint-disable-next-line no-prototype-builtins -- safe\n\t  return typeof test != 'function' || test.hasOwnProperty('prototype');\n\t});\n\n\tvar FunctionPrototype = Function.prototype;\n\tvar bind = FunctionPrototype.bind;\n\tvar call = FunctionPrototype.call;\n\tvar uncurryThis = functionBindNative && bind.bind(call, call);\n\n\tvar functionUncurryThis = functionBindNative ? function (fn) {\n\t  return fn && uncurryThis(fn);\n\t} : function (fn) {\n\t  return fn && function () {\n\t    return call.apply(fn, arguments);\n\t  };\n\t};\n\n\tvar TypeError$1 = global_1.TypeError;\n\n\t// `RequireObjectCoercible` abstract operation\n\t// https://tc39.es/ecma262/#sec-requireobjectcoercible\n\tvar requireObjectCoercible = function (it) {\n\t  if (it == undefined) throw TypeError$1(\"Can't call method on \" + it);\n\t  return it;\n\t};\n\n\tvar Object$1 = global_1.Object;\n\n\t// `ToObject` abstract operation\n\t// https://tc39.es/ecma262/#sec-toobject\n\tvar toObject = function (argument) {\n\t  return Object$1(requireObjectCoercible(argument));\n\t};\n\n\tvar hasOwnProperty = functionUncurryThis({}.hasOwnProperty);\n\n\t// `HasOwnProperty` abstract operation\n\t// https://tc39.es/ecma262/#sec-hasownproperty\n\t// eslint-disable-next-line es-x/no-object-hasown -- safe\n\tvar hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {\n\t  return hasOwnProperty(toObject(it), key);\n\t};\n\n\tvar id = 0;\n\tvar postfix = Math.random();\n\tvar toString = functionUncurryThis(1.0.toString);\n\n\tvar uid = function (key) {\n\t  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);\n\t};\n\n\t// `IsCallable` abstract operation\n\t// https://tc39.es/ecma262/#sec-iscallable\n\tvar isCallable = function (argument) {\n\t  return typeof argument == 'function';\n\t};\n\n\tvar aFunction = function (argument) {\n\t  return isCallable(argument) ? argument : undefined;\n\t};\n\n\tvar getBuiltIn = function (namespace, method) {\n\t  return arguments.length < 2 ? aFunction(global_1[namespace]) : global_1[namespace] && global_1[namespace][method];\n\t};\n\n\tvar engineUserAgent = getBuiltIn('navigator', 'userAgent') || '';\n\n\tvar process = global_1.process;\n\tvar Deno = global_1.Deno;\n\tvar versions = process && process.versions || Deno && Deno.version;\n\tvar v8 = versions && versions.v8;\n\tvar match, version;\n\n\tif (v8) {\n\t  match = v8.split('.');\n\t  // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n\t  // but their correct versions are not interesting for us\n\t  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n\t}\n\n\t// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n\t// so check `userAgent` even if `.v8` exists, but 0\n\tif (!version && engineUserAgent) {\n\t  match = engineUserAgent.match(/Edge\\/(\\d+)/);\n\t  if (!match || match[1] >= 74) {\n\t    match = engineUserAgent.match(/Chrome\\/(\\d+)/);\n\t    if (match) version = +match[1];\n\t  }\n\t}\n\n\tvar engineV8Version = version;\n\n\t/* eslint-disable es-x/no-symbol -- required for testing */\n\n\n\n\t// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing\n\tvar nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {\n\t  var symbol = Symbol();\n\t  // Chrome 38 Symbol has incorrect toString conversion\n\t  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n\t  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n\t    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n\t    !Symbol.sham && engineV8Version && engineV8Version < 41;\n\t});\n\n\t/* eslint-disable es-x/no-symbol -- required for testing */\n\n\n\tvar useSymbolAsUid = nativeSymbol\n\t  && !Symbol.sham\n\t  && typeof Symbol.iterator == 'symbol';\n\n\tvar WellKnownSymbolsStore = shared('wks');\n\tvar Symbol$1 = global_1.Symbol;\n\tvar symbolFor = Symbol$1 && Symbol$1['for'];\n\tvar createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;\n\n\tvar wellKnownSymbol = function (name) {\n\t  if (!hasOwnProperty_1(WellKnownSymbolsStore, name) || !(nativeSymbol || typeof WellKnownSymbolsStore[name] == 'string')) {\n\t    var description = 'Symbol.' + name;\n\t    if (nativeSymbol && hasOwnProperty_1(Symbol$1, name)) {\n\t      WellKnownSymbolsStore[name] = Symbol$1[name];\n\t    } else if (useSymbolAsUid && symbolFor) {\n\t      WellKnownSymbolsStore[name] = symbolFor(description);\n\t    } else {\n\t      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n\t    }\n\t  } return WellKnownSymbolsStore[name];\n\t};\n\n\tvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\n\tvar test = {};\n\n\ttest[TO_STRING_TAG] = 'z';\n\n\tvar toStringTagSupport = String(test) === '[object z]';\n\n\t// Detect IE8's incomplete defineProperty implementation\n\tvar descriptors = !fails(function () {\n\t  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n\t  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n\t});\n\n\tvar isObject = function (it) {\n\t  return typeof it == 'object' ? it !== null : isCallable(it);\n\t};\n\n\tvar document$1 = global_1.document;\n\t// typeof document.createElement is 'object' in old IE\n\tvar EXISTS = isObject(document$1) && isObject(document$1.createElement);\n\n\tvar documentCreateElement = function (it) {\n\t  return EXISTS ? document$1.createElement(it) : {};\n\t};\n\n\t// Thanks to IE8 for its funny defineProperty\n\tvar ie8DomDefine = !descriptors && !fails(function () {\n\t  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n\t  return Object.defineProperty(documentCreateElement('div'), 'a', {\n\t    get: function () { return 7; }\n\t  }).a != 7;\n\t});\n\n\t// V8 ~ Chrome 36-\n\t// https://bugs.chromium.org/p/v8/issues/detail?id=3334\n\tvar v8PrototypeDefineBug = descriptors && fails(function () {\n\t  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n\t  return Object.defineProperty(function () { /* empty */ }, 'prototype', {\n\t    value: 42,\n\t    writable: false\n\t  }).prototype != 42;\n\t});\n\n\tvar String$1 = global_1.String;\n\tvar TypeError$2 = global_1.TypeError;\n\n\t// `Assert: Type(argument) is Object`\n\tvar anObject = function (argument) {\n\t  if (isObject(argument)) return argument;\n\t  throw TypeError$2(String$1(argument) + ' is not an object');\n\t};\n\n\tvar call$1 = Function.prototype.call;\n\n\tvar functionCall = functionBindNative ? call$1.bind(call$1) : function () {\n\t  return call$1.apply(call$1, arguments);\n\t};\n\n\tvar objectIsPrototypeOf = functionUncurryThis({}.isPrototypeOf);\n\n\tvar Object$2 = global_1.Object;\n\n\tvar isSymbol = useSymbolAsUid ? function (it) {\n\t  return typeof it == 'symbol';\n\t} : function (it) {\n\t  var $Symbol = getBuiltIn('Symbol');\n\t  return isCallable($Symbol) && objectIsPrototypeOf($Symbol.prototype, Object$2(it));\n\t};\n\n\tvar String$2 = global_1.String;\n\n\tvar tryToString = function (argument) {\n\t  try {\n\t    return String$2(argument);\n\t  } catch (error) {\n\t    return 'Object';\n\t  }\n\t};\n\n\tvar TypeError$3 = global_1.TypeError;\n\n\t// `Assert: IsCallable(argument) is true`\n\tvar aCallable = function (argument) {\n\t  if (isCallable(argument)) return argument;\n\t  throw TypeError$3(tryToString(argument) + ' is not a function');\n\t};\n\n\t// `GetMethod` abstract operation\n\t// https://tc39.es/ecma262/#sec-getmethod\n\tvar getMethod = function (V, P) {\n\t  var func = V[P];\n\t  return func == null ? undefined : aCallable(func);\n\t};\n\n\tvar TypeError$4 = global_1.TypeError;\n\n\t// `OrdinaryToPrimitive` abstract operation\n\t// https://tc39.es/ecma262/#sec-ordinarytoprimitive\n\tvar ordinaryToPrimitive = function (input, pref) {\n\t  var fn, val;\n\t  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = functionCall(fn, input))) return val;\n\t  if (isCallable(fn = input.valueOf) && !isObject(val = functionCall(fn, input))) return val;\n\t  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = functionCall(fn, input))) return val;\n\t  throw TypeError$4(\"Can't convert object to primitive value\");\n\t};\n\n\tvar TypeError$5 = global_1.TypeError;\n\tvar TO_PRIMITIVE = wellKnownSymbol('toPrimitive');\n\n\t// `ToPrimitive` abstract operation\n\t// https://tc39.es/ecma262/#sec-toprimitive\n\tvar toPrimitive = function (input, pref) {\n\t  if (!isObject(input) || isSymbol(input)) return input;\n\t  var exoticToPrim = getMethod(input, TO_PRIMITIVE);\n\t  var result;\n\t  if (exoticToPrim) {\n\t    if (pref === undefined) pref = 'default';\n\t    result = functionCall(exoticToPrim, input, pref);\n\t    if (!isObject(result) || isSymbol(result)) return result;\n\t    throw TypeError$5(\"Can't convert object to primitive value\");\n\t  }\n\t  if (pref === undefined) pref = 'number';\n\t  return ordinaryToPrimitive(input, pref);\n\t};\n\n\t// `ToPropertyKey` abstract operation\n\t// https://tc39.es/ecma262/#sec-topropertykey\n\tvar toPropertyKey = function (argument) {\n\t  var key = toPrimitive(argument, 'string');\n\t  return isSymbol(key) ? key : key + '';\n\t};\n\n\tvar TypeError$6 = global_1.TypeError;\n\t// eslint-disable-next-line es-x/no-object-defineproperty -- safe\n\tvar $defineProperty = Object.defineProperty;\n\t// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\n\tvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\tvar ENUMERABLE = 'enumerable';\n\tvar CONFIGURABLE = 'configurable';\n\tvar WRITABLE = 'writable';\n\n\t// `Object.defineProperty` method\n\t// https://tc39.es/ecma262/#sec-object.defineproperty\n\tvar f = descriptors ? v8PrototypeDefineBug ? function defineProperty(O, P, Attributes) {\n\t  anObject(O);\n\t  P = toPropertyKey(P);\n\t  anObject(Attributes);\n\t  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n\t    var current = $getOwnPropertyDescriptor(O, P);\n\t    if (current && current[WRITABLE]) {\n\t      O[P] = Attributes.value;\n\t      Attributes = {\n\t        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],\n\t        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n\t        writable: false\n\t      };\n\t    }\n\t  } return $defineProperty(O, P, Attributes);\n\t} : $defineProperty : function defineProperty(O, P, Attributes) {\n\t  anObject(O);\n\t  P = toPropertyKey(P);\n\t  anObject(Attributes);\n\t  if (ie8DomDefine) try {\n\t    return $defineProperty(O, P, Attributes);\n\t  } catch (error) { /* empty */ }\n\t  if ('get' in Attributes || 'set' in Attributes) throw TypeError$6('Accessors not supported');\n\t  if ('value' in Attributes) O[P] = Attributes.value;\n\t  return O;\n\t};\n\n\tvar objectDefineProperty = {\n\t\tf: f\n\t};\n\n\tvar createPropertyDescriptor = function (bitmap, value) {\n\t  return {\n\t    enumerable: !(bitmap & 1),\n\t    configurable: !(bitmap & 2),\n\t    writable: !(bitmap & 4),\n\t    value: value\n\t  };\n\t};\n\n\tvar createNonEnumerableProperty = descriptors ? function (object, key, value) {\n\t  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));\n\t} : function (object, key, value) {\n\t  object[key] = value;\n\t  return object;\n\t};\n\n\tvar FunctionPrototype$1 = Function.prototype;\n\t// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\n\tvar getDescriptor = descriptors && Object.getOwnPropertyDescriptor;\n\n\tvar EXISTS$1 = hasOwnProperty_1(FunctionPrototype$1, 'name');\n\t// additional protection from minified / mangled / dropped function names\n\tvar PROPER = EXISTS$1 && (function something() { /* empty */ }).name === 'something';\n\tvar CONFIGURABLE$1 = EXISTS$1 && (!descriptors || (descriptors && getDescriptor(FunctionPrototype$1, 'name').configurable));\n\n\tvar functionName = {\n\t  EXISTS: EXISTS$1,\n\t  PROPER: PROPER,\n\t  CONFIGURABLE: CONFIGURABLE$1\n\t};\n\n\tvar functionToString = functionUncurryThis(Function.toString);\n\n\t// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\n\tif (!isCallable(sharedStore.inspectSource)) {\n\t  sharedStore.inspectSource = function (it) {\n\t    return functionToString(it);\n\t  };\n\t}\n\n\tvar inspectSource = sharedStore.inspectSource;\n\n\tvar WeakMap$1 = global_1.WeakMap;\n\n\tvar nativeWeakMap = isCallable(WeakMap$1) && /native code/.test(inspectSource(WeakMap$1));\n\n\tvar keys = shared('keys');\n\n\tvar sharedKey = function (key) {\n\t  return keys[key] || (keys[key] = uid(key));\n\t};\n\n\tvar hiddenKeys = {};\n\n\tvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\n\tvar TypeError$7 = global_1.TypeError;\n\tvar WeakMap$2 = global_1.WeakMap;\n\tvar set, get, has;\n\n\tvar enforce = function (it) {\n\t  return has(it) ? get(it) : set(it, {});\n\t};\n\n\tvar getterFor = function (TYPE) {\n\t  return function (it) {\n\t    var state;\n\t    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n\t      throw TypeError$7('Incompatible receiver, ' + TYPE + ' required');\n\t    } return state;\n\t  };\n\t};\n\n\tif (nativeWeakMap || sharedStore.state) {\n\t  var store$1 = sharedStore.state || (sharedStore.state = new WeakMap$2());\n\t  var wmget = functionUncurryThis(store$1.get);\n\t  var wmhas = functionUncurryThis(store$1.has);\n\t  var wmset = functionUncurryThis(store$1.set);\n\t  set = function (it, metadata) {\n\t    if (wmhas(store$1, it)) throw new TypeError$7(OBJECT_ALREADY_INITIALIZED);\n\t    metadata.facade = it;\n\t    wmset(store$1, it, metadata);\n\t    return metadata;\n\t  };\n\t  get = function (it) {\n\t    return wmget(store$1, it) || {};\n\t  };\n\t  has = function (it) {\n\t    return wmhas(store$1, it);\n\t  };\n\t} else {\n\t  var STATE = sharedKey('state');\n\t  hiddenKeys[STATE] = true;\n\t  set = function (it, metadata) {\n\t    if (hasOwnProperty_1(it, STATE)) throw new TypeError$7(OBJECT_ALREADY_INITIALIZED);\n\t    metadata.facade = it;\n\t    createNonEnumerableProperty(it, STATE, metadata);\n\t    return metadata;\n\t  };\n\t  get = function (it) {\n\t    return hasOwnProperty_1(it, STATE) ? it[STATE] : {};\n\t  };\n\t  has = function (it) {\n\t    return hasOwnProperty_1(it, STATE);\n\t  };\n\t}\n\n\tvar internalState = {\n\t  set: set,\n\t  get: get,\n\t  has: has,\n\t  enforce: enforce,\n\t  getterFor: getterFor\n\t};\n\n\tvar makeBuiltIn_1 = createCommonjsModule(function (module) {\n\tvar CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;\n\n\n\n\tvar enforceInternalState = internalState.enforce;\n\tvar getInternalState = internalState.get;\n\t// eslint-disable-next-line es-x/no-object-defineproperty -- safe\n\tvar defineProperty = Object.defineProperty;\n\n\tvar CONFIGURABLE_LENGTH = descriptors && !fails(function () {\n\t  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;\n\t});\n\n\tvar TEMPLATE = String(String).split('String');\n\n\tvar makeBuiltIn = module.exports = function (value, name, options) {\n\t  if (String(name).slice(0, 7) === 'Symbol(') {\n\t    name = '[' + String(name).replace(/^Symbol\\(([^)]*)\\)/, '$1') + ']';\n\t  }\n\t  if (options && options.getter) name = 'get ' + name;\n\t  if (options && options.setter) name = 'set ' + name;\n\t  if (!hasOwnProperty_1(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {\n\t    defineProperty(value, 'name', { value: name, configurable: true });\n\t  }\n\t  if (CONFIGURABLE_LENGTH && options && hasOwnProperty_1(options, 'arity') && value.length !== options.arity) {\n\t    defineProperty(value, 'length', { value: options.arity });\n\t  }\n\t  if (options && hasOwnProperty_1(options, 'constructor') && options.constructor) {\n\t    if (descriptors) try {\n\t      defineProperty(value, 'prototype', { writable: false });\n\t    } catch (error) { /* empty */ }\n\t  } else value.prototype = undefined;\n\t  var state = enforceInternalState(value);\n\t  if (!hasOwnProperty_1(state, 'source')) {\n\t    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');\n\t  } return value;\n\t};\n\n\t// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n\t// eslint-disable-next-line no-extend-native -- required\n\tFunction.prototype.toString = makeBuiltIn(function toString() {\n\t  return isCallable(this) && getInternalState(this).source || inspectSource(this);\n\t}, 'toString');\n\t});\n\n\tvar defineBuiltIn = function (O, key, value, options) {\n\t  if (!options) options = {};\n\t  var simple = options.enumerable;\n\t  var name = options.name !== undefined ? options.name : key;\n\t  if (isCallable(value)) makeBuiltIn_1(value, name, options);\n\t  if (options.global) {\n\t    if (simple) O[key] = value;\n\t    else defineGlobalProperty(key, value);\n\t  } else {\n\t    if (!options.unsafe) delete O[key];\n\t    else if (O[key]) simple = true;\n\t    if (simple) O[key] = value;\n\t    else createNonEnumerableProperty(O, key, value);\n\t  } return O;\n\t};\n\n\tvar toString$1 = functionUncurryThis({}.toString);\n\tvar stringSlice = functionUncurryThis(''.slice);\n\n\tvar classofRaw = function (it) {\n\t  return stringSlice(toString$1(it), 8, -1);\n\t};\n\n\tvar TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');\n\tvar Object$3 = global_1.Object;\n\n\t// ES3 wrong here\n\tvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n\t// fallback for IE11 Script Access Denied error\n\tvar tryGet = function (it, key) {\n\t  try {\n\t    return it[key];\n\t  } catch (error) { /* empty */ }\n\t};\n\n\t// getting tag from ES6+ `Object.prototype.toString`\n\tvar classof = toStringTagSupport ? classofRaw : function (it) {\n\t  var O, tag, result;\n\t  return it === undefined ? 'Undefined' : it === null ? 'Null'\n\t    // @@toStringTag case\n\t    : typeof (tag = tryGet(O = Object$3(it), TO_STRING_TAG$1)) == 'string' ? tag\n\t    // builtinTag case\n\t    : CORRECT_ARGUMENTS ? classofRaw(O)\n\t    // ES3 arguments fallback\n\t    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;\n\t};\n\n\t// `Object.prototype.toString` method implementation\n\t// https://tc39.es/ecma262/#sec-object.prototype.tostring\n\tvar objectToString = toStringTagSupport ? {}.toString : function toString() {\n\t  return '[object ' + classof(this) + ']';\n\t};\n\n\t// `Object.prototype.toString` method\n\t// https://tc39.es/ecma262/#sec-object.prototype.tostring\n\tif (!toStringTagSupport) {\n\t  defineBuiltIn(Object.prototype, 'toString', objectToString, { unsafe: true });\n\t}\n\n\t// iterable DOM collections\n\t// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\n\tvar domIterables = {\n\t  CSSRuleList: 0,\n\t  CSSStyleDeclaration: 0,\n\t  CSSValueList: 0,\n\t  ClientRectList: 0,\n\t  DOMRectList: 0,\n\t  DOMStringList: 0,\n\t  DOMTokenList: 1,\n\t  DataTransferItemList: 0,\n\t  FileList: 0,\n\t  HTMLAllCollection: 0,\n\t  HTMLCollection: 0,\n\t  HTMLFormElement: 0,\n\t  HTMLSelectElement: 0,\n\t  MediaList: 0,\n\t  MimeTypeArray: 0,\n\t  NamedNodeMap: 0,\n\t  NodeList: 1,\n\t  PaintRequestList: 0,\n\t  Plugin: 0,\n\t  PluginArray: 0,\n\t  SVGLengthList: 0,\n\t  SVGNumberList: 0,\n\t  SVGPathSegList: 0,\n\t  SVGPointList: 0,\n\t  SVGStringList: 0,\n\t  SVGTransformList: 0,\n\t  SourceBufferList: 0,\n\t  StyleSheetList: 0,\n\t  TextTrackCueList: 0,\n\t  TextTrackList: 0,\n\t  TouchList: 0\n\t};\n\n\t// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`\n\n\n\tvar classList = documentCreateElement('span').classList;\n\tvar DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;\n\n\tvar domTokenListPrototype = DOMTokenListPrototype === Object.prototype ? undefined : DOMTokenListPrototype;\n\n\tvar bind$1 = functionUncurryThis(functionUncurryThis.bind);\n\n\t// optional / simple context binding\n\tvar functionBindContext = function (fn, that) {\n\t  aCallable(fn);\n\t  return that === undefined ? fn : functionBindNative ? bind$1(fn, that) : function (/* ...args */) {\n\t    return fn.apply(that, arguments);\n\t  };\n\t};\n\n\tvar Object$4 = global_1.Object;\n\tvar split = functionUncurryThis(''.split);\n\n\t// fallback for non-array-like ES3 and non-enumerable old V8 strings\n\tvar indexedObject = fails(function () {\n\t  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n\t  // eslint-disable-next-line no-prototype-builtins -- safe\n\t  return !Object$4('z').propertyIsEnumerable(0);\n\t}) ? function (it) {\n\t  return classofRaw(it) == 'String' ? split(it, '') : Object$4(it);\n\t} : Object$4;\n\n\tvar ceil = Math.ceil;\n\tvar floor = Math.floor;\n\n\t// `Math.trunc` method\n\t// https://tc39.es/ecma262/#sec-math.trunc\n\t// eslint-disable-next-line es-x/no-math-trunc -- safe\n\tvar mathTrunc = Math.trunc || function trunc(x) {\n\t  var n = +x;\n\t  return (n > 0 ? floor : ceil)(n);\n\t};\n\n\t// `ToIntegerOrInfinity` abstract operation\n\t// https://tc39.es/ecma262/#sec-tointegerorinfinity\n\tvar toIntegerOrInfinity = function (argument) {\n\t  var number = +argument;\n\t  // eslint-disable-next-line no-self-compare -- NaN check\n\t  return number !== number || number === 0 ? 0 : mathTrunc(number);\n\t};\n\n\tvar min = Math.min;\n\n\t// `ToLength` abstract operation\n\t// https://tc39.es/ecma262/#sec-tolength\n\tvar toLength = function (argument) {\n\t  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n\t};\n\n\t// `LengthOfArrayLike` abstract operation\n\t// https://tc39.es/ecma262/#sec-lengthofarraylike\n\tvar lengthOfArrayLike = function (obj) {\n\t  return toLength(obj.length);\n\t};\n\n\t// `IsArray` abstract operation\n\t// https://tc39.es/ecma262/#sec-isarray\n\t// eslint-disable-next-line es-x/no-array-isarray -- safe\n\tvar isArray = Array.isArray || function isArray(argument) {\n\t  return classofRaw(argument) == 'Array';\n\t};\n\n\tvar noop = function () { /* empty */ };\n\tvar empty = [];\n\tvar construct = getBuiltIn('Reflect', 'construct');\n\tvar constructorRegExp = /^\\s*(?:class|function)\\b/;\n\tvar exec = functionUncurryThis(constructorRegExp.exec);\n\tvar INCORRECT_TO_STRING = !constructorRegExp.exec(noop);\n\n\tvar isConstructorModern = function isConstructor(argument) {\n\t  if (!isCallable(argument)) return false;\n\t  try {\n\t    construct(noop, empty, argument);\n\t    return true;\n\t  } catch (error) {\n\t    return false;\n\t  }\n\t};\n\n\tvar isConstructorLegacy = function isConstructor(argument) {\n\t  if (!isCallable(argument)) return false;\n\t  switch (classof(argument)) {\n\t    case 'AsyncFunction':\n\t    case 'GeneratorFunction':\n\t    case 'AsyncGeneratorFunction': return false;\n\t  }\n\t  try {\n\t    // we can't check .prototype since constructors produced by .bind haven't it\n\t    // `Function#toString` throws on some built-it function in some legacy engines\n\t    // (for example, `DOMQuad` and similar in FF41-)\n\t    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));\n\t  } catch (error) {\n\t    return true;\n\t  }\n\t};\n\n\tisConstructorLegacy.sham = true;\n\n\t// `IsConstructor` abstract operation\n\t// https://tc39.es/ecma262/#sec-isconstructor\n\tvar isConstructor = !construct || fails(function () {\n\t  var called;\n\t  return isConstructorModern(isConstructorModern.call)\n\t    || !isConstructorModern(Object)\n\t    || !isConstructorModern(function () { called = true; })\n\t    || called;\n\t}) ? isConstructorLegacy : isConstructorModern;\n\n\tvar SPECIES = wellKnownSymbol('species');\n\tvar Array$1 = global_1.Array;\n\n\t// a part of `ArraySpeciesCreate` abstract operation\n\t// https://tc39.es/ecma262/#sec-arrayspeciescreate\n\tvar arraySpeciesConstructor = function (originalArray) {\n\t  var C;\n\t  if (isArray(originalArray)) {\n\t    C = originalArray.constructor;\n\t    // cross-realm fallback\n\t    if (isConstructor(C) && (C === Array$1 || isArray(C.prototype))) C = undefined;\n\t    else if (isObject(C)) {\n\t      C = C[SPECIES];\n\t      if (C === null) C = undefined;\n\t    }\n\t  } return C === undefined ? Array$1 : C;\n\t};\n\n\t// `ArraySpeciesCreate` abstract operation\n\t// https://tc39.es/ecma262/#sec-arrayspeciescreate\n\tvar arraySpeciesCreate = function (originalArray, length) {\n\t  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);\n\t};\n\n\tvar push = functionUncurryThis([].push);\n\n\t// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation\n\tvar createMethod = function (TYPE) {\n\t  var IS_MAP = TYPE == 1;\n\t  var IS_FILTER = TYPE == 2;\n\t  var IS_SOME = TYPE == 3;\n\t  var IS_EVERY = TYPE == 4;\n\t  var IS_FIND_INDEX = TYPE == 6;\n\t  var IS_FILTER_REJECT = TYPE == 7;\n\t  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n\t  return function ($this, callbackfn, that, specificCreate) {\n\t    var O = toObject($this);\n\t    var self = indexedObject(O);\n\t    var boundFunction = functionBindContext(callbackfn, that);\n\t    var length = lengthOfArrayLike(self);\n\t    var index = 0;\n\t    var create = specificCreate || arraySpeciesCreate;\n\t    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;\n\t    var value, result;\n\t    for (;length > index; index++) if (NO_HOLES || index in self) {\n\t      value = self[index];\n\t      result = boundFunction(value, index, O);\n\t      if (TYPE) {\n\t        if (IS_MAP) target[index] = result; // map\n\t        else if (result) switch (TYPE) {\n\t          case 3: return true;              // some\n\t          case 5: return value;             // find\n\t          case 6: return index;             // findIndex\n\t          case 2: push(target, value);      // filter\n\t        } else switch (TYPE) {\n\t          case 4: return false;             // every\n\t          case 7: push(target, value);      // filterReject\n\t        }\n\t      }\n\t    }\n\t    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n\t  };\n\t};\n\n\tvar arrayIteration = {\n\t  // `Array.prototype.forEach` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.foreach\n\t  forEach: createMethod(0),\n\t  // `Array.prototype.map` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.map\n\t  map: createMethod(1),\n\t  // `Array.prototype.filter` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.filter\n\t  filter: createMethod(2),\n\t  // `Array.prototype.some` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.some\n\t  some: createMethod(3),\n\t  // `Array.prototype.every` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.every\n\t  every: createMethod(4),\n\t  // `Array.prototype.find` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.find\n\t  find: createMethod(5),\n\t  // `Array.prototype.findIndex` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.findIndex\n\t  findIndex: createMethod(6),\n\t  // `Array.prototype.filterReject` method\n\t  // https://github.com/tc39/proposal-array-filtering\n\t  filterReject: createMethod(7)\n\t};\n\n\tvar arrayMethodIsStrict = function (METHOD_NAME, argument) {\n\t  var method = [][METHOD_NAME];\n\t  return !!method && fails(function () {\n\t    // eslint-disable-next-line no-useless-call -- required for testing\n\t    method.call(null, argument || function () { return 1; }, 1);\n\t  });\n\t};\n\n\tvar $forEach = arrayIteration.forEach;\n\n\n\tvar STRICT_METHOD = arrayMethodIsStrict('forEach');\n\n\t// `Array.prototype.forEach` method implementation\n\t// https://tc39.es/ecma262/#sec-array.prototype.foreach\n\tvar arrayForEach = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */) {\n\t  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n\t// eslint-disable-next-line es-x/no-array-prototype-foreach -- safe\n\t} : [].forEach;\n\n\tvar handlePrototype = function (CollectionPrototype) {\n\t  // some Chrome versions have non-configurable methods on DOMTokenList\n\t  if (CollectionPrototype && CollectionPrototype.forEach !== arrayForEach) try {\n\t    createNonEnumerableProperty(CollectionPrototype, 'forEach', arrayForEach);\n\t  } catch (error) {\n\t    CollectionPrototype.forEach = arrayForEach;\n\t  }\n\t};\n\n\tfor (var COLLECTION_NAME in domIterables) {\n\t  if (domIterables[COLLECTION_NAME]) {\n\t    handlePrototype(global_1[COLLECTION_NAME] && global_1[COLLECTION_NAME].prototype);\n\t  }\n\t}\n\n\thandlePrototype(domTokenListPrototype);\n\n\tvar canUseDOM = !!(\n\t  typeof window !== 'undefined' &&\n\t  window.document &&\n\t  window.document.createElement\n\t);\n\n\tvar canUseDom = canUseDOM;\n\n\tvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n\t// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\n\tvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n\t// Nashorn ~ JDK8 bug\n\tvar NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n\t// `Object.prototype.propertyIsEnumerable` method implementation\n\t// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\n\tvar f$1 = NASHORN_BUG ? function propertyIsEnumerable(V) {\n\t  var descriptor = getOwnPropertyDescriptor(this, V);\n\t  return !!descriptor && descriptor.enumerable;\n\t} : $propertyIsEnumerable;\n\n\tvar objectPropertyIsEnumerable = {\n\t\tf: f$1\n\t};\n\n\t// toObject with fallback for non-array-like ES3 strings\n\n\n\n\tvar toIndexedObject = function (it) {\n\t  return indexedObject(requireObjectCoercible(it));\n\t};\n\n\t// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\n\tvar $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\n\n\t// `Object.getOwnPropertyDescriptor` method\n\t// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\n\tvar f$2 = descriptors ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {\n\t  O = toIndexedObject(O);\n\t  P = toPropertyKey(P);\n\t  if (ie8DomDefine) try {\n\t    return $getOwnPropertyDescriptor$1(O, P);\n\t  } catch (error) { /* empty */ }\n\t  if (hasOwnProperty_1(O, P)) return createPropertyDescriptor(!functionCall(objectPropertyIsEnumerable.f, O, P), O[P]);\n\t};\n\n\tvar objectGetOwnPropertyDescriptor = {\n\t\tf: f$2\n\t};\n\n\tvar max = Math.max;\n\tvar min$1 = Math.min;\n\n\t// Helper for a popular repeating case of the spec:\n\t// Let integer be ? ToInteger(index).\n\t// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\n\tvar toAbsoluteIndex = function (index, length) {\n\t  var integer = toIntegerOrInfinity(index);\n\t  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);\n\t};\n\n\t// `Array.prototype.{ indexOf, includes }` methods implementation\n\tvar createMethod$1 = function (IS_INCLUDES) {\n\t  return function ($this, el, fromIndex) {\n\t    var O = toIndexedObject($this);\n\t    var length = lengthOfArrayLike(O);\n\t    var index = toAbsoluteIndex(fromIndex, length);\n\t    var value;\n\t    // Array#includes uses SameValueZero equality algorithm\n\t    // eslint-disable-next-line no-self-compare -- NaN check\n\t    if (IS_INCLUDES && el != el) while (length > index) {\n\t      value = O[index++];\n\t      // eslint-disable-next-line no-self-compare -- NaN check\n\t      if (value != value) return true;\n\t    // Array#indexOf ignores holes, Array#includes - not\n\t    } else for (;length > index; index++) {\n\t      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n\t    } return !IS_INCLUDES && -1;\n\t  };\n\t};\n\n\tvar arrayIncludes = {\n\t  // `Array.prototype.includes` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.includes\n\t  includes: createMethod$1(true),\n\t  // `Array.prototype.indexOf` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n\t  indexOf: createMethod$1(false)\n\t};\n\n\tvar indexOf = arrayIncludes.indexOf;\n\n\n\tvar push$1 = functionUncurryThis([].push);\n\n\tvar objectKeysInternal = function (object, names) {\n\t  var O = toIndexedObject(object);\n\t  var i = 0;\n\t  var result = [];\n\t  var key;\n\t  for (key in O) !hasOwnProperty_1(hiddenKeys, key) && hasOwnProperty_1(O, key) && push$1(result, key);\n\t  // Don't enum bug & hidden keys\n\t  while (names.length > i) if (hasOwnProperty_1(O, key = names[i++])) {\n\t    ~indexOf(result, key) || push$1(result, key);\n\t  }\n\t  return result;\n\t};\n\n\t// IE8- don't enum bug keys\n\tvar enumBugKeys = [\n\t  'constructor',\n\t  'hasOwnProperty',\n\t  'isPrototypeOf',\n\t  'propertyIsEnumerable',\n\t  'toLocaleString',\n\t  'toString',\n\t  'valueOf'\n\t];\n\n\tvar hiddenKeys$1 = enumBugKeys.concat('length', 'prototype');\n\n\t// `Object.getOwnPropertyNames` method\n\t// https://tc39.es/ecma262/#sec-object.getownpropertynames\n\t// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe\n\tvar f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n\t  return objectKeysInternal(O, hiddenKeys$1);\n\t};\n\n\tvar objectGetOwnPropertyNames = {\n\t\tf: f$3\n\t};\n\n\t// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe\n\tvar f$4 = Object.getOwnPropertySymbols;\n\n\tvar objectGetOwnPropertySymbols = {\n\t\tf: f$4\n\t};\n\n\tvar concat = functionUncurryThis([].concat);\n\n\t// all object keys, includes non-enumerable and symbols\n\tvar ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n\t  var keys = objectGetOwnPropertyNames.f(anObject(it));\n\t  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;\n\t  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;\n\t};\n\n\tvar copyConstructorProperties = function (target, source, exceptions) {\n\t  var keys = ownKeys(source);\n\t  var defineProperty = objectDefineProperty.f;\n\t  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\n\t  for (var i = 0; i < keys.length; i++) {\n\t    var key = keys[i];\n\t    if (!hasOwnProperty_1(target, key) && !(exceptions && hasOwnProperty_1(exceptions, key))) {\n\t      defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n\t    }\n\t  }\n\t};\n\n\tvar replacement = /#|\\.prototype\\./;\n\n\tvar isForced = function (feature, detection) {\n\t  var value = data[normalize(feature)];\n\t  return value == POLYFILL ? true\n\t    : value == NATIVE ? false\n\t    : isCallable(detection) ? fails(detection)\n\t    : !!detection;\n\t};\n\n\tvar normalize = isForced.normalize = function (string) {\n\t  return String(string).replace(replacement, '.').toLowerCase();\n\t};\n\n\tvar data = isForced.data = {};\n\tvar NATIVE = isForced.NATIVE = 'N';\n\tvar POLYFILL = isForced.POLYFILL = 'P';\n\n\tvar isForced_1 = isForced;\n\n\tvar getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\n\n\n\n\n\n\n\t/*\n\t  options.target         - name of the target object\n\t  options.global         - target is the global object\n\t  options.stat           - export as static methods of target\n\t  options.proto          - export as prototype methods of target\n\t  options.real           - real prototype method for the `pure` version\n\t  options.forced         - export even if the native feature is available\n\t  options.bind           - bind methods to the target, required for the `pure` version\n\t  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n\t  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n\t  options.sham           - add a flag to not completely full polyfills\n\t  options.enumerable     - export as enumerable property\n\t  options.dontCallGetSet - prevent calling a getter on target\n\t  options.name           - the .name of the function if it does not match the key\n\t*/\n\tvar _export = function (options, source) {\n\t  var TARGET = options.target;\n\t  var GLOBAL = options.global;\n\t  var STATIC = options.stat;\n\t  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n\t  if (GLOBAL) {\n\t    target = global_1;\n\t  } else if (STATIC) {\n\t    target = global_1[TARGET] || defineGlobalProperty(TARGET, {});\n\t  } else {\n\t    target = (global_1[TARGET] || {}).prototype;\n\t  }\n\t  if (target) for (key in source) {\n\t    sourceProperty = source[key];\n\t    if (options.dontCallGetSet) {\n\t      descriptor = getOwnPropertyDescriptor$1(target, key);\n\t      targetProperty = descriptor && descriptor.value;\n\t    } else targetProperty = target[key];\n\t    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n\t    // contained in target\n\t    if (!FORCED && targetProperty !== undefined) {\n\t      if (typeof sourceProperty == typeof targetProperty) continue;\n\t      copyConstructorProperties(sourceProperty, targetProperty);\n\t    }\n\t    // add a flag to not completely full polyfills\n\t    if (options.sham || (targetProperty && targetProperty.sham)) {\n\t      createNonEnumerableProperty(sourceProperty, 'sham', true);\n\t    }\n\t    defineBuiltIn(target, key, sourceProperty, options);\n\t  }\n\t};\n\n\tvar String$3 = global_1.String;\n\n\tvar toString_1 = function (argument) {\n\t  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');\n\t  return String$3(argument);\n\t};\n\n\t// a string of all valid unicode whitespaces\n\tvar whitespaces = '\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u2000\\u2001\\u2002' +\n\t  '\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n\n\tvar replace = functionUncurryThis(''.replace);\n\tvar whitespace = '[' + whitespaces + ']';\n\tvar ltrim = RegExp('^' + whitespace + whitespace + '*');\n\tvar rtrim = RegExp(whitespace + whitespace + '*$');\n\n\t// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation\n\tvar createMethod$2 = function (TYPE) {\n\t  return function ($this) {\n\t    var string = toString_1(requireObjectCoercible($this));\n\t    if (TYPE & 1) string = replace(string, ltrim, '');\n\t    if (TYPE & 2) string = replace(string, rtrim, '');\n\t    return string;\n\t  };\n\t};\n\n\tvar stringTrim = {\n\t  // `String.prototype.{ trimLeft, trimStart }` methods\n\t  // https://tc39.es/ecma262/#sec-string.prototype.trimstart\n\t  start: createMethod$2(1),\n\t  // `String.prototype.{ trimRight, trimEnd }` methods\n\t  // https://tc39.es/ecma262/#sec-string.prototype.trimend\n\t  end: createMethod$2(2),\n\t  // `String.prototype.trim` method\n\t  // https://tc39.es/ecma262/#sec-string.prototype.trim\n\t  trim: createMethod$2(3)\n\t};\n\n\tvar trim = stringTrim.trim;\n\n\n\tvar $parseInt = global_1.parseInt;\n\tvar Symbol$2 = global_1.Symbol;\n\tvar ITERATOR = Symbol$2 && Symbol$2.iterator;\n\tvar hex = /^[+-]?0x/i;\n\tvar exec$1 = functionUncurryThis(hex.exec);\n\tvar FORCED = $parseInt(whitespaces + '08') !== 8 || $parseInt(whitespaces + '0x16') !== 22\n\t  // MS Edge 18- broken with boxed symbols\n\t  || (ITERATOR && !fails(function () { $parseInt(Object(ITERATOR)); }));\n\n\t// `parseInt` method\n\t// https://tc39.es/ecma262/#sec-parseint-string-radix\n\tvar numberParseInt = FORCED ? function parseInt(string, radix) {\n\t  var S = trim(toString_1(string));\n\t  return $parseInt(S, (radix >>> 0) || (exec$1(hex, S) ? 16 : 10));\n\t} : $parseInt;\n\n\t// `parseInt` method\n\t// https://tc39.es/ecma262/#sec-parseint-string-radix\n\t_export({ global: true, forced: parseInt != numberParseInt }, {\n\t  parseInt: numberParseInt\n\t});\n\n\t// `Object.keys` method\n\t// https://tc39.es/ecma262/#sec-object.keys\n\t// eslint-disable-next-line es-x/no-object-keys -- safe\n\tvar objectKeys = Object.keys || function keys(O) {\n\t  return objectKeysInternal(O, enumBugKeys);\n\t};\n\n\t// eslint-disable-next-line es-x/no-object-assign -- safe\n\tvar $assign = Object.assign;\n\t// eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n\tvar defineProperty$1 = Object.defineProperty;\n\tvar concat$1 = functionUncurryThis([].concat);\n\n\t// `Object.assign` method\n\t// https://tc39.es/ecma262/#sec-object.assign\n\tvar objectAssign = !$assign || fails(function () {\n\t  // should have correct order of operations (Edge bug)\n\t  if (descriptors && $assign({ b: 1 }, $assign(defineProperty$1({}, 'a', {\n\t    enumerable: true,\n\t    get: function () {\n\t      defineProperty$1(this, 'b', {\n\t        value: 3,\n\t        enumerable: false\n\t      });\n\t    }\n\t  }), { b: 2 })).b !== 1) return true;\n\t  // should work with symbols and should have deterministic property order (V8 bug)\n\t  var A = {};\n\t  var B = {};\n\t  // eslint-disable-next-line es-x/no-symbol -- safe\n\t  var symbol = Symbol();\n\t  var alphabet = 'abcdefghijklmnopqrst';\n\t  A[symbol] = 7;\n\t  alphabet.split('').forEach(function (chr) { B[chr] = chr; });\n\t  return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join('') != alphabet;\n\t}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`\n\t  var T = toObject(target);\n\t  var argumentsLength = arguments.length;\n\t  var index = 1;\n\t  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;\n\t  var propertyIsEnumerable = objectPropertyIsEnumerable.f;\n\t  while (argumentsLength > index) {\n\t    var S = indexedObject(arguments[index++]);\n\t    var keys = getOwnPropertySymbols ? concat$1(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);\n\t    var length = keys.length;\n\t    var j = 0;\n\t    var key;\n\t    while (length > j) {\n\t      key = keys[j++];\n\t      if (!descriptors || functionCall(propertyIsEnumerable, S, key)) T[key] = S[key];\n\t    }\n\t  } return T;\n\t} : $assign;\n\n\t// `Object.assign` method\n\t// https://tc39.es/ecma262/#sec-object.assign\n\t// eslint-disable-next-line es-x/no-object-assign -- required for testing\n\t_export({ target: 'Object', stat: true, arity: 2, forced: Object.assign !== objectAssign }, {\n\t  assign: objectAssign\n\t});\n\n\tvar SPECIES$1 = wellKnownSymbol('species');\n\n\tvar arrayMethodHasSpeciesSupport = function (METHOD_NAME) {\n\t  // We can't use this feature detection in V8 since it causes\n\t  // deoptimization and serious performance degradation\n\t  // https://github.com/zloirock/core-js/issues/677\n\t  return engineV8Version >= 51 || !fails(function () {\n\t    var array = [];\n\t    var constructor = array.constructor = {};\n\t    constructor[SPECIES$1] = function () {\n\t      return { foo: 1 };\n\t    };\n\t    return array[METHOD_NAME](Boolean).foo !== 1;\n\t  });\n\t};\n\n\tvar $filter = arrayIteration.filter;\n\n\n\tvar HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');\n\n\t// `Array.prototype.filter` method\n\t// https://tc39.es/ecma262/#sec-array.prototype.filter\n\t// with adding support of @@species\n\t_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {\n\t  filter: function filter(callbackfn /* , thisArg */) {\n\t    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\t// `Object.defineProperties` method\n\t// https://tc39.es/ecma262/#sec-object.defineproperties\n\t// eslint-disable-next-line es-x/no-object-defineproperties -- safe\n\tvar f$5 = descriptors && !v8PrototypeDefineBug ? Object.defineProperties : function defineProperties(O, Properties) {\n\t  anObject(O);\n\t  var props = toIndexedObject(Properties);\n\t  var keys = objectKeys(Properties);\n\t  var length = keys.length;\n\t  var index = 0;\n\t  var key;\n\t  while (length > index) objectDefineProperty.f(O, key = keys[index++], props[key]);\n\t  return O;\n\t};\n\n\tvar objectDefineProperties = {\n\t\tf: f$5\n\t};\n\n\tvar html = getBuiltIn('document', 'documentElement');\n\n\t/* global ActiveXObject -- old IE, WSH */\n\n\n\n\n\n\n\n\n\tvar GT = '>';\n\tvar LT = '<';\n\tvar PROTOTYPE = 'prototype';\n\tvar SCRIPT = 'script';\n\tvar IE_PROTO = sharedKey('IE_PROTO');\n\n\tvar EmptyConstructor = function () { /* empty */ };\n\n\tvar scriptTag = function (content) {\n\t  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n\t};\n\n\t// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\n\tvar NullProtoObjectViaActiveX = function (activeXDocument) {\n\t  activeXDocument.write(scriptTag(''));\n\t  activeXDocument.close();\n\t  var temp = activeXDocument.parentWindow.Object;\n\t  activeXDocument = null; // avoid memory leak\n\t  return temp;\n\t};\n\n\t// Create object with fake `null` prototype: use iframe Object with cleared prototype\n\tvar NullProtoObjectViaIFrame = function () {\n\t  // Thrash, waste and sodomy: IE GC bug\n\t  var iframe = documentCreateElement('iframe');\n\t  var JS = 'java' + SCRIPT + ':';\n\t  var iframeDocument;\n\t  iframe.style.display = 'none';\n\t  html.appendChild(iframe);\n\t  // https://github.com/zloirock/core-js/issues/475\n\t  iframe.src = String(JS);\n\t  iframeDocument = iframe.contentWindow.document;\n\t  iframeDocument.open();\n\t  iframeDocument.write(scriptTag('document.F=Object'));\n\t  iframeDocument.close();\n\t  return iframeDocument.F;\n\t};\n\n\t// Check for document.domain and active x support\n\t// No need to use active x approach when document.domain is not set\n\t// see https://github.com/es-shims/es5-shim/issues/150\n\t// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n\t// avoid IE GC bug\n\tvar activeXDocument;\n\tvar NullProtoObject = function () {\n\t  try {\n\t    activeXDocument = new ActiveXObject('htmlfile');\n\t  } catch (error) { /* ignore */ }\n\t  NullProtoObject = typeof document != 'undefined'\n\t    ? document.domain && activeXDocument\n\t      ? NullProtoObjectViaActiveX(activeXDocument) // old IE\n\t      : NullProtoObjectViaIFrame()\n\t    : NullProtoObjectViaActiveX(activeXDocument); // WSH\n\t  var length = enumBugKeys.length;\n\t  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n\t  return NullProtoObject();\n\t};\n\n\thiddenKeys[IE_PROTO] = true;\n\n\t// `Object.create` method\n\t// https://tc39.es/ecma262/#sec-object.create\n\t// eslint-disable-next-line es-x/no-object-create -- safe\n\tvar objectCreate = Object.create || function create(O, Properties) {\n\t  var result;\n\t  if (O !== null) {\n\t    EmptyConstructor[PROTOTYPE] = anObject(O);\n\t    result = new EmptyConstructor();\n\t    EmptyConstructor[PROTOTYPE] = null;\n\t    // add \"__proto__\" for Object.getPrototypeOf polyfill\n\t    result[IE_PROTO] = O;\n\t  } else result = NullProtoObject();\n\t  return Properties === undefined ? result : objectDefineProperties.f(result, Properties);\n\t};\n\n\tvar defineProperty$2 = objectDefineProperty.f;\n\n\tvar UNSCOPABLES = wellKnownSymbol('unscopables');\n\tvar ArrayPrototype = Array.prototype;\n\n\t// Array.prototype[@@unscopables]\n\t// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\n\tif (ArrayPrototype[UNSCOPABLES] == undefined) {\n\t  defineProperty$2(ArrayPrototype, UNSCOPABLES, {\n\t    configurable: true,\n\t    value: objectCreate(null)\n\t  });\n\t}\n\n\t// add a key to Array.prototype[@@unscopables]\n\tvar addToUnscopables = function (key) {\n\t  ArrayPrototype[UNSCOPABLES][key] = true;\n\t};\n\n\tvar iterators = {};\n\n\tvar correctPrototypeGetter = !fails(function () {\n\t  function F() { /* empty */ }\n\t  F.prototype.constructor = null;\n\t  // eslint-disable-next-line es-x/no-object-getprototypeof -- required for testing\n\t  return Object.getPrototypeOf(new F()) !== F.prototype;\n\t});\n\n\tvar IE_PROTO$1 = sharedKey('IE_PROTO');\n\tvar Object$5 = global_1.Object;\n\tvar ObjectPrototype = Object$5.prototype;\n\n\t// `Object.getPrototypeOf` method\n\t// https://tc39.es/ecma262/#sec-object.getprototypeof\n\tvar objectGetPrototypeOf = correctPrototypeGetter ? Object$5.getPrototypeOf : function (O) {\n\t  var object = toObject(O);\n\t  if (hasOwnProperty_1(object, IE_PROTO$1)) return object[IE_PROTO$1];\n\t  var constructor = object.constructor;\n\t  if (isCallable(constructor) && object instanceof constructor) {\n\t    return constructor.prototype;\n\t  } return object instanceof Object$5 ? ObjectPrototype : null;\n\t};\n\n\tvar ITERATOR$1 = wellKnownSymbol('iterator');\n\tvar BUGGY_SAFARI_ITERATORS = false;\n\n\t// `%IteratorPrototype%` object\n\t// https://tc39.es/ecma262/#sec-%iteratorprototype%-object\n\tvar IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\n\t/* eslint-disable es-x/no-array-prototype-keys -- safe */\n\tif ([].keys) {\n\t  arrayIterator = [].keys();\n\t  // Safari 8 has buggy iterators w/o `next`\n\t  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;\n\t  else {\n\t    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));\n\t    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;\n\t  }\n\t}\n\n\tvar NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {\n\t  var test = {};\n\t  // FF44- legacy iterators case\n\t  return IteratorPrototype[ITERATOR$1].call(test) !== test;\n\t});\n\n\tif (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};\n\n\t// `%IteratorPrototype%[@@iterator]()` method\n\t// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator\n\tif (!isCallable(IteratorPrototype[ITERATOR$1])) {\n\t  defineBuiltIn(IteratorPrototype, ITERATOR$1, function () {\n\t    return this;\n\t  });\n\t}\n\n\tvar iteratorsCore = {\n\t  IteratorPrototype: IteratorPrototype,\n\t  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS\n\t};\n\n\tvar defineProperty$3 = objectDefineProperty.f;\n\n\n\n\tvar TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');\n\n\tvar setToStringTag = function (target, TAG, STATIC) {\n\t  if (target && !STATIC) target = target.prototype;\n\t  if (target && !hasOwnProperty_1(target, TO_STRING_TAG$2)) {\n\t    defineProperty$3(target, TO_STRING_TAG$2, { configurable: true, value: TAG });\n\t  }\n\t};\n\n\tvar IteratorPrototype$1 = iteratorsCore.IteratorPrototype;\n\n\n\n\n\n\tvar returnThis = function () { return this; };\n\n\tvar createIteratorConstructor = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {\n\t  var TO_STRING_TAG = NAME + ' Iterator';\n\t  IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });\n\t  setToStringTag(IteratorConstructor, TO_STRING_TAG, false);\n\t  iterators[TO_STRING_TAG] = returnThis;\n\t  return IteratorConstructor;\n\t};\n\n\tvar String$4 = global_1.String;\n\tvar TypeError$8 = global_1.TypeError;\n\n\tvar aPossiblePrototype = function (argument) {\n\t  if (typeof argument == 'object' || isCallable(argument)) return argument;\n\t  throw TypeError$8(\"Can't set \" + String$4(argument) + ' as a prototype');\n\t};\n\n\t/* eslint-disable no-proto -- safe */\n\n\n\n\n\t// `Object.setPrototypeOf` method\n\t// https://tc39.es/ecma262/#sec-object.setprototypeof\n\t// Works with __proto__ only. Old v8 can't work with null proto objects.\n\t// eslint-disable-next-line es-x/no-object-setprototypeof -- safe\n\tvar objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n\t  var CORRECT_SETTER = false;\n\t  var test = {};\n\t  var setter;\n\t  try {\n\t    // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\n\t    setter = functionUncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);\n\t    setter(test, []);\n\t    CORRECT_SETTER = test instanceof Array;\n\t  } catch (error) { /* empty */ }\n\t  return function setPrototypeOf(O, proto) {\n\t    anObject(O);\n\t    aPossiblePrototype(proto);\n\t    if (CORRECT_SETTER) setter(O, proto);\n\t    else O.__proto__ = proto;\n\t    return O;\n\t  };\n\t}() : undefined);\n\n\tvar PROPER_FUNCTION_NAME = functionName.PROPER;\n\tvar CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;\n\tvar IteratorPrototype$2 = iteratorsCore.IteratorPrototype;\n\tvar BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;\n\tvar ITERATOR$2 = wellKnownSymbol('iterator');\n\tvar KEYS = 'keys';\n\tvar VALUES = 'values';\n\tvar ENTRIES = 'entries';\n\n\tvar returnThis$1 = function () { return this; };\n\n\tvar defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n\t  createIteratorConstructor(IteratorConstructor, NAME, next);\n\n\t  var getIterationMethod = function (KIND) {\n\t    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n\t    if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];\n\t    switch (KIND) {\n\t      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\n\t      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\n\t      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\n\t    } return function () { return new IteratorConstructor(this); };\n\t  };\n\n\t  var TO_STRING_TAG = NAME + ' Iterator';\n\t  var INCORRECT_VALUES_NAME = false;\n\t  var IterablePrototype = Iterable.prototype;\n\t  var nativeIterator = IterablePrototype[ITERATOR$2]\n\t    || IterablePrototype['@@iterator']\n\t    || DEFAULT && IterablePrototype[DEFAULT];\n\t  var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);\n\t  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n\t  var CurrentIteratorPrototype, methods, KEY;\n\n\t  // fix native\n\t  if (anyNativeIterator) {\n\t    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));\n\t    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n\t      if ( objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype$2) {\n\t        if (objectSetPrototypeOf) {\n\t          objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype$2);\n\t        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR$2])) {\n\t          defineBuiltIn(CurrentIteratorPrototype, ITERATOR$2, returnThis$1);\n\t        }\n\t      }\n\t      // Set @@toStringTag to native iterators\n\t      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);\n\t    }\n\t  }\n\n\t  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF\n\t  if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n\t    if ( CONFIGURABLE_FUNCTION_NAME) {\n\t      createNonEnumerableProperty(IterablePrototype, 'name', VALUES);\n\t    } else {\n\t      INCORRECT_VALUES_NAME = true;\n\t      defaultIterator = function values() { return functionCall(nativeIterator, this); };\n\t    }\n\t  }\n\n\t  // export additional methods\n\t  if (DEFAULT) {\n\t    methods = {\n\t      values: getIterationMethod(VALUES),\n\t      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n\t      entries: getIterationMethod(ENTRIES)\n\t    };\n\t    if (FORCED) for (KEY in methods) {\n\t      if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n\t        defineBuiltIn(IterablePrototype, KEY, methods[KEY]);\n\t      }\n\t    } else _export({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME }, methods);\n\t  }\n\n\t  // define iterator\n\t  if ( IterablePrototype[ITERATOR$2] !== defaultIterator) {\n\t    defineBuiltIn(IterablePrototype, ITERATOR$2, defaultIterator, { name: DEFAULT });\n\t  }\n\t  iterators[NAME] = defaultIterator;\n\n\t  return methods;\n\t};\n\n\tvar defineProperty$4 = objectDefineProperty.f;\n\n\n\n\n\tvar ARRAY_ITERATOR = 'Array Iterator';\n\tvar setInternalState = internalState.set;\n\tvar getInternalState = internalState.getterFor(ARRAY_ITERATOR);\n\n\t// `Array.prototype.entries` method\n\t// https://tc39.es/ecma262/#sec-array.prototype.entries\n\t// `Array.prototype.keys` method\n\t// https://tc39.es/ecma262/#sec-array.prototype.keys\n\t// `Array.prototype.values` method\n\t// https://tc39.es/ecma262/#sec-array.prototype.values\n\t// `Array.prototype[@@iterator]` method\n\t// https://tc39.es/ecma262/#sec-array.prototype-@@iterator\n\t// `CreateArrayIterator` internal method\n\t// https://tc39.es/ecma262/#sec-createarrayiterator\n\tvar es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {\n\t  setInternalState(this, {\n\t    type: ARRAY_ITERATOR,\n\t    target: toIndexedObject(iterated), // target\n\t    index: 0,                          // next index\n\t    kind: kind                         // kind\n\t  });\n\t// `%ArrayIteratorPrototype%.next` method\n\t// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next\n\t}, function () {\n\t  var state = getInternalState(this);\n\t  var target = state.target;\n\t  var kind = state.kind;\n\t  var index = state.index++;\n\t  if (!target || index >= target.length) {\n\t    state.target = undefined;\n\t    return { value: undefined, done: true };\n\t  }\n\t  if (kind == 'keys') return { value: index, done: false };\n\t  if (kind == 'values') return { value: target[index], done: false };\n\t  return { value: [index, target[index]], done: false };\n\t}, 'values');\n\n\t// argumentsList[@@iterator] is %ArrayProto_values%\n\t// https://tc39.es/ecma262/#sec-createunmappedargumentsobject\n\t// https://tc39.es/ecma262/#sec-createmappedargumentsobject\n\tvar values = iterators.Arguments = iterators.Array;\n\n\t// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\n\taddToUnscopables('keys');\n\taddToUnscopables('values');\n\taddToUnscopables('entries');\n\n\t// V8 ~ Chrome 45- bug\n\tif ( descriptors && values.name !== 'values') try {\n\t  defineProperty$4(values, 'name', { value: 'values' });\n\t} catch (error) { /* empty */ }\n\n\tvar charAt = functionUncurryThis(''.charAt);\n\tvar charCodeAt = functionUncurryThis(''.charCodeAt);\n\tvar stringSlice$1 = functionUncurryThis(''.slice);\n\n\tvar createMethod$3 = function (CONVERT_TO_STRING) {\n\t  return function ($this, pos) {\n\t    var S = toString_1(requireObjectCoercible($this));\n\t    var position = toIntegerOrInfinity(pos);\n\t    var size = S.length;\n\t    var first, second;\n\t    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;\n\t    first = charCodeAt(S, position);\n\t    return first < 0xD800 || first > 0xDBFF || position + 1 === size\n\t      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF\n\t        ? CONVERT_TO_STRING\n\t          ? charAt(S, position)\n\t          : first\n\t        : CONVERT_TO_STRING\n\t          ? stringSlice$1(S, position, position + 2)\n\t          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n\t  };\n\t};\n\n\tvar stringMultibyte = {\n\t  // `String.prototype.codePointAt` method\n\t  // https://tc39.es/ecma262/#sec-string.prototype.codepointat\n\t  codeAt: createMethod$3(false),\n\t  // `String.prototype.at` method\n\t  // https://github.com/mathiasbynens/String.prototype.at\n\t  charAt: createMethod$3(true)\n\t};\n\n\tvar charAt$1 = stringMultibyte.charAt;\n\n\n\n\n\tvar STRING_ITERATOR = 'String Iterator';\n\tvar setInternalState$1 = internalState.set;\n\tvar getInternalState$1 = internalState.getterFor(STRING_ITERATOR);\n\n\t// `String.prototype[@@iterator]` method\n\t// https://tc39.es/ecma262/#sec-string.prototype-@@iterator\n\tdefineIterator(String, 'String', function (iterated) {\n\t  setInternalState$1(this, {\n\t    type: STRING_ITERATOR,\n\t    string: toString_1(iterated),\n\t    index: 0\n\t  });\n\t// `%StringIteratorPrototype%.next` method\n\t// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next\n\t}, function next() {\n\t  var state = getInternalState$1(this);\n\t  var string = state.string;\n\t  var index = state.index;\n\t  var point;\n\t  if (index >= string.length) return { value: undefined, done: true };\n\t  point = charAt$1(string, index);\n\t  state.index += point.length;\n\t  return { value: point, done: false };\n\t});\n\n\tvar defineBuiltIns = function (target, src, options) {\n\t  for (var key in src) defineBuiltIn(target, key, src[key], options);\n\t  return target;\n\t};\n\n\tvar createProperty = function (object, key, value) {\n\t  var propertyKey = toPropertyKey(key);\n\t  if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));\n\t  else object[propertyKey] = value;\n\t};\n\n\tvar Array$2 = global_1.Array;\n\tvar max$1 = Math.max;\n\n\tvar arraySliceSimple = function (O, start, end) {\n\t  var length = lengthOfArrayLike(O);\n\t  var k = toAbsoluteIndex(start, length);\n\t  var fin = toAbsoluteIndex(end === undefined ? length : end, length);\n\t  var result = Array$2(max$1(fin - k, 0));\n\t  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);\n\t  result.length = n;\n\t  return result;\n\t};\n\n\t/* eslint-disable es-x/no-object-getownpropertynames -- safe */\n\n\n\tvar $getOwnPropertyNames = objectGetOwnPropertyNames.f;\n\n\n\tvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n\t  ? Object.getOwnPropertyNames(window) : [];\n\n\tvar getWindowNames = function (it) {\n\t  try {\n\t    return $getOwnPropertyNames(it);\n\t  } catch (error) {\n\t    return arraySliceSimple(windowNames);\n\t  }\n\t};\n\n\t// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\n\tvar f$6 = function getOwnPropertyNames(it) {\n\t  return windowNames && classofRaw(it) == 'Window'\n\t    ? getWindowNames(it)\n\t    : $getOwnPropertyNames(toIndexedObject(it));\n\t};\n\n\tvar objectGetOwnPropertyNamesExternal = {\n\t\tf: f$6\n\t};\n\n\t// FF26- bug: ArrayBuffers are non-extensible, but Object.isExtensible does not report it\n\n\n\tvar arrayBufferNonExtensible = fails(function () {\n\t  if (typeof ArrayBuffer == 'function') {\n\t    var buffer = new ArrayBuffer(8);\n\t    // eslint-disable-next-line es-x/no-object-isextensible, es-x/no-object-defineproperty -- safe\n\t    if (Object.isExtensible(buffer)) Object.defineProperty(buffer, 'a', { value: 8 });\n\t  }\n\t});\n\n\t// eslint-disable-next-line es-x/no-object-isextensible -- safe\n\tvar $isExtensible = Object.isExtensible;\n\tvar FAILS_ON_PRIMITIVES = fails(function () { $isExtensible(1); });\n\n\t// `Object.isExtensible` method\n\t// https://tc39.es/ecma262/#sec-object.isextensible\n\tvar objectIsExtensible = (FAILS_ON_PRIMITIVES || arrayBufferNonExtensible) ? function isExtensible(it) {\n\t  if (!isObject(it)) return false;\n\t  if (arrayBufferNonExtensible && classofRaw(it) == 'ArrayBuffer') return false;\n\t  return $isExtensible ? $isExtensible(it) : true;\n\t} : $isExtensible;\n\n\tvar freezing = !fails(function () {\n\t  // eslint-disable-next-line es-x/no-object-isextensible, es-x/no-object-preventextensions -- required for testing\n\t  return Object.isExtensible(Object.preventExtensions({}));\n\t});\n\n\tvar internalMetadata = createCommonjsModule(function (module) {\n\tvar defineProperty = objectDefineProperty.f;\n\n\n\n\n\n\n\tvar REQUIRED = false;\n\tvar METADATA = uid('meta');\n\tvar id = 0;\n\n\tvar setMetadata = function (it) {\n\t  defineProperty(it, METADATA, { value: {\n\t    objectID: 'O' + id++, // object ID\n\t    weakData: {}          // weak collections IDs\n\t  } });\n\t};\n\n\tvar fastKey = function (it, create) {\n\t  // return a primitive with prefix\n\t  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n\t  if (!hasOwnProperty_1(it, METADATA)) {\n\t    // can't set metadata to uncaught frozen object\n\t    if (!objectIsExtensible(it)) return 'F';\n\t    // not necessary to add metadata\n\t    if (!create) return 'E';\n\t    // add missing metadata\n\t    setMetadata(it);\n\t  // return object ID\n\t  } return it[METADATA].objectID;\n\t};\n\n\tvar getWeakData = function (it, create) {\n\t  if (!hasOwnProperty_1(it, METADATA)) {\n\t    // can't set metadata to uncaught frozen object\n\t    if (!objectIsExtensible(it)) return true;\n\t    // not necessary to add metadata\n\t    if (!create) return false;\n\t    // add missing metadata\n\t    setMetadata(it);\n\t  // return the store of weak collections IDs\n\t  } return it[METADATA].weakData;\n\t};\n\n\t// add metadata on freeze-family methods calling\n\tvar onFreeze = function (it) {\n\t  if (freezing && REQUIRED && objectIsExtensible(it) && !hasOwnProperty_1(it, METADATA)) setMetadata(it);\n\t  return it;\n\t};\n\n\tvar enable = function () {\n\t  meta.enable = function () { /* empty */ };\n\t  REQUIRED = true;\n\t  var getOwnPropertyNames = objectGetOwnPropertyNames.f;\n\t  var splice = functionUncurryThis([].splice);\n\t  var test = {};\n\t  test[METADATA] = 1;\n\n\t  // prevent exposing of metadata key\n\t  if (getOwnPropertyNames(test).length) {\n\t    objectGetOwnPropertyNames.f = function (it) {\n\t      var result = getOwnPropertyNames(it);\n\t      for (var i = 0, length = result.length; i < length; i++) {\n\t        if (result[i] === METADATA) {\n\t          splice(result, i, 1);\n\t          break;\n\t        }\n\t      } return result;\n\t    };\n\n\t    _export({ target: 'Object', stat: true, forced: true }, {\n\t      getOwnPropertyNames: objectGetOwnPropertyNamesExternal.f\n\t    });\n\t  }\n\t};\n\n\tvar meta = module.exports = {\n\t  enable: enable,\n\t  fastKey: fastKey,\n\t  getWeakData: getWeakData,\n\t  onFreeze: onFreeze\n\t};\n\n\thiddenKeys[METADATA] = true;\n\t});\n\tvar internalMetadata_1 = internalMetadata.enable;\n\tvar internalMetadata_2 = internalMetadata.fastKey;\n\tvar internalMetadata_3 = internalMetadata.getWeakData;\n\tvar internalMetadata_4 = internalMetadata.onFreeze;\n\n\tvar ITERATOR$3 = wellKnownSymbol('iterator');\n\tvar ArrayPrototype$1 = Array.prototype;\n\n\t// check on default Array iterator\n\tvar isArrayIteratorMethod = function (it) {\n\t  return it !== undefined && (iterators.Array === it || ArrayPrototype$1[ITERATOR$3] === it);\n\t};\n\n\tvar ITERATOR$4 = wellKnownSymbol('iterator');\n\n\tvar getIteratorMethod = function (it) {\n\t  if (it != undefined) return getMethod(it, ITERATOR$4)\n\t    || getMethod(it, '@@iterator')\n\t    || iterators[classof(it)];\n\t};\n\n\tvar TypeError$9 = global_1.TypeError;\n\n\tvar getIterator = function (argument, usingIterator) {\n\t  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;\n\t  if (aCallable(iteratorMethod)) return anObject(functionCall(iteratorMethod, argument));\n\t  throw TypeError$9(tryToString(argument) + ' is not iterable');\n\t};\n\n\tvar iteratorClose = function (iterator, kind, value) {\n\t  var innerResult, innerError;\n\t  anObject(iterator);\n\t  try {\n\t    innerResult = getMethod(iterator, 'return');\n\t    if (!innerResult) {\n\t      if (kind === 'throw') throw value;\n\t      return value;\n\t    }\n\t    innerResult = functionCall(innerResult, iterator);\n\t  } catch (error) {\n\t    innerError = true;\n\t    innerResult = error;\n\t  }\n\t  if (kind === 'throw') throw value;\n\t  if (innerError) throw innerResult;\n\t  anObject(innerResult);\n\t  return value;\n\t};\n\n\tvar TypeError$a = global_1.TypeError;\n\n\tvar Result = function (stopped, result) {\n\t  this.stopped = stopped;\n\t  this.result = result;\n\t};\n\n\tvar ResultPrototype = Result.prototype;\n\n\tvar iterate = function (iterable, unboundFunction, options) {\n\t  var that = options && options.that;\n\t  var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n\t  var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n\t  var INTERRUPTED = !!(options && options.INTERRUPTED);\n\t  var fn = functionBindContext(unboundFunction, that);\n\t  var iterator, iterFn, index, length, result, next, step;\n\n\t  var stop = function (condition) {\n\t    if (iterator) iteratorClose(iterator, 'normal', condition);\n\t    return new Result(true, condition);\n\t  };\n\n\t  var callFn = function (value) {\n\t    if (AS_ENTRIES) {\n\t      anObject(value);\n\t      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n\t    } return INTERRUPTED ? fn(value, stop) : fn(value);\n\t  };\n\n\t  if (IS_ITERATOR) {\n\t    iterator = iterable;\n\t  } else {\n\t    iterFn = getIteratorMethod(iterable);\n\t    if (!iterFn) throw TypeError$a(tryToString(iterable) + ' is not iterable');\n\t    // optimisation for array iterators\n\t    if (isArrayIteratorMethod(iterFn)) {\n\t      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {\n\t        result = callFn(iterable[index]);\n\t        if (result && objectIsPrototypeOf(ResultPrototype, result)) return result;\n\t      } return new Result(false);\n\t    }\n\t    iterator = getIterator(iterable, iterFn);\n\t  }\n\n\t  next = iterator.next;\n\t  while (!(step = functionCall(next, iterator)).done) {\n\t    try {\n\t      result = callFn(step.value);\n\t    } catch (error) {\n\t      iteratorClose(iterator, 'throw', error);\n\t    }\n\t    if (typeof result == 'object' && result && objectIsPrototypeOf(ResultPrototype, result)) return result;\n\t  } return new Result(false);\n\t};\n\n\tvar TypeError$b = global_1.TypeError;\n\n\tvar anInstance = function (it, Prototype) {\n\t  if (objectIsPrototypeOf(Prototype, it)) return it;\n\t  throw TypeError$b('Incorrect invocation');\n\t};\n\n\tvar ITERATOR$5 = wellKnownSymbol('iterator');\n\tvar SAFE_CLOSING = false;\n\n\ttry {\n\t  var called = 0;\n\t  var iteratorWithReturn = {\n\t    next: function () {\n\t      return { done: !!called++ };\n\t    },\n\t    'return': function () {\n\t      SAFE_CLOSING = true;\n\t    }\n\t  };\n\t  iteratorWithReturn[ITERATOR$5] = function () {\n\t    return this;\n\t  };\n\t  // eslint-disable-next-line es-x/no-array-from, no-throw-literal -- required for testing\n\t  Array.from(iteratorWithReturn, function () { throw 2; });\n\t} catch (error) { /* empty */ }\n\n\tvar checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {\n\t  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n\t  var ITERATION_SUPPORT = false;\n\t  try {\n\t    var object = {};\n\t    object[ITERATOR$5] = function () {\n\t      return {\n\t        next: function () {\n\t          return { done: ITERATION_SUPPORT = true };\n\t        }\n\t      };\n\t    };\n\t    exec(object);\n\t  } catch (error) { /* empty */ }\n\t  return ITERATION_SUPPORT;\n\t};\n\n\t// makes subclassing work correct for wrapped built-ins\n\tvar inheritIfRequired = function ($this, dummy, Wrapper) {\n\t  var NewTarget, NewTargetPrototype;\n\t  if (\n\t    // it can work only with native `setPrototypeOf`\n\t    objectSetPrototypeOf &&\n\t    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this\n\t    isCallable(NewTarget = dummy.constructor) &&\n\t    NewTarget !== Wrapper &&\n\t    isObject(NewTargetPrototype = NewTarget.prototype) &&\n\t    NewTargetPrototype !== Wrapper.prototype\n\t  ) objectSetPrototypeOf($this, NewTargetPrototype);\n\t  return $this;\n\t};\n\n\tvar collection = function (CONSTRUCTOR_NAME, wrapper, common) {\n\t  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;\n\t  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;\n\t  var ADDER = IS_MAP ? 'set' : 'add';\n\t  var NativeConstructor = global_1[CONSTRUCTOR_NAME];\n\t  var NativePrototype = NativeConstructor && NativeConstructor.prototype;\n\t  var Constructor = NativeConstructor;\n\t  var exported = {};\n\n\t  var fixMethod = function (KEY) {\n\t    var uncurriedNativeMethod = functionUncurryThis(NativePrototype[KEY]);\n\t    defineBuiltIn(NativePrototype, KEY,\n\t      KEY == 'add' ? function add(value) {\n\t        uncurriedNativeMethod(this, value === 0 ? 0 : value);\n\t        return this;\n\t      } : KEY == 'delete' ? function (key) {\n\t        return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);\n\t      } : KEY == 'get' ? function get(key) {\n\t        return IS_WEAK && !isObject(key) ? undefined : uncurriedNativeMethod(this, key === 0 ? 0 : key);\n\t      } : KEY == 'has' ? function has(key) {\n\t        return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);\n\t      } : function set(key, value) {\n\t        uncurriedNativeMethod(this, key === 0 ? 0 : key, value);\n\t        return this;\n\t      }\n\t    );\n\t  };\n\n\t  var REPLACE = isForced_1(\n\t    CONSTRUCTOR_NAME,\n\t    !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function () {\n\t      new NativeConstructor().entries().next();\n\t    }))\n\t  );\n\n\t  if (REPLACE) {\n\t    // create collection constructor\n\t    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);\n\t    internalMetadata.enable();\n\t  } else if (isForced_1(CONSTRUCTOR_NAME, true)) {\n\t    var instance = new Constructor();\n\t    // early implementations not supports chaining\n\t    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;\n\t    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false\n\t    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });\n\t    // most early implementations doesn't supports iterables, most modern - not close it correctly\n\t    // eslint-disable-next-line no-new -- required for testing\n\t    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });\n\t    // for early implementations -0 and +0 not the same\n\t    var BUGGY_ZERO = !IS_WEAK && fails(function () {\n\t      // V8 ~ Chromium 42- fails only with 5+ elements\n\t      var $instance = new NativeConstructor();\n\t      var index = 5;\n\t      while (index--) $instance[ADDER](index, index);\n\t      return !$instance.has(-0);\n\t    });\n\n\t    if (!ACCEPT_ITERABLES) {\n\t      Constructor = wrapper(function (dummy, iterable) {\n\t        anInstance(dummy, NativePrototype);\n\t        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);\n\t        if (iterable != undefined) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });\n\t        return that;\n\t      });\n\t      Constructor.prototype = NativePrototype;\n\t      NativePrototype.constructor = Constructor;\n\t    }\n\n\t    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {\n\t      fixMethod('delete');\n\t      fixMethod('has');\n\t      IS_MAP && fixMethod('get');\n\t    }\n\n\t    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);\n\n\t    // weak collections should not contains .clear method\n\t    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;\n\t  }\n\n\t  exported[CONSTRUCTOR_NAME] = Constructor;\n\t  _export({ global: true, constructor: true, forced: Constructor != NativeConstructor }, exported);\n\n\t  setToStringTag(Constructor, CONSTRUCTOR_NAME);\n\n\t  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);\n\n\t  return Constructor;\n\t};\n\n\tvar getWeakData = internalMetadata.getWeakData;\n\n\n\n\n\n\n\n\n\tvar setInternalState$2 = internalState.set;\n\tvar internalStateGetterFor = internalState.getterFor;\n\tvar find = arrayIteration.find;\n\tvar findIndex = arrayIteration.findIndex;\n\tvar splice = functionUncurryThis([].splice);\n\tvar id$1 = 0;\n\n\t// fallback for uncaught frozen keys\n\tvar uncaughtFrozenStore = function (store) {\n\t  return store.frozen || (store.frozen = new UncaughtFrozenStore());\n\t};\n\n\tvar UncaughtFrozenStore = function () {\n\t  this.entries = [];\n\t};\n\n\tvar findUncaughtFrozen = function (store, key) {\n\t  return find(store.entries, function (it) {\n\t    return it[0] === key;\n\t  });\n\t};\n\n\tUncaughtFrozenStore.prototype = {\n\t  get: function (key) {\n\t    var entry = findUncaughtFrozen(this, key);\n\t    if (entry) return entry[1];\n\t  },\n\t  has: function (key) {\n\t    return !!findUncaughtFrozen(this, key);\n\t  },\n\t  set: function (key, value) {\n\t    var entry = findUncaughtFrozen(this, key);\n\t    if (entry) entry[1] = value;\n\t    else this.entries.push([key, value]);\n\t  },\n\t  'delete': function (key) {\n\t    var index = findIndex(this.entries, function (it) {\n\t      return it[0] === key;\n\t    });\n\t    if (~index) splice(this.entries, index, 1);\n\t    return !!~index;\n\t  }\n\t};\n\n\tvar collectionWeak = {\n\t  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {\n\t    var Constructor = wrapper(function (that, iterable) {\n\t      anInstance(that, Prototype);\n\t      setInternalState$2(that, {\n\t        type: CONSTRUCTOR_NAME,\n\t        id: id$1++,\n\t        frozen: undefined\n\t      });\n\t      if (iterable != undefined) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });\n\t    });\n\n\t    var Prototype = Constructor.prototype;\n\n\t    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);\n\n\t    var define = function (that, key, value) {\n\t      var state = getInternalState(that);\n\t      var data = getWeakData(anObject(key), true);\n\t      if (data === true) uncaughtFrozenStore(state).set(key, value);\n\t      else data[state.id] = value;\n\t      return that;\n\t    };\n\n\t    defineBuiltIns(Prototype, {\n\t      // `{ WeakMap, WeakSet }.prototype.delete(key)` methods\n\t      // https://tc39.es/ecma262/#sec-weakmap.prototype.delete\n\t      // https://tc39.es/ecma262/#sec-weakset.prototype.delete\n\t      'delete': function (key) {\n\t        var state = getInternalState(this);\n\t        if (!isObject(key)) return false;\n\t        var data = getWeakData(key);\n\t        if (data === true) return uncaughtFrozenStore(state)['delete'](key);\n\t        return data && hasOwnProperty_1(data, state.id) && delete data[state.id];\n\t      },\n\t      // `{ WeakMap, WeakSet }.prototype.has(key)` methods\n\t      // https://tc39.es/ecma262/#sec-weakmap.prototype.has\n\t      // https://tc39.es/ecma262/#sec-weakset.prototype.has\n\t      has: function has(key) {\n\t        var state = getInternalState(this);\n\t        if (!isObject(key)) return false;\n\t        var data = getWeakData(key);\n\t        if (data === true) return uncaughtFrozenStore(state).has(key);\n\t        return data && hasOwnProperty_1(data, state.id);\n\t      }\n\t    });\n\n\t    defineBuiltIns(Prototype, IS_MAP ? {\n\t      // `WeakMap.prototype.get(key)` method\n\t      // https://tc39.es/ecma262/#sec-weakmap.prototype.get\n\t      get: function get(key) {\n\t        var state = getInternalState(this);\n\t        if (isObject(key)) {\n\t          var data = getWeakData(key);\n\t          if (data === true) return uncaughtFrozenStore(state).get(key);\n\t          return data ? data[state.id] : undefined;\n\t        }\n\t      },\n\t      // `WeakMap.prototype.set(key, value)` method\n\t      // https://tc39.es/ecma262/#sec-weakmap.prototype.set\n\t      set: function set(key, value) {\n\t        return define(this, key, value);\n\t      }\n\t    } : {\n\t      // `WeakSet.prototype.add(value)` method\n\t      // https://tc39.es/ecma262/#sec-weakset.prototype.add\n\t      add: function add(value) {\n\t        return define(this, value, true);\n\t      }\n\t    });\n\n\t    return Constructor;\n\t  }\n\t};\n\n\tvar enforceInternalState = internalState.enforce;\n\n\n\tvar IS_IE11 = !global_1.ActiveXObject && 'ActiveXObject' in global_1;\n\tvar InternalWeakMap;\n\n\tvar wrapper = function (init) {\n\t  return function WeakMap() {\n\t    return init(this, arguments.length ? arguments[0] : undefined);\n\t  };\n\t};\n\n\t// `WeakMap` constructor\n\t// https://tc39.es/ecma262/#sec-weakmap-constructor\n\tvar $WeakMap = collection('WeakMap', wrapper, collectionWeak);\n\n\t// IE11 WeakMap frozen keys fix\n\t// We can't use feature detection because it crash some old IE builds\n\t// https://github.com/zloirock/core-js/issues/485\n\tif (nativeWeakMap && IS_IE11) {\n\t  InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);\n\t  internalMetadata.enable();\n\t  var WeakMapPrototype = $WeakMap.prototype;\n\t  var nativeDelete = functionUncurryThis(WeakMapPrototype['delete']);\n\t  var nativeHas = functionUncurryThis(WeakMapPrototype.has);\n\t  var nativeGet = functionUncurryThis(WeakMapPrototype.get);\n\t  var nativeSet = functionUncurryThis(WeakMapPrototype.set);\n\t  defineBuiltIns(WeakMapPrototype, {\n\t    'delete': function (key) {\n\t      if (isObject(key) && !objectIsExtensible(key)) {\n\t        var state = enforceInternalState(this);\n\t        if (!state.frozen) state.frozen = new InternalWeakMap();\n\t        return nativeDelete(this, key) || state.frozen['delete'](key);\n\t      } return nativeDelete(this, key);\n\t    },\n\t    has: function has(key) {\n\t      if (isObject(key) && !objectIsExtensible(key)) {\n\t        var state = enforceInternalState(this);\n\t        if (!state.frozen) state.frozen = new InternalWeakMap();\n\t        return nativeHas(this, key) || state.frozen.has(key);\n\t      } return nativeHas(this, key);\n\t    },\n\t    get: function get(key) {\n\t      if (isObject(key) && !objectIsExtensible(key)) {\n\t        var state = enforceInternalState(this);\n\t        if (!state.frozen) state.frozen = new InternalWeakMap();\n\t        return nativeHas(this, key) ? nativeGet(this, key) : state.frozen.get(key);\n\t      } return nativeGet(this, key);\n\t    },\n\t    set: function set(key, value) {\n\t      if (isObject(key) && !objectIsExtensible(key)) {\n\t        var state = enforceInternalState(this);\n\t        if (!state.frozen) state.frozen = new InternalWeakMap();\n\t        nativeHas(this, key) ? nativeSet(this, key, value) : state.frozen.set(key, value);\n\t      } else nativeSet(this, key, value);\n\t      return this;\n\t    }\n\t  });\n\t}\n\n\tvar ITERATOR$6 = wellKnownSymbol('iterator');\n\tvar TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');\n\tvar ArrayValues = es_array_iterator.values;\n\n\tvar handlePrototype$1 = function (CollectionPrototype, COLLECTION_NAME) {\n\t  if (CollectionPrototype) {\n\t    // some Chrome versions have non-configurable methods on DOMTokenList\n\t    if (CollectionPrototype[ITERATOR$6] !== ArrayValues) try {\n\t      createNonEnumerableProperty(CollectionPrototype, ITERATOR$6, ArrayValues);\n\t    } catch (error) {\n\t      CollectionPrototype[ITERATOR$6] = ArrayValues;\n\t    }\n\t    if (!CollectionPrototype[TO_STRING_TAG$3]) {\n\t      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG$3, COLLECTION_NAME);\n\t    }\n\t    if (domIterables[COLLECTION_NAME]) for (var METHOD_NAME in es_array_iterator) {\n\t      // some Chrome versions have non-configurable methods on DOMTokenList\n\t      if (CollectionPrototype[METHOD_NAME] !== es_array_iterator[METHOD_NAME]) try {\n\t        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, es_array_iterator[METHOD_NAME]);\n\t      } catch (error) {\n\t        CollectionPrototype[METHOD_NAME] = es_array_iterator[METHOD_NAME];\n\t      }\n\t    }\n\t  }\n\t};\n\n\tfor (var COLLECTION_NAME$1 in domIterables) {\n\t  handlePrototype$1(global_1[COLLECTION_NAME$1] && global_1[COLLECTION_NAME$1].prototype, COLLECTION_NAME$1);\n\t}\n\n\thandlePrototype$1(domTokenListPrototype, 'DOMTokenList');\n\n\t/**\n\t * lodash (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modularize exports=\"npm\" -o ./`\n\t * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n\t * Released under MIT license <https://lodash.com/license>\n\t * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n\t * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t */\n\n\t/** Used as the `TypeError` message for \"Functions\" methods. */\n\tvar FUNC_ERROR_TEXT = 'Expected a function';\n\n\t/** Used as references for various `Number` constants. */\n\tvar NAN = 0 / 0;\n\n\t/** `Object#toString` result references. */\n\tvar symbolTag = '[object Symbol]';\n\n\t/** Used to match leading and trailing whitespace. */\n\tvar reTrim = /^\\s+|\\s+$/g;\n\n\t/** Used to detect bad signed hexadecimal string values. */\n\tvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n\t/** Used to detect binary string values. */\n\tvar reIsBinary = /^0b[01]+$/i;\n\n\t/** Used to detect octal string values. */\n\tvar reIsOctal = /^0o[0-7]+$/i;\n\n\t/** Built-in method references without a dependency on `root`. */\n\tvar freeParseInt = parseInt;\n\n\t/** Detect free variable `global` from Node.js. */\n\tvar freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n\n\t/** Detect free variable `self`. */\n\tvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n\t/** Used as a reference to the global object. */\n\tvar root = freeGlobal || freeSelf || Function('return this')();\n\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\n\t/**\n\t * Used to resolve the\n\t * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n\t * of values.\n\t */\n\tvar objectToString$1 = objectProto.toString;\n\n\t/* Built-in method references for those with the same name as other `lodash` methods. */\n\tvar nativeMax = Math.max,\n\t    nativeMin = Math.min;\n\n\t/**\n\t * Gets the timestamp of the number of milliseconds that have elapsed since\n\t * the Unix epoch (1 January 1970 00:00:00 UTC).\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 2.4.0\n\t * @category Date\n\t * @returns {number} Returns the timestamp.\n\t * @example\n\t *\n\t * _.defer(function(stamp) {\n\t *   console.log(_.now() - stamp);\n\t * }, _.now());\n\t * // => Logs the number of milliseconds it took for the deferred invocation.\n\t */\n\tvar now = function() {\n\t  return root.Date.now();\n\t};\n\n\t/**\n\t * Creates a debounced function that delays invoking `func` until after `wait`\n\t * milliseconds have elapsed since the last time the debounced function was\n\t * invoked. The debounced function comes with a `cancel` method to cancel\n\t * delayed `func` invocations and a `flush` method to immediately invoke them.\n\t * Provide `options` to indicate whether `func` should be invoked on the\n\t * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n\t * with the last arguments provided to the debounced function. Subsequent\n\t * calls to the debounced function return the result of the last `func`\n\t * invocation.\n\t *\n\t * **Note:** If `leading` and `trailing` options are `true`, `func` is\n\t * invoked on the trailing edge of the timeout only if the debounced function\n\t * is invoked more than once during the `wait` timeout.\n\t *\n\t * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n\t * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n\t *\n\t * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n\t * for details over the differences between `_.debounce` and `_.throttle`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Function\n\t * @param {Function} func The function to debounce.\n\t * @param {number} [wait=0] The number of milliseconds to delay.\n\t * @param {Object} [options={}] The options object.\n\t * @param {boolean} [options.leading=false]\n\t *  Specify invoking on the leading edge of the timeout.\n\t * @param {number} [options.maxWait]\n\t *  The maximum time `func` is allowed to be delayed before it's invoked.\n\t * @param {boolean} [options.trailing=true]\n\t *  Specify invoking on the trailing edge of the timeout.\n\t * @returns {Function} Returns the new debounced function.\n\t * @example\n\t *\n\t * // Avoid costly calculations while the window size is in flux.\n\t * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n\t *\n\t * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n\t * jQuery(element).on('click', _.debounce(sendMail, 300, {\n\t *   'leading': true,\n\t *   'trailing': false\n\t * }));\n\t *\n\t * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n\t * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n\t * var source = new EventSource('/stream');\n\t * jQuery(source).on('message', debounced);\n\t *\n\t * // Cancel the trailing debounced invocation.\n\t * jQuery(window).on('popstate', debounced.cancel);\n\t */\n\tfunction debounce(func, wait, options) {\n\t  var lastArgs,\n\t      lastThis,\n\t      maxWait,\n\t      result,\n\t      timerId,\n\t      lastCallTime,\n\t      lastInvokeTime = 0,\n\t      leading = false,\n\t      maxing = false,\n\t      trailing = true;\n\n\t  if (typeof func != 'function') {\n\t    throw new TypeError(FUNC_ERROR_TEXT);\n\t  }\n\t  wait = toNumber(wait) || 0;\n\t  if (isObject$1(options)) {\n\t    leading = !!options.leading;\n\t    maxing = 'maxWait' in options;\n\t    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n\t    trailing = 'trailing' in options ? !!options.trailing : trailing;\n\t  }\n\n\t  function invokeFunc(time) {\n\t    var args = lastArgs,\n\t        thisArg = lastThis;\n\n\t    lastArgs = lastThis = undefined;\n\t    lastInvokeTime = time;\n\t    result = func.apply(thisArg, args);\n\t    return result;\n\t  }\n\n\t  function leadingEdge(time) {\n\t    // Reset any `maxWait` timer.\n\t    lastInvokeTime = time;\n\t    // Start the timer for the trailing edge.\n\t    timerId = setTimeout(timerExpired, wait);\n\t    // Invoke the leading edge.\n\t    return leading ? invokeFunc(time) : result;\n\t  }\n\n\t  function remainingWait(time) {\n\t    var timeSinceLastCall = time - lastCallTime,\n\t        timeSinceLastInvoke = time - lastInvokeTime,\n\t        result = wait - timeSinceLastCall;\n\n\t    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n\t  }\n\n\t  function shouldInvoke(time) {\n\t    var timeSinceLastCall = time - lastCallTime,\n\t        timeSinceLastInvoke = time - lastInvokeTime;\n\n\t    // Either this is the first call, activity has stopped and we're at the\n\t    // trailing edge, the system time has gone backwards and we're treating\n\t    // it as the trailing edge, or we've hit the `maxWait` limit.\n\t    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n\t      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n\t  }\n\n\t  function timerExpired() {\n\t    var time = now();\n\t    if (shouldInvoke(time)) {\n\t      return trailingEdge(time);\n\t    }\n\t    // Restart the timer.\n\t    timerId = setTimeout(timerExpired, remainingWait(time));\n\t  }\n\n\t  function trailingEdge(time) {\n\t    timerId = undefined;\n\n\t    // Only invoke if we have `lastArgs` which means `func` has been\n\t    // debounced at least once.\n\t    if (trailing && lastArgs) {\n\t      return invokeFunc(time);\n\t    }\n\t    lastArgs = lastThis = undefined;\n\t    return result;\n\t  }\n\n\t  function cancel() {\n\t    if (timerId !== undefined) {\n\t      clearTimeout(timerId);\n\t    }\n\t    lastInvokeTime = 0;\n\t    lastArgs = lastCallTime = lastThis = timerId = undefined;\n\t  }\n\n\t  function flush() {\n\t    return timerId === undefined ? result : trailingEdge(now());\n\t  }\n\n\t  function debounced() {\n\t    var time = now(),\n\t        isInvoking = shouldInvoke(time);\n\n\t    lastArgs = arguments;\n\t    lastThis = this;\n\t    lastCallTime = time;\n\n\t    if (isInvoking) {\n\t      if (timerId === undefined) {\n\t        return leadingEdge(lastCallTime);\n\t      }\n\t      if (maxing) {\n\t        // Handle invocations in a tight loop.\n\t        timerId = setTimeout(timerExpired, wait);\n\t        return invokeFunc(lastCallTime);\n\t      }\n\t    }\n\t    if (timerId === undefined) {\n\t      timerId = setTimeout(timerExpired, wait);\n\t    }\n\t    return result;\n\t  }\n\t  debounced.cancel = cancel;\n\t  debounced.flush = flush;\n\t  return debounced;\n\t}\n\n\t/**\n\t * Creates a throttled function that only invokes `func` at most once per\n\t * every `wait` milliseconds. The throttled function comes with a `cancel`\n\t * method to cancel delayed `func` invocations and a `flush` method to\n\t * immediately invoke them. Provide `options` to indicate whether `func`\n\t * should be invoked on the leading and/or trailing edge of the `wait`\n\t * timeout. The `func` is invoked with the last arguments provided to the\n\t * throttled function. Subsequent calls to the throttled function return the\n\t * result of the last `func` invocation.\n\t *\n\t * **Note:** If `leading` and `trailing` options are `true`, `func` is\n\t * invoked on the trailing edge of the timeout only if the throttled function\n\t * is invoked more than once during the `wait` timeout.\n\t *\n\t * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n\t * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n\t *\n\t * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n\t * for details over the differences between `_.throttle` and `_.debounce`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Function\n\t * @param {Function} func The function to throttle.\n\t * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n\t * @param {Object} [options={}] The options object.\n\t * @param {boolean} [options.leading=true]\n\t *  Specify invoking on the leading edge of the timeout.\n\t * @param {boolean} [options.trailing=true]\n\t *  Specify invoking on the trailing edge of the timeout.\n\t * @returns {Function} Returns the new throttled function.\n\t * @example\n\t *\n\t * // Avoid excessively updating the position while scrolling.\n\t * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n\t *\n\t * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n\t * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n\t * jQuery(element).on('click', throttled);\n\t *\n\t * // Cancel the trailing throttled invocation.\n\t * jQuery(window).on('popstate', throttled.cancel);\n\t */\n\tfunction throttle(func, wait, options) {\n\t  var leading = true,\n\t      trailing = true;\n\n\t  if (typeof func != 'function') {\n\t    throw new TypeError(FUNC_ERROR_TEXT);\n\t  }\n\t  if (isObject$1(options)) {\n\t    leading = 'leading' in options ? !!options.leading : leading;\n\t    trailing = 'trailing' in options ? !!options.trailing : trailing;\n\t  }\n\t  return debounce(func, wait, {\n\t    'leading': leading,\n\t    'maxWait': wait,\n\t    'trailing': trailing\n\t  });\n\t}\n\n\t/**\n\t * Checks if `value` is the\n\t * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n\t * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n\t * @example\n\t *\n\t * _.isObject({});\n\t * // => true\n\t *\n\t * _.isObject([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isObject(_.noop);\n\t * // => true\n\t *\n\t * _.isObject(null);\n\t * // => false\n\t */\n\tfunction isObject$1(value) {\n\t  var type = typeof value;\n\t  return !!value && (type == 'object' || type == 'function');\n\t}\n\n\t/**\n\t * Checks if `value` is object-like. A value is object-like if it's not `null`\n\t * and has a `typeof` result of \"object\".\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n\t * @example\n\t *\n\t * _.isObjectLike({});\n\t * // => true\n\t *\n\t * _.isObjectLike([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isObjectLike(_.noop);\n\t * // => false\n\t *\n\t * _.isObjectLike(null);\n\t * // => false\n\t */\n\tfunction isObjectLike(value) {\n\t  return !!value && typeof value == 'object';\n\t}\n\n\t/**\n\t * Checks if `value` is classified as a `Symbol` primitive or object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n\t * @example\n\t *\n\t * _.isSymbol(Symbol.iterator);\n\t * // => true\n\t *\n\t * _.isSymbol('abc');\n\t * // => false\n\t */\n\tfunction isSymbol$1(value) {\n\t  return typeof value == 'symbol' ||\n\t    (isObjectLike(value) && objectToString$1.call(value) == symbolTag);\n\t}\n\n\t/**\n\t * Converts `value` to a number.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to process.\n\t * @returns {number} Returns the number.\n\t * @example\n\t *\n\t * _.toNumber(3.2);\n\t * // => 3.2\n\t *\n\t * _.toNumber(Number.MIN_VALUE);\n\t * // => 5e-324\n\t *\n\t * _.toNumber(Infinity);\n\t * // => Infinity\n\t *\n\t * _.toNumber('3.2');\n\t * // => 3.2\n\t */\n\tfunction toNumber(value) {\n\t  if (typeof value == 'number') {\n\t    return value;\n\t  }\n\t  if (isSymbol$1(value)) {\n\t    return NAN;\n\t  }\n\t  if (isObject$1(value)) {\n\t    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n\t    value = isObject$1(other) ? (other + '') : other;\n\t  }\n\t  if (typeof value != 'string') {\n\t    return value === 0 ? value : +value;\n\t  }\n\t  value = value.replace(reTrim, '');\n\t  var isBinary = reIsBinary.test(value);\n\t  return (isBinary || reIsOctal.test(value))\n\t    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n\t    : (reIsBadHex.test(value) ? NAN : +value);\n\t}\n\n\tvar lodash_throttle = throttle;\n\n\t/**\n\t * lodash (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modularize exports=\"npm\" -o ./`\n\t * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n\t * Released under MIT license <https://lodash.com/license>\n\t * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n\t * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t */\n\n\t/** Used as the `TypeError` message for \"Functions\" methods. */\n\tvar FUNC_ERROR_TEXT$1 = 'Expected a function';\n\n\t/** Used as references for various `Number` constants. */\n\tvar NAN$1 = 0 / 0;\n\n\t/** `Object#toString` result references. */\n\tvar symbolTag$1 = '[object Symbol]';\n\n\t/** Used to match leading and trailing whitespace. */\n\tvar reTrim$1 = /^\\s+|\\s+$/g;\n\n\t/** Used to detect bad signed hexadecimal string values. */\n\tvar reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i;\n\n\t/** Used to detect binary string values. */\n\tvar reIsBinary$1 = /^0b[01]+$/i;\n\n\t/** Used to detect octal string values. */\n\tvar reIsOctal$1 = /^0o[0-7]+$/i;\n\n\t/** Built-in method references without a dependency on `root`. */\n\tvar freeParseInt$1 = parseInt;\n\n\t/** Detect free variable `global` from Node.js. */\n\tvar freeGlobal$1 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n\n\t/** Detect free variable `self`. */\n\tvar freeSelf$1 = typeof self == 'object' && self && self.Object === Object && self;\n\n\t/** Used as a reference to the global object. */\n\tvar root$1 = freeGlobal$1 || freeSelf$1 || Function('return this')();\n\n\t/** Used for built-in method references. */\n\tvar objectProto$1 = Object.prototype;\n\n\t/**\n\t * Used to resolve the\n\t * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n\t * of values.\n\t */\n\tvar objectToString$2 = objectProto$1.toString;\n\n\t/* Built-in method references for those with the same name as other `lodash` methods. */\n\tvar nativeMax$1 = Math.max,\n\t    nativeMin$1 = Math.min;\n\n\t/**\n\t * Gets the timestamp of the number of milliseconds that have elapsed since\n\t * the Unix epoch (1 January 1970 00:00:00 UTC).\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 2.4.0\n\t * @category Date\n\t * @returns {number} Returns the timestamp.\n\t * @example\n\t *\n\t * _.defer(function(stamp) {\n\t *   console.log(_.now() - stamp);\n\t * }, _.now());\n\t * // => Logs the number of milliseconds it took for the deferred invocation.\n\t */\n\tvar now$1 = function() {\n\t  return root$1.Date.now();\n\t};\n\n\t/**\n\t * Creates a debounced function that delays invoking `func` until after `wait`\n\t * milliseconds have elapsed since the last time the debounced function was\n\t * invoked. The debounced function comes with a `cancel` method to cancel\n\t * delayed `func` invocations and a `flush` method to immediately invoke them.\n\t * Provide `options` to indicate whether `func` should be invoked on the\n\t * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n\t * with the last arguments provided to the debounced function. Subsequent\n\t * calls to the debounced function return the result of the last `func`\n\t * invocation.\n\t *\n\t * **Note:** If `leading` and `trailing` options are `true`, `func` is\n\t * invoked on the trailing edge of the timeout only if the debounced function\n\t * is invoked more than once during the `wait` timeout.\n\t *\n\t * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n\t * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n\t *\n\t * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n\t * for details over the differences between `_.debounce` and `_.throttle`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Function\n\t * @param {Function} func The function to debounce.\n\t * @param {number} [wait=0] The number of milliseconds to delay.\n\t * @param {Object} [options={}] The options object.\n\t * @param {boolean} [options.leading=false]\n\t *  Specify invoking on the leading edge of the timeout.\n\t * @param {number} [options.maxWait]\n\t *  The maximum time `func` is allowed to be delayed before it's invoked.\n\t * @param {boolean} [options.trailing=true]\n\t *  Specify invoking on the trailing edge of the timeout.\n\t * @returns {Function} Returns the new debounced function.\n\t * @example\n\t *\n\t * // Avoid costly calculations while the window size is in flux.\n\t * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n\t *\n\t * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n\t * jQuery(element).on('click', _.debounce(sendMail, 300, {\n\t *   'leading': true,\n\t *   'trailing': false\n\t * }));\n\t *\n\t * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n\t * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n\t * var source = new EventSource('/stream');\n\t * jQuery(source).on('message', debounced);\n\t *\n\t * // Cancel the trailing debounced invocation.\n\t * jQuery(window).on('popstate', debounced.cancel);\n\t */\n\tfunction debounce$1(func, wait, options) {\n\t  var lastArgs,\n\t      lastThis,\n\t      maxWait,\n\t      result,\n\t      timerId,\n\t      lastCallTime,\n\t      lastInvokeTime = 0,\n\t      leading = false,\n\t      maxing = false,\n\t      trailing = true;\n\n\t  if (typeof func != 'function') {\n\t    throw new TypeError(FUNC_ERROR_TEXT$1);\n\t  }\n\t  wait = toNumber$1(wait) || 0;\n\t  if (isObject$2(options)) {\n\t    leading = !!options.leading;\n\t    maxing = 'maxWait' in options;\n\t    maxWait = maxing ? nativeMax$1(toNumber$1(options.maxWait) || 0, wait) : maxWait;\n\t    trailing = 'trailing' in options ? !!options.trailing : trailing;\n\t  }\n\n\t  function invokeFunc(time) {\n\t    var args = lastArgs,\n\t        thisArg = lastThis;\n\n\t    lastArgs = lastThis = undefined;\n\t    lastInvokeTime = time;\n\t    result = func.apply(thisArg, args);\n\t    return result;\n\t  }\n\n\t  function leadingEdge(time) {\n\t    // Reset any `maxWait` timer.\n\t    lastInvokeTime = time;\n\t    // Start the timer for the trailing edge.\n\t    timerId = setTimeout(timerExpired, wait);\n\t    // Invoke the leading edge.\n\t    return leading ? invokeFunc(time) : result;\n\t  }\n\n\t  function remainingWait(time) {\n\t    var timeSinceLastCall = time - lastCallTime,\n\t        timeSinceLastInvoke = time - lastInvokeTime,\n\t        result = wait - timeSinceLastCall;\n\n\t    return maxing ? nativeMin$1(result, maxWait - timeSinceLastInvoke) : result;\n\t  }\n\n\t  function shouldInvoke(time) {\n\t    var timeSinceLastCall = time - lastCallTime,\n\t        timeSinceLastInvoke = time - lastInvokeTime;\n\n\t    // Either this is the first call, activity has stopped and we're at the\n\t    // trailing edge, the system time has gone backwards and we're treating\n\t    // it as the trailing edge, or we've hit the `maxWait` limit.\n\t    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n\t      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n\t  }\n\n\t  function timerExpired() {\n\t    var time = now$1();\n\t    if (shouldInvoke(time)) {\n\t      return trailingEdge(time);\n\t    }\n\t    // Restart the timer.\n\t    timerId = setTimeout(timerExpired, remainingWait(time));\n\t  }\n\n\t  function trailingEdge(time) {\n\t    timerId = undefined;\n\n\t    // Only invoke if we have `lastArgs` which means `func` has been\n\t    // debounced at least once.\n\t    if (trailing && lastArgs) {\n\t      return invokeFunc(time);\n\t    }\n\t    lastArgs = lastThis = undefined;\n\t    return result;\n\t  }\n\n\t  function cancel() {\n\t    if (timerId !== undefined) {\n\t      clearTimeout(timerId);\n\t    }\n\t    lastInvokeTime = 0;\n\t    lastArgs = lastCallTime = lastThis = timerId = undefined;\n\t  }\n\n\t  function flush() {\n\t    return timerId === undefined ? result : trailingEdge(now$1());\n\t  }\n\n\t  function debounced() {\n\t    var time = now$1(),\n\t        isInvoking = shouldInvoke(time);\n\n\t    lastArgs = arguments;\n\t    lastThis = this;\n\t    lastCallTime = time;\n\n\t    if (isInvoking) {\n\t      if (timerId === undefined) {\n\t        return leadingEdge(lastCallTime);\n\t      }\n\t      if (maxing) {\n\t        // Handle invocations in a tight loop.\n\t        timerId = setTimeout(timerExpired, wait);\n\t        return invokeFunc(lastCallTime);\n\t      }\n\t    }\n\t    if (timerId === undefined) {\n\t      timerId = setTimeout(timerExpired, wait);\n\t    }\n\t    return result;\n\t  }\n\t  debounced.cancel = cancel;\n\t  debounced.flush = flush;\n\t  return debounced;\n\t}\n\n\t/**\n\t * Checks if `value` is the\n\t * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n\t * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n\t * @example\n\t *\n\t * _.isObject({});\n\t * // => true\n\t *\n\t * _.isObject([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isObject(_.noop);\n\t * // => true\n\t *\n\t * _.isObject(null);\n\t * // => false\n\t */\n\tfunction isObject$2(value) {\n\t  var type = typeof value;\n\t  return !!value && (type == 'object' || type == 'function');\n\t}\n\n\t/**\n\t * Checks if `value` is object-like. A value is object-like if it's not `null`\n\t * and has a `typeof` result of \"object\".\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n\t * @example\n\t *\n\t * _.isObjectLike({});\n\t * // => true\n\t *\n\t * _.isObjectLike([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isObjectLike(_.noop);\n\t * // => false\n\t *\n\t * _.isObjectLike(null);\n\t * // => false\n\t */\n\tfunction isObjectLike$1(value) {\n\t  return !!value && typeof value == 'object';\n\t}\n\n\t/**\n\t * Checks if `value` is classified as a `Symbol` primitive or object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n\t * @example\n\t *\n\t * _.isSymbol(Symbol.iterator);\n\t * // => true\n\t *\n\t * _.isSymbol('abc');\n\t * // => false\n\t */\n\tfunction isSymbol$2(value) {\n\t  return typeof value == 'symbol' ||\n\t    (isObjectLike$1(value) && objectToString$2.call(value) == symbolTag$1);\n\t}\n\n\t/**\n\t * Converts `value` to a number.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to process.\n\t * @returns {number} Returns the number.\n\t * @example\n\t *\n\t * _.toNumber(3.2);\n\t * // => 3.2\n\t *\n\t * _.toNumber(Number.MIN_VALUE);\n\t * // => 5e-324\n\t *\n\t * _.toNumber(Infinity);\n\t * // => Infinity\n\t *\n\t * _.toNumber('3.2');\n\t * // => 3.2\n\t */\n\tfunction toNumber$1(value) {\n\t  if (typeof value == 'number') {\n\t    return value;\n\t  }\n\t  if (isSymbol$2(value)) {\n\t    return NAN$1;\n\t  }\n\t  if (isObject$2(value)) {\n\t    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n\t    value = isObject$2(other) ? (other + '') : other;\n\t  }\n\t  if (typeof value != 'string') {\n\t    return value === 0 ? value : +value;\n\t  }\n\t  value = value.replace(reTrim$1, '');\n\t  var isBinary = reIsBinary$1.test(value);\n\t  return (isBinary || reIsOctal$1.test(value))\n\t    ? freeParseInt$1(value.slice(2), isBinary ? 2 : 8)\n\t    : (reIsBadHex$1.test(value) ? NAN$1 : +value);\n\t}\n\n\tvar lodash_debounce = debounce$1;\n\n\t/**\n\t * lodash (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modularize exports=\"npm\" -o ./`\n\t * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n\t * Released under MIT license <https://lodash.com/license>\n\t * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n\t * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t */\n\n\t/** Used as the `TypeError` message for \"Functions\" methods. */\n\tvar FUNC_ERROR_TEXT$2 = 'Expected a function';\n\n\t/** Used to stand-in for `undefined` hash values. */\n\tvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n\t/** `Object#toString` result references. */\n\tvar funcTag = '[object Function]',\n\t    genTag = '[object GeneratorFunction]';\n\n\t/**\n\t * Used to match `RegExp`\n\t * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n\t */\n\tvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n\t/** Used to detect host constructors (Safari). */\n\tvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n\t/** Detect free variable `global` from Node.js. */\n\tvar freeGlobal$2 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n\n\t/** Detect free variable `self`. */\n\tvar freeSelf$2 = typeof self == 'object' && self && self.Object === Object && self;\n\n\t/** Used as a reference to the global object. */\n\tvar root$2 = freeGlobal$2 || freeSelf$2 || Function('return this')();\n\n\t/**\n\t * Gets the value at `key` of `object`.\n\t *\n\t * @private\n\t * @param {Object} [object] The object to query.\n\t * @param {string} key The key of the property to get.\n\t * @returns {*} Returns the property value.\n\t */\n\tfunction getValue(object, key) {\n\t  return object == null ? undefined : object[key];\n\t}\n\n\t/**\n\t * Checks if `value` is a host object in IE < 9.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n\t */\n\tfunction isHostObject(value) {\n\t  // Many host objects are `Object` objects that can coerce to strings\n\t  // despite having improperly defined `toString` methods.\n\t  var result = false;\n\t  if (value != null && typeof value.toString != 'function') {\n\t    try {\n\t      result = !!(value + '');\n\t    } catch (e) {}\n\t  }\n\t  return result;\n\t}\n\n\t/** Used for built-in method references. */\n\tvar arrayProto = Array.prototype,\n\t    funcProto = Function.prototype,\n\t    objectProto$2 = Object.prototype;\n\n\t/** Used to detect overreaching core-js shims. */\n\tvar coreJsData = root$2['__core-js_shared__'];\n\n\t/** Used to detect methods masquerading as native. */\n\tvar maskSrcKey = (function() {\n\t  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n\t  return uid ? ('Symbol(src)_1.' + uid) : '';\n\t}());\n\n\t/** Used to resolve the decompiled source of functions. */\n\tvar funcToString = funcProto.toString;\n\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty$1 = objectProto$2.hasOwnProperty;\n\n\t/**\n\t * Used to resolve the\n\t * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n\t * of values.\n\t */\n\tvar objectToString$3 = objectProto$2.toString;\n\n\t/** Used to detect if a method is native. */\n\tvar reIsNative = RegExp('^' +\n\t  funcToString.call(hasOwnProperty$1).replace(reRegExpChar, '\\\\$&')\n\t  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n\t);\n\n\t/** Built-in value references. */\n\tvar splice$1 = arrayProto.splice;\n\n\t/* Built-in method references that are verified to be native. */\n\tvar Map = getNative(root$2, 'Map'),\n\t    nativeCreate = getNative(Object, 'create');\n\n\t/**\n\t * Creates a hash object.\n\t *\n\t * @private\n\t * @constructor\n\t * @param {Array} [entries] The key-value pairs to cache.\n\t */\n\tfunction Hash(entries) {\n\t  var index = -1,\n\t      length = entries ? entries.length : 0;\n\n\t  this.clear();\n\t  while (++index < length) {\n\t    var entry = entries[index];\n\t    this.set(entry[0], entry[1]);\n\t  }\n\t}\n\n\t/**\n\t * Removes all key-value entries from the hash.\n\t *\n\t * @private\n\t * @name clear\n\t * @memberOf Hash\n\t */\n\tfunction hashClear() {\n\t  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n\t}\n\n\t/**\n\t * Removes `key` and its value from the hash.\n\t *\n\t * @private\n\t * @name delete\n\t * @memberOf Hash\n\t * @param {Object} hash The hash to modify.\n\t * @param {string} key The key of the value to remove.\n\t * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t */\n\tfunction hashDelete(key) {\n\t  return this.has(key) && delete this.__data__[key];\n\t}\n\n\t/**\n\t * Gets the hash value for `key`.\n\t *\n\t * @private\n\t * @name get\n\t * @memberOf Hash\n\t * @param {string} key The key of the value to get.\n\t * @returns {*} Returns the entry value.\n\t */\n\tfunction hashGet(key) {\n\t  var data = this.__data__;\n\t  if (nativeCreate) {\n\t    var result = data[key];\n\t    return result === HASH_UNDEFINED ? undefined : result;\n\t  }\n\t  return hasOwnProperty$1.call(data, key) ? data[key] : undefined;\n\t}\n\n\t/**\n\t * Checks if a hash value for `key` exists.\n\t *\n\t * @private\n\t * @name has\n\t * @memberOf Hash\n\t * @param {string} key The key of the entry to check.\n\t * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t */\n\tfunction hashHas(key) {\n\t  var data = this.__data__;\n\t  return nativeCreate ? data[key] !== undefined : hasOwnProperty$1.call(data, key);\n\t}\n\n\t/**\n\t * Sets the hash `key` to `value`.\n\t *\n\t * @private\n\t * @name set\n\t * @memberOf Hash\n\t * @param {string} key The key of the value to set.\n\t * @param {*} value The value to set.\n\t * @returns {Object} Returns the hash instance.\n\t */\n\tfunction hashSet(key, value) {\n\t  var data = this.__data__;\n\t  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n\t  return this;\n\t}\n\n\t// Add methods to `Hash`.\n\tHash.prototype.clear = hashClear;\n\tHash.prototype['delete'] = hashDelete;\n\tHash.prototype.get = hashGet;\n\tHash.prototype.has = hashHas;\n\tHash.prototype.set = hashSet;\n\n\t/**\n\t * Creates an list cache object.\n\t *\n\t * @private\n\t * @constructor\n\t * @param {Array} [entries] The key-value pairs to cache.\n\t */\n\tfunction ListCache(entries) {\n\t  var index = -1,\n\t      length = entries ? entries.length : 0;\n\n\t  this.clear();\n\t  while (++index < length) {\n\t    var entry = entries[index];\n\t    this.set(entry[0], entry[1]);\n\t  }\n\t}\n\n\t/**\n\t * Removes all key-value entries from the list cache.\n\t *\n\t * @private\n\t * @name clear\n\t * @memberOf ListCache\n\t */\n\tfunction listCacheClear() {\n\t  this.__data__ = [];\n\t}\n\n\t/**\n\t * Removes `key` and its value from the list cache.\n\t *\n\t * @private\n\t * @name delete\n\t * @memberOf ListCache\n\t * @param {string} key The key of the value to remove.\n\t * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t */\n\tfunction listCacheDelete(key) {\n\t  var data = this.__data__,\n\t      index = assocIndexOf(data, key);\n\n\t  if (index < 0) {\n\t    return false;\n\t  }\n\t  var lastIndex = data.length - 1;\n\t  if (index == lastIndex) {\n\t    data.pop();\n\t  } else {\n\t    splice$1.call(data, index, 1);\n\t  }\n\t  return true;\n\t}\n\n\t/**\n\t * Gets the list cache value for `key`.\n\t *\n\t * @private\n\t * @name get\n\t * @memberOf ListCache\n\t * @param {string} key The key of the value to get.\n\t * @returns {*} Returns the entry value.\n\t */\n\tfunction listCacheGet(key) {\n\t  var data = this.__data__,\n\t      index = assocIndexOf(data, key);\n\n\t  return index < 0 ? undefined : data[index][1];\n\t}\n\n\t/**\n\t * Checks if a list cache value for `key` exists.\n\t *\n\t * @private\n\t * @name has\n\t * @memberOf ListCache\n\t * @param {string} key The key of the entry to check.\n\t * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t */\n\tfunction listCacheHas(key) {\n\t  return assocIndexOf(this.__data__, key) > -1;\n\t}\n\n\t/**\n\t * Sets the list cache `key` to `value`.\n\t *\n\t * @private\n\t * @name set\n\t * @memberOf ListCache\n\t * @param {string} key The key of the value to set.\n\t * @param {*} value The value to set.\n\t * @returns {Object} Returns the list cache instance.\n\t */\n\tfunction listCacheSet(key, value) {\n\t  var data = this.__data__,\n\t      index = assocIndexOf(data, key);\n\n\t  if (index < 0) {\n\t    data.push([key, value]);\n\t  } else {\n\t    data[index][1] = value;\n\t  }\n\t  return this;\n\t}\n\n\t// Add methods to `ListCache`.\n\tListCache.prototype.clear = listCacheClear;\n\tListCache.prototype['delete'] = listCacheDelete;\n\tListCache.prototype.get = listCacheGet;\n\tListCache.prototype.has = listCacheHas;\n\tListCache.prototype.set = listCacheSet;\n\n\t/**\n\t * Creates a map cache object to store key-value pairs.\n\t *\n\t * @private\n\t * @constructor\n\t * @param {Array} [entries] The key-value pairs to cache.\n\t */\n\tfunction MapCache(entries) {\n\t  var index = -1,\n\t      length = entries ? entries.length : 0;\n\n\t  this.clear();\n\t  while (++index < length) {\n\t    var entry = entries[index];\n\t    this.set(entry[0], entry[1]);\n\t  }\n\t}\n\n\t/**\n\t * Removes all key-value entries from the map.\n\t *\n\t * @private\n\t * @name clear\n\t * @memberOf MapCache\n\t */\n\tfunction mapCacheClear() {\n\t  this.__data__ = {\n\t    'hash': new Hash,\n\t    'map': new (Map || ListCache),\n\t    'string': new Hash\n\t  };\n\t}\n\n\t/**\n\t * Removes `key` and its value from the map.\n\t *\n\t * @private\n\t * @name delete\n\t * @memberOf MapCache\n\t * @param {string} key The key of the value to remove.\n\t * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t */\n\tfunction mapCacheDelete(key) {\n\t  return getMapData(this, key)['delete'](key);\n\t}\n\n\t/**\n\t * Gets the map value for `key`.\n\t *\n\t * @private\n\t * @name get\n\t * @memberOf MapCache\n\t * @param {string} key The key of the value to get.\n\t * @returns {*} Returns the entry value.\n\t */\n\tfunction mapCacheGet(key) {\n\t  return getMapData(this, key).get(key);\n\t}\n\n\t/**\n\t * Checks if a map value for `key` exists.\n\t *\n\t * @private\n\t * @name has\n\t * @memberOf MapCache\n\t * @param {string} key The key of the entry to check.\n\t * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t */\n\tfunction mapCacheHas(key) {\n\t  return getMapData(this, key).has(key);\n\t}\n\n\t/**\n\t * Sets the map `key` to `value`.\n\t *\n\t * @private\n\t * @name set\n\t * @memberOf MapCache\n\t * @param {string} key The key of the value to set.\n\t * @param {*} value The value to set.\n\t * @returns {Object} Returns the map cache instance.\n\t */\n\tfunction mapCacheSet(key, value) {\n\t  getMapData(this, key).set(key, value);\n\t  return this;\n\t}\n\n\t// Add methods to `MapCache`.\n\tMapCache.prototype.clear = mapCacheClear;\n\tMapCache.prototype['delete'] = mapCacheDelete;\n\tMapCache.prototype.get = mapCacheGet;\n\tMapCache.prototype.has = mapCacheHas;\n\tMapCache.prototype.set = mapCacheSet;\n\n\t/**\n\t * Gets the index at which the `key` is found in `array` of key-value pairs.\n\t *\n\t * @private\n\t * @param {Array} array The array to inspect.\n\t * @param {*} key The key to search for.\n\t * @returns {number} Returns the index of the matched value, else `-1`.\n\t */\n\tfunction assocIndexOf(array, key) {\n\t  var length = array.length;\n\t  while (length--) {\n\t    if (eq(array[length][0], key)) {\n\t      return length;\n\t    }\n\t  }\n\t  return -1;\n\t}\n\n\t/**\n\t * The base implementation of `_.isNative` without bad shim checks.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a native function,\n\t *  else `false`.\n\t */\n\tfunction baseIsNative(value) {\n\t  if (!isObject$3(value) || isMasked(value)) {\n\t    return false;\n\t  }\n\t  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n\t  return pattern.test(toSource(value));\n\t}\n\n\t/**\n\t * Gets the data for `map`.\n\t *\n\t * @private\n\t * @param {Object} map The map to query.\n\t * @param {string} key The reference key.\n\t * @returns {*} Returns the map data.\n\t */\n\tfunction getMapData(map, key) {\n\t  var data = map.__data__;\n\t  return isKeyable(key)\n\t    ? data[typeof key == 'string' ? 'string' : 'hash']\n\t    : data.map;\n\t}\n\n\t/**\n\t * Gets the native function at `key` of `object`.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @param {string} key The key of the method to get.\n\t * @returns {*} Returns the function if it's native, else `undefined`.\n\t */\n\tfunction getNative(object, key) {\n\t  var value = getValue(object, key);\n\t  return baseIsNative(value) ? value : undefined;\n\t}\n\n\t/**\n\t * Checks if `value` is suitable for use as unique object key.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n\t */\n\tfunction isKeyable(value) {\n\t  var type = typeof value;\n\t  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n\t    ? (value !== '__proto__')\n\t    : (value === null);\n\t}\n\n\t/**\n\t * Checks if `func` has its source masked.\n\t *\n\t * @private\n\t * @param {Function} func The function to check.\n\t * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n\t */\n\tfunction isMasked(func) {\n\t  return !!maskSrcKey && (maskSrcKey in func);\n\t}\n\n\t/**\n\t * Converts `func` to its source code.\n\t *\n\t * @private\n\t * @param {Function} func The function to process.\n\t * @returns {string} Returns the source code.\n\t */\n\tfunction toSource(func) {\n\t  if (func != null) {\n\t    try {\n\t      return funcToString.call(func);\n\t    } catch (e) {}\n\t    try {\n\t      return (func + '');\n\t    } catch (e) {}\n\t  }\n\t  return '';\n\t}\n\n\t/**\n\t * Creates a function that memoizes the result of `func`. If `resolver` is\n\t * provided, it determines the cache key for storing the result based on the\n\t * arguments provided to the memoized function. By default, the first argument\n\t * provided to the memoized function is used as the map cache key. The `func`\n\t * is invoked with the `this` binding of the memoized function.\n\t *\n\t * **Note:** The cache is exposed as the `cache` property on the memoized\n\t * function. Its creation may be customized by replacing the `_.memoize.Cache`\n\t * constructor with one whose instances implement the\n\t * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n\t * method interface of `delete`, `get`, `has`, and `set`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Function\n\t * @param {Function} func The function to have its output memoized.\n\t * @param {Function} [resolver] The function to resolve the cache key.\n\t * @returns {Function} Returns the new memoized function.\n\t * @example\n\t *\n\t * var object = { 'a': 1, 'b': 2 };\n\t * var other = { 'c': 3, 'd': 4 };\n\t *\n\t * var values = _.memoize(_.values);\n\t * values(object);\n\t * // => [1, 2]\n\t *\n\t * values(other);\n\t * // => [3, 4]\n\t *\n\t * object.a = 2;\n\t * values(object);\n\t * // => [1, 2]\n\t *\n\t * // Modify the result cache.\n\t * values.cache.set(object, ['a', 'b']);\n\t * values(object);\n\t * // => ['a', 'b']\n\t *\n\t * // Replace `_.memoize.Cache`.\n\t * _.memoize.Cache = WeakMap;\n\t */\n\tfunction memoize(func, resolver) {\n\t  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n\t    throw new TypeError(FUNC_ERROR_TEXT$2);\n\t  }\n\t  var memoized = function() {\n\t    var args = arguments,\n\t        key = resolver ? resolver.apply(this, args) : args[0],\n\t        cache = memoized.cache;\n\n\t    if (cache.has(key)) {\n\t      return cache.get(key);\n\t    }\n\t    var result = func.apply(this, args);\n\t    memoized.cache = cache.set(key, result);\n\t    return result;\n\t  };\n\t  memoized.cache = new (memoize.Cache || MapCache);\n\t  return memoized;\n\t}\n\n\t// Assign cache to `_.memoize`.\n\tmemoize.Cache = MapCache;\n\n\t/**\n\t * Performs a\n\t * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n\t * comparison between two values to determine if they are equivalent.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to compare.\n\t * @param {*} other The other value to compare.\n\t * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n\t * @example\n\t *\n\t * var object = { 'a': 1 };\n\t * var other = { 'a': 1 };\n\t *\n\t * _.eq(object, object);\n\t * // => true\n\t *\n\t * _.eq(object, other);\n\t * // => false\n\t *\n\t * _.eq('a', 'a');\n\t * // => true\n\t *\n\t * _.eq('a', Object('a'));\n\t * // => false\n\t *\n\t * _.eq(NaN, NaN);\n\t * // => true\n\t */\n\tfunction eq(value, other) {\n\t  return value === other || (value !== value && other !== other);\n\t}\n\n\t/**\n\t * Checks if `value` is classified as a `Function` object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n\t * @example\n\t *\n\t * _.isFunction(_);\n\t * // => true\n\t *\n\t * _.isFunction(/abc/);\n\t * // => false\n\t */\n\tfunction isFunction(value) {\n\t  // The use of `Object#toString` avoids issues with the `typeof` operator\n\t  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n\t  var tag = isObject$3(value) ? objectToString$3.call(value) : '';\n\t  return tag == funcTag || tag == genTag;\n\t}\n\n\t/**\n\t * Checks if `value` is the\n\t * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n\t * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n\t * @example\n\t *\n\t * _.isObject({});\n\t * // => true\n\t *\n\t * _.isObject([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isObject(_.noop);\n\t * // => true\n\t *\n\t * _.isObject(null);\n\t * // => false\n\t */\n\tfunction isObject$3(value) {\n\t  var type = typeof value;\n\t  return !!value && (type == 'object' || type == 'function');\n\t}\n\n\tvar lodash_memoize = memoize;\n\n\tvar resizeObservers = [];\n\n\tvar hasActiveObservations = function () {\n\t    return resizeObservers.some(function (ro) { return ro.activeTargets.length > 0; });\n\t};\n\n\tvar hasSkippedObservations = function () {\n\t    return resizeObservers.some(function (ro) { return ro.skippedTargets.length > 0; });\n\t};\n\n\tvar msg = 'ResizeObserver loop completed with undelivered notifications.';\n\tvar deliverResizeLoopError = function () {\n\t    var event;\n\t    if (typeof ErrorEvent === 'function') {\n\t        event = new ErrorEvent('error', {\n\t            message: msg\n\t        });\n\t    }\n\t    else {\n\t        event = document.createEvent('Event');\n\t        event.initEvent('error', false, false);\n\t        event.message = msg;\n\t    }\n\t    window.dispatchEvent(event);\n\t};\n\n\tvar ResizeObserverBoxOptions;\n\t(function (ResizeObserverBoxOptions) {\n\t    ResizeObserverBoxOptions[\"BORDER_BOX\"] = \"border-box\";\n\t    ResizeObserverBoxOptions[\"CONTENT_BOX\"] = \"content-box\";\n\t    ResizeObserverBoxOptions[\"DEVICE_PIXEL_CONTENT_BOX\"] = \"device-pixel-content-box\";\n\t})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));\n\n\tvar freeze = function (obj) { return Object.freeze(obj); };\n\n\tvar ResizeObserverSize = (function () {\n\t    function ResizeObserverSize(inlineSize, blockSize) {\n\t        this.inlineSize = inlineSize;\n\t        this.blockSize = blockSize;\n\t        freeze(this);\n\t    }\n\t    return ResizeObserverSize;\n\t}());\n\n\tvar DOMRectReadOnly = (function () {\n\t    function DOMRectReadOnly(x, y, width, height) {\n\t        this.x = x;\n\t        this.y = y;\n\t        this.width = width;\n\t        this.height = height;\n\t        this.top = this.y;\n\t        this.left = this.x;\n\t        this.bottom = this.top + this.height;\n\t        this.right = this.left + this.width;\n\t        return freeze(this);\n\t    }\n\t    DOMRectReadOnly.prototype.toJSON = function () {\n\t        var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;\n\t        return { x: x, y: y, top: top, right: right, bottom: bottom, left: left, width: width, height: height };\n\t    };\n\t    DOMRectReadOnly.fromRect = function (rectangle) {\n\t        return new DOMRectReadOnly(rectangle.x, rectangle.y, rectangle.width, rectangle.height);\n\t    };\n\t    return DOMRectReadOnly;\n\t}());\n\n\tvar isSVG = function (target) { return target instanceof SVGElement && 'getBBox' in target; };\n\tvar isHidden = function (target) {\n\t    if (isSVG(target)) {\n\t        var _a = target.getBBox(), width = _a.width, height = _a.height;\n\t        return !width && !height;\n\t    }\n\t    var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;\n\t    return !(offsetWidth || offsetHeight || target.getClientRects().length);\n\t};\n\tvar isElement = function (obj) {\n\t    var _a, _b;\n\t    if (obj instanceof Element) {\n\t        return true;\n\t    }\n\t    var scope = (_b = (_a = obj) === null || _a === void 0 ? void 0 : _a.ownerDocument) === null || _b === void 0 ? void 0 : _b.defaultView;\n\t    return !!(scope && obj instanceof scope.Element);\n\t};\n\tvar isReplacedElement = function (target) {\n\t    switch (target.tagName) {\n\t        case 'INPUT':\n\t            if (target.type !== 'image') {\n\t                break;\n\t            }\n\t        case 'VIDEO':\n\t        case 'AUDIO':\n\t        case 'EMBED':\n\t        case 'OBJECT':\n\t        case 'CANVAS':\n\t        case 'IFRAME':\n\t        case 'IMG':\n\t            return true;\n\t    }\n\t    return false;\n\t};\n\n\tvar global$1 = typeof window !== 'undefined' ? window : {};\n\n\tvar cache = new WeakMap();\n\tvar scrollRegexp = /auto|scroll/;\n\tvar verticalRegexp = /^tb|vertical/;\n\tvar IE = (/msie|trident/i).test(global$1.navigator && global$1.navigator.userAgent);\n\tvar parseDimension = function (pixel) { return parseFloat(pixel || '0'); };\n\tvar size = function (inlineSize, blockSize, switchSizes) {\n\t    if (inlineSize === void 0) { inlineSize = 0; }\n\t    if (blockSize === void 0) { blockSize = 0; }\n\t    if (switchSizes === void 0) { switchSizes = false; }\n\t    return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);\n\t};\n\tvar zeroBoxes = freeze({\n\t    devicePixelContentBoxSize: size(),\n\t    borderBoxSize: size(),\n\t    contentBoxSize: size(),\n\t    contentRect: new DOMRectReadOnly(0, 0, 0, 0)\n\t});\n\tvar calculateBoxSizes = function (target, forceRecalculation) {\n\t    if (forceRecalculation === void 0) { forceRecalculation = false; }\n\t    if (cache.has(target) && !forceRecalculation) {\n\t        return cache.get(target);\n\t    }\n\t    if (isHidden(target)) {\n\t        cache.set(target, zeroBoxes);\n\t        return zeroBoxes;\n\t    }\n\t    var cs = getComputedStyle(target);\n\t    var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();\n\t    var removePadding = !IE && cs.boxSizing === 'border-box';\n\t    var switchSizes = verticalRegexp.test(cs.writingMode || '');\n\t    var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || '');\n\t    var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || '');\n\t    var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);\n\t    var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);\n\t    var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);\n\t    var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);\n\t    var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);\n\t    var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);\n\t    var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);\n\t    var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);\n\t    var horizontalPadding = paddingLeft + paddingRight;\n\t    var verticalPadding = paddingTop + paddingBottom;\n\t    var horizontalBorderArea = borderLeft + borderRight;\n\t    var verticalBorderArea = borderTop + borderBottom;\n\t    var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;\n\t    var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;\n\t    var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;\n\t    var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;\n\t    var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;\n\t    var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;\n\t    var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;\n\t    var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;\n\t    var boxes = freeze({\n\t        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),\n\t        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),\n\t        contentBoxSize: size(contentWidth, contentHeight, switchSizes),\n\t        contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)\n\t    });\n\t    cache.set(target, boxes);\n\t    return boxes;\n\t};\n\tvar calculateBoxSize = function (target, observedBox, forceRecalculation) {\n\t    var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;\n\t    switch (observedBox) {\n\t        case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:\n\t            return devicePixelContentBoxSize;\n\t        case ResizeObserverBoxOptions.BORDER_BOX:\n\t            return borderBoxSize;\n\t        default:\n\t            return contentBoxSize;\n\t    }\n\t};\n\n\tvar ResizeObserverEntry = (function () {\n\t    function ResizeObserverEntry(target) {\n\t        var boxes = calculateBoxSizes(target);\n\t        this.target = target;\n\t        this.contentRect = boxes.contentRect;\n\t        this.borderBoxSize = freeze([boxes.borderBoxSize]);\n\t        this.contentBoxSize = freeze([boxes.contentBoxSize]);\n\t        this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);\n\t    }\n\t    return ResizeObserverEntry;\n\t}());\n\n\tvar calculateDepthForNode = function (node) {\n\t    if (isHidden(node)) {\n\t        return Infinity;\n\t    }\n\t    var depth = 0;\n\t    var parent = node.parentNode;\n\t    while (parent) {\n\t        depth += 1;\n\t        parent = parent.parentNode;\n\t    }\n\t    return depth;\n\t};\n\n\tvar broadcastActiveObservations = function () {\n\t    var shallowestDepth = Infinity;\n\t    var callbacks = [];\n\t    resizeObservers.forEach(function processObserver(ro) {\n\t        if (ro.activeTargets.length === 0) {\n\t            return;\n\t        }\n\t        var entries = [];\n\t        ro.activeTargets.forEach(function processTarget(ot) {\n\t            var entry = new ResizeObserverEntry(ot.target);\n\t            var targetDepth = calculateDepthForNode(ot.target);\n\t            entries.push(entry);\n\t            ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);\n\t            if (targetDepth < shallowestDepth) {\n\t                shallowestDepth = targetDepth;\n\t            }\n\t        });\n\t        callbacks.push(function resizeObserverCallback() {\n\t            ro.callback.call(ro.observer, entries, ro.observer);\n\t        });\n\t        ro.activeTargets.splice(0, ro.activeTargets.length);\n\t    });\n\t    for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {\n\t        var callback = callbacks_1[_i];\n\t        callback();\n\t    }\n\t    return shallowestDepth;\n\t};\n\n\tvar gatherActiveObservationsAtDepth = function (depth) {\n\t    resizeObservers.forEach(function processObserver(ro) {\n\t        ro.activeTargets.splice(0, ro.activeTargets.length);\n\t        ro.skippedTargets.splice(0, ro.skippedTargets.length);\n\t        ro.observationTargets.forEach(function processTarget(ot) {\n\t            if (ot.isActive()) {\n\t                if (calculateDepthForNode(ot.target) > depth) {\n\t                    ro.activeTargets.push(ot);\n\t                }\n\t                else {\n\t                    ro.skippedTargets.push(ot);\n\t                }\n\t            }\n\t        });\n\t    });\n\t};\n\n\tvar process$1 = function () {\n\t    var depth = 0;\n\t    gatherActiveObservationsAtDepth(depth);\n\t    while (hasActiveObservations()) {\n\t        depth = broadcastActiveObservations();\n\t        gatherActiveObservationsAtDepth(depth);\n\t    }\n\t    if (hasSkippedObservations()) {\n\t        deliverResizeLoopError();\n\t    }\n\t    return depth > 0;\n\t};\n\n\tvar trigger;\n\tvar callbacks = [];\n\tvar notify = function () { return callbacks.splice(0).forEach(function (cb) { return cb(); }); };\n\tvar queueMicroTask = function (callback) {\n\t    if (!trigger) {\n\t        var toggle_1 = 0;\n\t        var el_1 = document.createTextNode('');\n\t        var config = { characterData: true };\n\t        new MutationObserver(function () { return notify(); }).observe(el_1, config);\n\t        trigger = function () { el_1.textContent = \"\" + (toggle_1 ? toggle_1-- : toggle_1++); };\n\t    }\n\t    callbacks.push(callback);\n\t    trigger();\n\t};\n\n\tvar queueResizeObserver = function (cb) {\n\t    queueMicroTask(function ResizeObserver() {\n\t        requestAnimationFrame(cb);\n\t    });\n\t};\n\n\tvar watching = 0;\n\tvar isWatching = function () { return !!watching; };\n\tvar CATCH_PERIOD = 250;\n\tvar observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };\n\tvar events = [\n\t    'resize',\n\t    'load',\n\t    'transitionend',\n\t    'animationend',\n\t    'animationstart',\n\t    'animationiteration',\n\t    'keyup',\n\t    'keydown',\n\t    'mouseup',\n\t    'mousedown',\n\t    'mouseover',\n\t    'mouseout',\n\t    'blur',\n\t    'focus'\n\t];\n\tvar time = function (timeout) {\n\t    if (timeout === void 0) { timeout = 0; }\n\t    return Date.now() + timeout;\n\t};\n\tvar scheduled = false;\n\tvar Scheduler = (function () {\n\t    function Scheduler() {\n\t        var _this = this;\n\t        this.stopped = true;\n\t        this.listener = function () { return _this.schedule(); };\n\t    }\n\t    Scheduler.prototype.run = function (timeout) {\n\t        var _this = this;\n\t        if (timeout === void 0) { timeout = CATCH_PERIOD; }\n\t        if (scheduled) {\n\t            return;\n\t        }\n\t        scheduled = true;\n\t        var until = time(timeout);\n\t        queueResizeObserver(function () {\n\t            var elementsHaveResized = false;\n\t            try {\n\t                elementsHaveResized = process$1();\n\t            }\n\t            finally {\n\t                scheduled = false;\n\t                timeout = until - time();\n\t                if (!isWatching()) {\n\t                    return;\n\t                }\n\t                if (elementsHaveResized) {\n\t                    _this.run(1000);\n\t                }\n\t                else if (timeout > 0) {\n\t                    _this.run(timeout);\n\t                }\n\t                else {\n\t                    _this.start();\n\t                }\n\t            }\n\t        });\n\t    };\n\t    Scheduler.prototype.schedule = function () {\n\t        this.stop();\n\t        this.run();\n\t    };\n\t    Scheduler.prototype.observe = function () {\n\t        var _this = this;\n\t        var cb = function () { return _this.observer && _this.observer.observe(document.body, observerConfig); };\n\t        document.body ? cb() : global$1.addEventListener('DOMContentLoaded', cb);\n\t    };\n\t    Scheduler.prototype.start = function () {\n\t        var _this = this;\n\t        if (this.stopped) {\n\t            this.stopped = false;\n\t            this.observer = new MutationObserver(this.listener);\n\t            this.observe();\n\t            events.forEach(function (name) { return global$1.addEventListener(name, _this.listener, true); });\n\t        }\n\t    };\n\t    Scheduler.prototype.stop = function () {\n\t        var _this = this;\n\t        if (!this.stopped) {\n\t            this.observer && this.observer.disconnect();\n\t            events.forEach(function (name) { return global$1.removeEventListener(name, _this.listener, true); });\n\t            this.stopped = true;\n\t        }\n\t    };\n\t    return Scheduler;\n\t}());\n\tvar scheduler = new Scheduler();\n\tvar updateCount = function (n) {\n\t    !watching && n > 0 && scheduler.start();\n\t    watching += n;\n\t    !watching && scheduler.stop();\n\t};\n\n\tvar skipNotifyOnElement = function (target) {\n\t    return !isSVG(target)\n\t        && !isReplacedElement(target)\n\t        && getComputedStyle(target).display === 'inline';\n\t};\n\tvar ResizeObservation = (function () {\n\t    function ResizeObservation(target, observedBox) {\n\t        this.target = target;\n\t        this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;\n\t        this.lastReportedSize = {\n\t            inlineSize: 0,\n\t            blockSize: 0\n\t        };\n\t    }\n\t    ResizeObservation.prototype.isActive = function () {\n\t        var size = calculateBoxSize(this.target, this.observedBox, true);\n\t        if (skipNotifyOnElement(this.target)) {\n\t            this.lastReportedSize = size;\n\t        }\n\t        if (this.lastReportedSize.inlineSize !== size.inlineSize\n\t            || this.lastReportedSize.blockSize !== size.blockSize) {\n\t            return true;\n\t        }\n\t        return false;\n\t    };\n\t    return ResizeObservation;\n\t}());\n\n\tvar ResizeObserverDetail = (function () {\n\t    function ResizeObserverDetail(resizeObserver, callback) {\n\t        this.activeTargets = [];\n\t        this.skippedTargets = [];\n\t        this.observationTargets = [];\n\t        this.observer = resizeObserver;\n\t        this.callback = callback;\n\t    }\n\t    return ResizeObserverDetail;\n\t}());\n\n\tvar observerMap = new WeakMap();\n\tvar getObservationIndex = function (observationTargets, target) {\n\t    for (var i = 0; i < observationTargets.length; i += 1) {\n\t        if (observationTargets[i].target === target) {\n\t            return i;\n\t        }\n\t    }\n\t    return -1;\n\t};\n\tvar ResizeObserverController = (function () {\n\t    function ResizeObserverController() {\n\t    }\n\t    ResizeObserverController.connect = function (resizeObserver, callback) {\n\t        var detail = new ResizeObserverDetail(resizeObserver, callback);\n\t        observerMap.set(resizeObserver, detail);\n\t    };\n\t    ResizeObserverController.observe = function (resizeObserver, target, options) {\n\t        var detail = observerMap.get(resizeObserver);\n\t        var firstObservation = detail.observationTargets.length === 0;\n\t        if (getObservationIndex(detail.observationTargets, target) < 0) {\n\t            firstObservation && resizeObservers.push(detail);\n\t            detail.observationTargets.push(new ResizeObservation(target, options && options.box));\n\t            updateCount(1);\n\t            scheduler.schedule();\n\t        }\n\t    };\n\t    ResizeObserverController.unobserve = function (resizeObserver, target) {\n\t        var detail = observerMap.get(resizeObserver);\n\t        var index = getObservationIndex(detail.observationTargets, target);\n\t        var lastObservation = detail.observationTargets.length === 1;\n\t        if (index >= 0) {\n\t            lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);\n\t            detail.observationTargets.splice(index, 1);\n\t            updateCount(-1);\n\t        }\n\t    };\n\t    ResizeObserverController.disconnect = function (resizeObserver) {\n\t        var _this = this;\n\t        var detail = observerMap.get(resizeObserver);\n\t        detail.observationTargets.slice().forEach(function (ot) { return _this.unobserve(resizeObserver, ot.target); });\n\t        detail.activeTargets.splice(0, detail.activeTargets.length);\n\t    };\n\t    return ResizeObserverController;\n\t}());\n\n\tvar ResizeObserver = (function () {\n\t    function ResizeObserver(callback) {\n\t        if (arguments.length === 0) {\n\t            throw new TypeError(\"Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.\");\n\t        }\n\t        if (typeof callback !== 'function') {\n\t            throw new TypeError(\"Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.\");\n\t        }\n\t        ResizeObserverController.connect(this, callback);\n\t    }\n\t    ResizeObserver.prototype.observe = function (target, options) {\n\t        if (arguments.length === 0) {\n\t            throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n\t        }\n\t        if (!isElement(target)) {\n\t            throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n\t        }\n\t        ResizeObserverController.observe(this, target, options);\n\t    };\n\t    ResizeObserver.prototype.unobserve = function (target) {\n\t        if (arguments.length === 0) {\n\t            throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n\t        }\n\t        if (!isElement(target)) {\n\t            throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n\t        }\n\t        ResizeObserverController.unobserve(this, target);\n\t    };\n\t    ResizeObserver.prototype.disconnect = function () {\n\t        ResizeObserverController.disconnect(this);\n\t    };\n\t    ResizeObserver.toString = function () {\n\t        return 'function ResizeObserver () { [polyfill code] }';\n\t    };\n\t    return ResizeObserver;\n\t}());\n\n\tvar TypeError$c = global_1.TypeError;\n\n\t// `Array.prototype.{ reduce, reduceRight }` methods implementation\n\tvar createMethod$4 = function (IS_RIGHT) {\n\t  return function (that, callbackfn, argumentsLength, memo) {\n\t    aCallable(callbackfn);\n\t    var O = toObject(that);\n\t    var self = indexedObject(O);\n\t    var length = lengthOfArrayLike(O);\n\t    var index = IS_RIGHT ? length - 1 : 0;\n\t    var i = IS_RIGHT ? -1 : 1;\n\t    if (argumentsLength < 2) while (true) {\n\t      if (index in self) {\n\t        memo = self[index];\n\t        index += i;\n\t        break;\n\t      }\n\t      index += i;\n\t      if (IS_RIGHT ? index < 0 : length <= index) {\n\t        throw TypeError$c('Reduce of empty array with no initial value');\n\t      }\n\t    }\n\t    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {\n\t      memo = callbackfn(memo, self[index], index, O);\n\t    }\n\t    return memo;\n\t  };\n\t};\n\n\tvar arrayReduce = {\n\t  // `Array.prototype.reduce` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.reduce\n\t  left: createMethod$4(false),\n\t  // `Array.prototype.reduceRight` method\n\t  // https://tc39.es/ecma262/#sec-array.prototype.reduceright\n\t  right: createMethod$4(true)\n\t};\n\n\tvar engineIsNode = classofRaw(global_1.process) == 'process';\n\n\tvar $reduce = arrayReduce.left;\n\n\n\n\n\tvar STRICT_METHOD$1 = arrayMethodIsStrict('reduce');\n\t// Chrome 80-82 has a critical bug\n\t// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982\n\tvar CHROME_BUG = !engineIsNode && engineV8Version > 79 && engineV8Version < 83;\n\n\t// `Array.prototype.reduce` method\n\t// https://tc39.es/ecma262/#sec-array.prototype.reduce\n\t_export({ target: 'Array', proto: true, forced: !STRICT_METHOD$1 || CHROME_BUG }, {\n\t  reduce: function reduce(callbackfn /* , initialValue */) {\n\t    var length = arguments.length;\n\t    return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\t// `RegExp.prototype.flags` getter implementation\n\t// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags\n\tvar regexpFlags = function () {\n\t  var that = anObject(this);\n\t  var result = '';\n\t  if (that.hasIndices) result += 'd';\n\t  if (that.global) result += 'g';\n\t  if (that.ignoreCase) result += 'i';\n\t  if (that.multiline) result += 'm';\n\t  if (that.dotAll) result += 's';\n\t  if (that.unicode) result += 'u';\n\t  if (that.sticky) result += 'y';\n\t  return result;\n\t};\n\n\t// babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError\n\tvar $RegExp = global_1.RegExp;\n\n\tvar UNSUPPORTED_Y = fails(function () {\n\t  var re = $RegExp('a', 'y');\n\t  re.lastIndex = 2;\n\t  return re.exec('abcd') != null;\n\t});\n\n\t// UC Browser bug\n\t// https://github.com/zloirock/core-js/issues/1008\n\tvar MISSED_STICKY = UNSUPPORTED_Y || fails(function () {\n\t  return !$RegExp('a', 'y').sticky;\n\t});\n\n\tvar BROKEN_CARET = UNSUPPORTED_Y || fails(function () {\n\t  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687\n\t  var re = $RegExp('^r', 'gy');\n\t  re.lastIndex = 2;\n\t  return re.exec('str') != null;\n\t});\n\n\tvar regexpStickyHelpers = {\n\t  BROKEN_CARET: BROKEN_CARET,\n\t  MISSED_STICKY: MISSED_STICKY,\n\t  UNSUPPORTED_Y: UNSUPPORTED_Y\n\t};\n\n\t// babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError\n\tvar $RegExp$1 = global_1.RegExp;\n\n\tvar regexpUnsupportedDotAll = fails(function () {\n\t  var re = $RegExp$1('.', 's');\n\t  return !(re.dotAll && re.exec('\\n') && re.flags === 's');\n\t});\n\n\t// babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError\n\tvar $RegExp$2 = global_1.RegExp;\n\n\tvar regexpUnsupportedNcg = fails(function () {\n\t  var re = $RegExp$2('(?<a>b)', 'g');\n\t  return re.exec('b').groups.a !== 'b' ||\n\t    'b'.replace(re, '$<a>c') !== 'bc';\n\t});\n\n\t/* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */\n\t/* eslint-disable regexp/no-useless-quantifier -- testing */\n\n\n\n\n\n\n\n\tvar getInternalState$2 = internalState.get;\n\n\n\n\tvar nativeReplace = shared('native-string-replace', String.prototype.replace);\n\tvar nativeExec = RegExp.prototype.exec;\n\tvar patchedExec = nativeExec;\n\tvar charAt$2 = functionUncurryThis(''.charAt);\n\tvar indexOf$1 = functionUncurryThis(''.indexOf);\n\tvar replace$1 = functionUncurryThis(''.replace);\n\tvar stringSlice$2 = functionUncurryThis(''.slice);\n\n\tvar UPDATES_LAST_INDEX_WRONG = (function () {\n\t  var re1 = /a/;\n\t  var re2 = /b*/g;\n\t  functionCall(nativeExec, re1, 'a');\n\t  functionCall(nativeExec, re2, 'a');\n\t  return re1.lastIndex !== 0 || re2.lastIndex !== 0;\n\t})();\n\n\tvar UNSUPPORTED_Y$1 = regexpStickyHelpers.BROKEN_CARET;\n\n\t// nonparticipating capturing group, copied from es5-shim's String#split patch.\n\tvar NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;\n\n\tvar PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1 || regexpUnsupportedDotAll || regexpUnsupportedNcg;\n\n\tif (PATCH) {\n\t  patchedExec = function exec(string) {\n\t    var re = this;\n\t    var state = getInternalState$2(re);\n\t    var str = toString_1(string);\n\t    var raw = state.raw;\n\t    var result, reCopy, lastIndex, match, i, object, group;\n\n\t    if (raw) {\n\t      raw.lastIndex = re.lastIndex;\n\t      result = functionCall(patchedExec, raw, str);\n\t      re.lastIndex = raw.lastIndex;\n\t      return result;\n\t    }\n\n\t    var groups = state.groups;\n\t    var sticky = UNSUPPORTED_Y$1 && re.sticky;\n\t    var flags = functionCall(regexpFlags, re);\n\t    var source = re.source;\n\t    var charsAdded = 0;\n\t    var strCopy = str;\n\n\t    if (sticky) {\n\t      flags = replace$1(flags, 'y', '');\n\t      if (indexOf$1(flags, 'g') === -1) {\n\t        flags += 'g';\n\t      }\n\n\t      strCopy = stringSlice$2(str, re.lastIndex);\n\t      // Support anchored sticky behavior.\n\t      if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt$2(str, re.lastIndex - 1) !== '\\n')) {\n\t        source = '(?: ' + source + ')';\n\t        strCopy = ' ' + strCopy;\n\t        charsAdded++;\n\t      }\n\t      // ^(? + rx + ) is needed, in combination with some str slicing, to\n\t      // simulate the 'y' flag.\n\t      reCopy = new RegExp('^(?:' + source + ')', flags);\n\t    }\n\n\t    if (NPCG_INCLUDED) {\n\t      reCopy = new RegExp('^' + source + '$(?!\\\\s)', flags);\n\t    }\n\t    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;\n\n\t    match = functionCall(nativeExec, sticky ? reCopy : re, strCopy);\n\n\t    if (sticky) {\n\t      if (match) {\n\t        match.input = stringSlice$2(match.input, charsAdded);\n\t        match[0] = stringSlice$2(match[0], charsAdded);\n\t        match.index = re.lastIndex;\n\t        re.lastIndex += match[0].length;\n\t      } else re.lastIndex = 0;\n\t    } else if (UPDATES_LAST_INDEX_WRONG && match) {\n\t      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;\n\t    }\n\t    if (NPCG_INCLUDED && match && match.length > 1) {\n\t      // Fix browsers whose `exec` methods don't consistently return `undefined`\n\t      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/\n\t      functionCall(nativeReplace, match[0], reCopy, function () {\n\t        for (i = 1; i < arguments.length - 2; i++) {\n\t          if (arguments[i] === undefined) match[i] = undefined;\n\t        }\n\t      });\n\t    }\n\n\t    if (match && groups) {\n\t      match.groups = object = objectCreate(null);\n\t      for (i = 0; i < groups.length; i++) {\n\t        group = groups[i];\n\t        object[group[0]] = match[group[1]];\n\t      }\n\t    }\n\n\t    return match;\n\t  };\n\t}\n\n\tvar regexpExec = patchedExec;\n\n\t// `RegExp.prototype.exec` method\n\t// https://tc39.es/ecma262/#sec-regexp.prototype.exec\n\t_export({ target: 'RegExp', proto: true, forced: /./.exec !== regexpExec }, {\n\t  exec: regexpExec\n\t});\n\n\t// TODO: Remove from `core-js@4` since it's moved to entry points\n\n\n\n\n\n\n\n\n\tvar SPECIES$2 = wellKnownSymbol('species');\n\tvar RegExpPrototype = RegExp.prototype;\n\n\tvar fixRegexpWellKnownSymbolLogic = function (KEY, exec, FORCED, SHAM) {\n\t  var SYMBOL = wellKnownSymbol(KEY);\n\n\t  var DELEGATES_TO_SYMBOL = !fails(function () {\n\t    // String methods call symbol-named RegEp methods\n\t    var O = {};\n\t    O[SYMBOL] = function () { return 7; };\n\t    return ''[KEY](O) != 7;\n\t  });\n\n\t  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {\n\t    // Symbol-named RegExp methods call .exec\n\t    var execCalled = false;\n\t    var re = /a/;\n\n\t    if (KEY === 'split') {\n\t      // We can't use real regex here since it causes deoptimization\n\t      // and serious performance degradation in V8\n\t      // https://github.com/zloirock/core-js/issues/306\n\t      re = {};\n\t      // RegExp[@@split] doesn't call the regex's exec method, but first creates\n\t      // a new one. We need to return the patched regex when creating the new one.\n\t      re.constructor = {};\n\t      re.constructor[SPECIES$2] = function () { return re; };\n\t      re.flags = '';\n\t      re[SYMBOL] = /./[SYMBOL];\n\t    }\n\n\t    re.exec = function () { execCalled = true; return null; };\n\n\t    re[SYMBOL]('');\n\t    return !execCalled;\n\t  });\n\n\t  if (\n\t    !DELEGATES_TO_SYMBOL ||\n\t    !DELEGATES_TO_EXEC ||\n\t    FORCED\n\t  ) {\n\t    var uncurriedNativeRegExpMethod = functionUncurryThis(/./[SYMBOL]);\n\t    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {\n\t      var uncurriedNativeMethod = functionUncurryThis(nativeMethod);\n\t      var $exec = regexp.exec;\n\t      if ($exec === regexpExec || $exec === RegExpPrototype.exec) {\n\t        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {\n\t          // The native String method already delegates to @@method (this\n\t          // polyfilled function), leasing to infinite recursion.\n\t          // We avoid it by directly calling the native @@method method.\n\t          return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };\n\t        }\n\t        return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };\n\t      }\n\t      return { done: false };\n\t    });\n\n\t    defineBuiltIn(String.prototype, KEY, methods[0]);\n\t    defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);\n\t  }\n\n\t  if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], 'sham', true);\n\t};\n\n\tvar charAt$3 = stringMultibyte.charAt;\n\n\t// `AdvanceStringIndex` abstract operation\n\t// https://tc39.es/ecma262/#sec-advancestringindex\n\tvar advanceStringIndex = function (S, index, unicode) {\n\t  return index + (unicode ? charAt$3(S, index).length : 1);\n\t};\n\n\tvar TypeError$d = global_1.TypeError;\n\n\t// `RegExpExec` abstract operation\n\t// https://tc39.es/ecma262/#sec-regexpexec\n\tvar regexpExecAbstract = function (R, S) {\n\t  var exec = R.exec;\n\t  if (isCallable(exec)) {\n\t    var result = functionCall(exec, R, S);\n\t    if (result !== null) anObject(result);\n\t    return result;\n\t  }\n\t  if (classofRaw(R) === 'RegExp') return functionCall(regexpExec, R, S);\n\t  throw TypeError$d('RegExp#exec called on incompatible receiver');\n\t};\n\n\t// @@match logic\n\tfixRegexpWellKnownSymbolLogic('match', function (MATCH, nativeMatch, maybeCallNative) {\n\t  return [\n\t    // `String.prototype.match` method\n\t    // https://tc39.es/ecma262/#sec-string.prototype.match\n\t    function match(regexp) {\n\t      var O = requireObjectCoercible(this);\n\t      var matcher = regexp == undefined ? undefined : getMethod(regexp, MATCH);\n\t      return matcher ? functionCall(matcher, regexp, O) : new RegExp(regexp)[MATCH](toString_1(O));\n\t    },\n\t    // `RegExp.prototype[@@match]` method\n\t    // https://tc39.es/ecma262/#sec-regexp.prototype-@@match\n\t    function (string) {\n\t      var rx = anObject(this);\n\t      var S = toString_1(string);\n\t      var res = maybeCallNative(nativeMatch, rx, S);\n\n\t      if (res.done) return res.value;\n\n\t      if (!rx.global) return regexpExecAbstract(rx, S);\n\n\t      var fullUnicode = rx.unicode;\n\t      rx.lastIndex = 0;\n\t      var A = [];\n\t      var n = 0;\n\t      var result;\n\t      while ((result = regexpExecAbstract(rx, S)) !== null) {\n\t        var matchStr = toString_1(result[0]);\n\t        A[n] = matchStr;\n\t        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);\n\t        n++;\n\t      }\n\t      return n === 0 ? null : A;\n\t    }\n\t  ];\n\t});\n\n\tvar FUNCTION_NAME_EXISTS = functionName.EXISTS;\n\n\tvar defineProperty$5 = objectDefineProperty.f;\n\n\tvar FunctionPrototype$2 = Function.prototype;\n\tvar functionToString$1 = functionUncurryThis(FunctionPrototype$2.toString);\n\tvar nameRE = /function\\b(?:\\s|\\/\\*[\\S\\s]*?\\*\\/|\\/\\/[^\\n\\r]*[\\n\\r]+)*([^\\s(/]*)/;\n\tvar regExpExec = functionUncurryThis(nameRE.exec);\n\tvar NAME = 'name';\n\n\t// Function instances `.name` property\n\t// https://tc39.es/ecma262/#sec-function-instances-name\n\tif (descriptors && !FUNCTION_NAME_EXISTS) {\n\t  defineProperty$5(FunctionPrototype$2, NAME, {\n\t    configurable: true,\n\t    get: function () {\n\t      try {\n\t        return regExpExec(nameRE, functionToString$1(this))[1];\n\t      } catch (error) {\n\t        return '';\n\t      }\n\t    }\n\t  });\n\t}\n\n\tvar FunctionPrototype$3 = Function.prototype;\n\tvar apply = FunctionPrototype$3.apply;\n\tvar call$2 = FunctionPrototype$3.call;\n\n\t// eslint-disable-next-line es-x/no-reflect -- safe\n\tvar functionApply = typeof Reflect == 'object' && Reflect.apply || (functionBindNative ? call$2.bind(apply) : function () {\n\t  return call$2.apply(apply, arguments);\n\t});\n\n\tvar floor$1 = Math.floor;\n\tvar charAt$4 = functionUncurryThis(''.charAt);\n\tvar replace$2 = functionUncurryThis(''.replace);\n\tvar stringSlice$3 = functionUncurryThis(''.slice);\n\tvar SUBSTITUTION_SYMBOLS = /\\$([$&'`]|\\d{1,2}|<[^>]*>)/g;\n\tvar SUBSTITUTION_SYMBOLS_NO_NAMED = /\\$([$&'`]|\\d{1,2})/g;\n\n\t// `GetSubstitution` abstract operation\n\t// https://tc39.es/ecma262/#sec-getsubstitution\n\tvar getSubstitution = function (matched, str, position, captures, namedCaptures, replacement) {\n\t  var tailPos = position + matched.length;\n\t  var m = captures.length;\n\t  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;\n\t  if (namedCaptures !== undefined) {\n\t    namedCaptures = toObject(namedCaptures);\n\t    symbols = SUBSTITUTION_SYMBOLS;\n\t  }\n\t  return replace$2(replacement, symbols, function (match, ch) {\n\t    var capture;\n\t    switch (charAt$4(ch, 0)) {\n\t      case '$': return '$';\n\t      case '&': return matched;\n\t      case '`': return stringSlice$3(str, 0, position);\n\t      case \"'\": return stringSlice$3(str, tailPos);\n\t      case '<':\n\t        capture = namedCaptures[stringSlice$3(ch, 1, -1)];\n\t        break;\n\t      default: // \\d\\d?\n\t        var n = +ch;\n\t        if (n === 0) return match;\n\t        if (n > m) {\n\t          var f = floor$1(n / 10);\n\t          if (f === 0) return match;\n\t          if (f <= m) return captures[f - 1] === undefined ? charAt$4(ch, 1) : captures[f - 1] + charAt$4(ch, 1);\n\t          return match;\n\t        }\n\t        capture = captures[n - 1];\n\t    }\n\t    return capture === undefined ? '' : capture;\n\t  });\n\t};\n\n\tvar REPLACE = wellKnownSymbol('replace');\n\tvar max$2 = Math.max;\n\tvar min$2 = Math.min;\n\tvar concat$2 = functionUncurryThis([].concat);\n\tvar push$2 = functionUncurryThis([].push);\n\tvar stringIndexOf = functionUncurryThis(''.indexOf);\n\tvar stringSlice$4 = functionUncurryThis(''.slice);\n\n\tvar maybeToString = function (it) {\n\t  return it === undefined ? it : String(it);\n\t};\n\n\t// IE <= 11 replaces $0 with the whole match, as if it was $&\n\t// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0\n\tvar REPLACE_KEEPS_$0 = (function () {\n\t  // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing\n\t  return 'a'.replace(/./, '$0') === '$0';\n\t})();\n\n\t// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string\n\tvar REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {\n\t  if (/./[REPLACE]) {\n\t    return /./[REPLACE]('a', '$0') === '';\n\t  }\n\t  return false;\n\t})();\n\n\tvar REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {\n\t  var re = /./;\n\t  re.exec = function () {\n\t    var result = [];\n\t    result.groups = { a: '7' };\n\t    return result;\n\t  };\n\t  // eslint-disable-next-line regexp/no-useless-dollar-replacements -- false positive\n\t  return ''.replace(re, '$<a>') !== '7';\n\t});\n\n\t// @@replace logic\n\tfixRegexpWellKnownSymbolLogic('replace', function (_, nativeReplace, maybeCallNative) {\n\t  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';\n\n\t  return [\n\t    // `String.prototype.replace` method\n\t    // https://tc39.es/ecma262/#sec-string.prototype.replace\n\t    function replace(searchValue, replaceValue) {\n\t      var O = requireObjectCoercible(this);\n\t      var replacer = searchValue == undefined ? undefined : getMethod(searchValue, REPLACE);\n\t      return replacer\n\t        ? functionCall(replacer, searchValue, O, replaceValue)\n\t        : functionCall(nativeReplace, toString_1(O), searchValue, replaceValue);\n\t    },\n\t    // `RegExp.prototype[@@replace]` method\n\t    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace\n\t    function (string, replaceValue) {\n\t      var rx = anObject(this);\n\t      var S = toString_1(string);\n\n\t      if (\n\t        typeof replaceValue == 'string' &&\n\t        stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 &&\n\t        stringIndexOf(replaceValue, '$<') === -1\n\t      ) {\n\t        var res = maybeCallNative(nativeReplace, rx, S, replaceValue);\n\t        if (res.done) return res.value;\n\t      }\n\n\t      var functionalReplace = isCallable(replaceValue);\n\t      if (!functionalReplace) replaceValue = toString_1(replaceValue);\n\n\t      var global = rx.global;\n\t      if (global) {\n\t        var fullUnicode = rx.unicode;\n\t        rx.lastIndex = 0;\n\t      }\n\t      var results = [];\n\t      while (true) {\n\t        var result = regexpExecAbstract(rx, S);\n\t        if (result === null) break;\n\n\t        push$2(results, result);\n\t        if (!global) break;\n\n\t        var matchStr = toString_1(result[0]);\n\t        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);\n\t      }\n\n\t      var accumulatedResult = '';\n\t      var nextSourcePosition = 0;\n\t      for (var i = 0; i < results.length; i++) {\n\t        result = results[i];\n\n\t        var matched = toString_1(result[0]);\n\t        var position = max$2(min$2(toIntegerOrInfinity(result.index), S.length), 0);\n\t        var captures = [];\n\t        // NOTE: This is equivalent to\n\t        //   captures = result.slice(1).map(maybeToString)\n\t        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in\n\t        // the slice polyfill when slicing native arrays) \"doesn't work\" in safari 9 and\n\t        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.\n\t        for (var j = 1; j < result.length; j++) push$2(captures, maybeToString(result[j]));\n\t        var namedCaptures = result.groups;\n\t        if (functionalReplace) {\n\t          var replacerArgs = concat$2([matched], captures, position, S);\n\t          if (namedCaptures !== undefined) push$2(replacerArgs, namedCaptures);\n\t          var replacement = toString_1(functionApply(replaceValue, undefined, replacerArgs));\n\t        } else {\n\t          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);\n\t        }\n\t        if (position >= nextSourcePosition) {\n\t          accumulatedResult += stringSlice$4(S, nextSourcePosition, position) + replacement;\n\t          nextSourcePosition = position + matched.length;\n\t        }\n\t      }\n\t      return accumulatedResult + stringSlice$4(S, nextSourcePosition);\n\t    }\n\t  ];\n\t}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);\n\n\t// Helper function to retrieve options from element attributes\n\tvar getOptions = function getOptions(obj) {\n\t  var options = Array.prototype.reduce.call(obj, function (acc, attribute) {\n\t    var option = attribute.name.match(/data-simplebar-(.+)/);\n\n\t    if (option) {\n\t      var key = option[1].replace(/\\W+(.)/g, function (x, chr) {\n\t        return chr.toUpperCase();\n\t      });\n\n\t      switch (attribute.value) {\n\t        case 'true':\n\t          acc[key] = true;\n\t          break;\n\n\t        case 'false':\n\t          acc[key] = false;\n\t          break;\n\n\t        case undefined:\n\t          acc[key] = true;\n\t          break;\n\n\t        default:\n\t          acc[key] = attribute.value;\n\t      }\n\t    }\n\n\t    return acc;\n\t  }, {});\n\t  return options;\n\t};\n\tfunction getElementWindow(element) {\n\t  if (!element || !element.ownerDocument || !element.ownerDocument.defaultView) {\n\t    return window;\n\t  }\n\n\t  return element.ownerDocument.defaultView;\n\t}\n\tfunction getElementDocument(element) {\n\t  if (!element || !element.ownerDocument) {\n\t    return document;\n\t  }\n\n\t  return element.ownerDocument;\n\t}\n\n\tvar cachedScrollbarWidth = null;\n\tvar cachedDevicePixelRatio = null;\n\n\tif (canUseDom) {\n\t  window.addEventListener('resize', function () {\n\t    if (cachedDevicePixelRatio !== window.devicePixelRatio) {\n\t      cachedDevicePixelRatio = window.devicePixelRatio;\n\t      cachedScrollbarWidth = null;\n\t    }\n\t  });\n\t}\n\n\tfunction scrollbarWidth(el) {\n\t  if (cachedScrollbarWidth === null) {\n\t    var document = getElementDocument(el);\n\n\t    if (typeof document === 'undefined') {\n\t      cachedScrollbarWidth = 0;\n\t      return cachedScrollbarWidth;\n\t    }\n\n\t    var body = document.body;\n\t    var box = document.createElement('div');\n\t    box.classList.add('simplebar-hide-scrollbar');\n\t    body.appendChild(box);\n\t    var width = box.getBoundingClientRect().right;\n\t    body.removeChild(box);\n\t    cachedScrollbarWidth = width;\n\t  }\n\n\t  return cachedScrollbarWidth;\n\t}\n\n\tvar SimpleBar = /*#__PURE__*/function () {\n\t  function SimpleBar(element, options) {\n\t    var _this = this;\n\n\t    this.onScroll = function () {\n\t      var elWindow = getElementWindow(_this.el);\n\n\t      if (!_this.scrollXTicking) {\n\t        elWindow.requestAnimationFrame(_this.scrollX);\n\t        _this.scrollXTicking = true;\n\t      }\n\n\t      if (!_this.scrollYTicking) {\n\t        elWindow.requestAnimationFrame(_this.scrollY);\n\t        _this.scrollYTicking = true;\n\t      }\n\t    };\n\n\t    this.scrollX = function () {\n\t      if (_this.axis.x.isOverflowing) {\n\t        _this.showScrollbar('x');\n\n\t        _this.positionScrollbar('x');\n\t      }\n\n\t      _this.scrollXTicking = false;\n\t    };\n\n\t    this.scrollY = function () {\n\t      if (_this.axis.y.isOverflowing) {\n\t        _this.showScrollbar('y');\n\n\t        _this.positionScrollbar('y');\n\t      }\n\n\t      _this.scrollYTicking = false;\n\t    };\n\n\t    this.onMouseEnter = function () {\n\t      _this.showScrollbar('x');\n\n\t      _this.showScrollbar('y');\n\t    };\n\n\t    this.onMouseMove = function (e) {\n\t      _this.mouseX = e.clientX;\n\t      _this.mouseY = e.clientY;\n\n\t      if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) {\n\t        _this.onMouseMoveForAxis('x');\n\t      }\n\n\t      if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) {\n\t        _this.onMouseMoveForAxis('y');\n\t      }\n\t    };\n\n\t    this.onMouseLeave = function () {\n\t      _this.onMouseMove.cancel();\n\n\t      if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) {\n\t        _this.onMouseLeaveForAxis('x');\n\t      }\n\n\t      if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) {\n\t        _this.onMouseLeaveForAxis('y');\n\t      }\n\n\t      _this.mouseX = -1;\n\t      _this.mouseY = -1;\n\t    };\n\n\t    this.onWindowResize = function () {\n\t      // Recalculate scrollbarWidth in case it's a zoom\n\t      _this.scrollbarWidth = _this.getScrollbarWidth();\n\n\t      _this.hideNativeScrollbar();\n\t    };\n\n\t    this.hideScrollbars = function () {\n\t      _this.axis.x.track.rect = _this.axis.x.track.el.getBoundingClientRect();\n\t      _this.axis.y.track.rect = _this.axis.y.track.el.getBoundingClientRect();\n\n\t      if (!_this.isWithinBounds(_this.axis.y.track.rect)) {\n\t        _this.axis.y.scrollbar.el.classList.remove(_this.classNames.visible);\n\n\t        _this.axis.y.isVisible = false;\n\t      }\n\n\t      if (!_this.isWithinBounds(_this.axis.x.track.rect)) {\n\t        _this.axis.x.scrollbar.el.classList.remove(_this.classNames.visible);\n\n\t        _this.axis.x.isVisible = false;\n\t      }\n\t    };\n\n\t    this.onPointerEvent = function (e) {\n\t      var isWithinTrackXBounds, isWithinTrackYBounds;\n\t      _this.axis.x.track.rect = _this.axis.x.track.el.getBoundingClientRect();\n\t      _this.axis.y.track.rect = _this.axis.y.track.el.getBoundingClientRect();\n\n\t      if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) {\n\t        isWithinTrackXBounds = _this.isWithinBounds(_this.axis.x.track.rect);\n\t      }\n\n\t      if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) {\n\t        isWithinTrackYBounds = _this.isWithinBounds(_this.axis.y.track.rect);\n\t      } // If any pointer event is called on the scrollbar\n\n\n\t      if (isWithinTrackXBounds || isWithinTrackYBounds) {\n\t        // Preventing the event's default action stops text being\n\t        // selectable during the drag.\n\t        e.preventDefault(); // Prevent event leaking\n\n\t        e.stopPropagation();\n\n\t        if (e.type === 'mousedown') {\n\t          if (isWithinTrackXBounds) {\n\t            _this.axis.x.scrollbar.rect = _this.axis.x.scrollbar.el.getBoundingClientRect();\n\n\t            if (_this.isWithinBounds(_this.axis.x.scrollbar.rect)) {\n\t              _this.onDragStart(e, 'x');\n\t            } else {\n\t              _this.onTrackClick(e, 'x');\n\t            }\n\t          }\n\n\t          if (isWithinTrackYBounds) {\n\t            _this.axis.y.scrollbar.rect = _this.axis.y.scrollbar.el.getBoundingClientRect();\n\n\t            if (_this.isWithinBounds(_this.axis.y.scrollbar.rect)) {\n\t              _this.onDragStart(e, 'y');\n\t            } else {\n\t              _this.onTrackClick(e, 'y');\n\t            }\n\t          }\n\t        }\n\t      }\n\t    };\n\n\t    this.drag = function (e) {\n\t      var eventOffset;\n\t      var track = _this.axis[_this.draggedAxis].track;\n\t      var trackSize = track.rect[_this.axis[_this.draggedAxis].sizeAttr];\n\t      var scrollbar = _this.axis[_this.draggedAxis].scrollbar;\n\t      var contentSize = _this.contentWrapperEl[_this.axis[_this.draggedAxis].scrollSizeAttr];\n\t      var hostSize = parseInt(_this.elStyles[_this.axis[_this.draggedAxis].sizeAttr], 10);\n\t      e.preventDefault();\n\t      e.stopPropagation();\n\n\t      if (_this.draggedAxis === 'y') {\n\t        eventOffset = e.pageY;\n\t      } else {\n\t        eventOffset = e.pageX;\n\t      } // Calculate how far the user's mouse is from the top/left of the scrollbar (minus the dragOffset).\n\n\n\t      var dragPos = eventOffset - track.rect[_this.axis[_this.draggedAxis].offsetAttr] - _this.axis[_this.draggedAxis].dragOffset; // Convert the mouse position into a percentage of the scrollbar height/width.\n\n\t      var dragPerc = dragPos / (trackSize - scrollbar.size); // Scroll the content by the same percentage.\n\n\t      var scrollPos = dragPerc * (contentSize - hostSize); // Fix browsers inconsistency on RTL\n\n\t      if (_this.draggedAxis === 'x') {\n\t        scrollPos = _this.isRtl && SimpleBar.getRtlHelpers().isRtlScrollbarInverted ? scrollPos - (trackSize + scrollbar.size) : scrollPos;\n\t        scrollPos = _this.isRtl && SimpleBar.getRtlHelpers().isRtlScrollingInverted ? -scrollPos : scrollPos;\n\t      }\n\n\t      _this.contentWrapperEl[_this.axis[_this.draggedAxis].scrollOffsetAttr] = scrollPos;\n\t    };\n\n\t    this.onEndDrag = function (e) {\n\t      var elDocument = getElementDocument(_this.el);\n\t      var elWindow = getElementWindow(_this.el);\n\t      e.preventDefault();\n\t      e.stopPropagation();\n\n\t      _this.el.classList.remove(_this.classNames.dragging);\n\n\t      elDocument.removeEventListener('mousemove', _this.drag, true);\n\t      elDocument.removeEventListener('mouseup', _this.onEndDrag, true);\n\t      _this.removePreventClickId = elWindow.setTimeout(function () {\n\t        // Remove these asynchronously so we still suppress click events\n\t        // generated simultaneously with mouseup.\n\t        elDocument.removeEventListener('click', _this.preventClick, true);\n\t        elDocument.removeEventListener('dblclick', _this.preventClick, true);\n\t        _this.removePreventClickId = null;\n\t      });\n\t    };\n\n\t    this.preventClick = function (e) {\n\t      e.preventDefault();\n\t      e.stopPropagation();\n\t    };\n\n\t    this.el = element;\n\t    this.minScrollbarWidth = 20;\n\t    this.options = Object.assign({}, SimpleBar.defaultOptions, options);\n\t    this.classNames = Object.assign({}, SimpleBar.defaultOptions.classNames, this.options.classNames);\n\t    this.axis = {\n\t      x: {\n\t        scrollOffsetAttr: 'scrollLeft',\n\t        sizeAttr: 'width',\n\t        scrollSizeAttr: 'scrollWidth',\n\t        offsetSizeAttr: 'offsetWidth',\n\t        offsetAttr: 'left',\n\t        overflowAttr: 'overflowX',\n\t        dragOffset: 0,\n\t        isOverflowing: true,\n\t        isVisible: false,\n\t        forceVisible: false,\n\t        track: {},\n\t        scrollbar: {}\n\t      },\n\t      y: {\n\t        scrollOffsetAttr: 'scrollTop',\n\t        sizeAttr: 'height',\n\t        scrollSizeAttr: 'scrollHeight',\n\t        offsetSizeAttr: 'offsetHeight',\n\t        offsetAttr: 'top',\n\t        overflowAttr: 'overflowY',\n\t        dragOffset: 0,\n\t        isOverflowing: true,\n\t        isVisible: false,\n\t        forceVisible: false,\n\t        track: {},\n\t        scrollbar: {}\n\t      }\n\t    };\n\t    this.removePreventClickId = null; // Don't re-instantiate over an existing one\n\n\t    if (SimpleBar.instances.has(this.el)) {\n\t      return;\n\t    }\n\n\t    this.recalculate = lodash_throttle(this.recalculate.bind(this), 64);\n\t    this.onMouseMove = lodash_throttle(this.onMouseMove.bind(this), 64);\n\t    this.hideScrollbars = lodash_debounce(this.hideScrollbars.bind(this), this.options.timeout);\n\t    this.onWindowResize = lodash_debounce(this.onWindowResize.bind(this), 64, {\n\t      leading: true\n\t    });\n\t    SimpleBar.getRtlHelpers = lodash_memoize(SimpleBar.getRtlHelpers);\n\t    this.init();\n\t  }\n\t  /**\n\t   * Static properties\n\t   */\n\n\t  /**\n\t   * Helper to fix browsers inconsistency on RTL:\n\t   *  - Firefox inverts the scrollbar initial position\n\t   *  - IE11 inverts both scrollbar position and scrolling offset\n\t   * Directly inspired by @KingSora's OverlayScrollbars https://github.com/KingSora/OverlayScrollbars/blob/master/js/OverlayScrollbars.js#L1634\n\t   */\n\n\n\t  SimpleBar.getRtlHelpers = function getRtlHelpers() {\n\t    var dummyDiv = document.createElement('div');\n\t    dummyDiv.innerHTML = '<div class=\"hs-dummy-scrollbar-size\"><div style=\"height: 200%; width: 200%; margin: 10px 0;\"></div></div>';\n\t    var scrollbarDummyEl = dummyDiv.firstElementChild;\n\t    document.body.appendChild(scrollbarDummyEl);\n\t    var dummyContainerChild = scrollbarDummyEl.firstElementChild;\n\t    scrollbarDummyEl.scrollLeft = 0;\n\t    var dummyContainerOffset = SimpleBar.getOffset(scrollbarDummyEl);\n\t    var dummyContainerChildOffset = SimpleBar.getOffset(dummyContainerChild);\n\t    scrollbarDummyEl.scrollLeft = 999;\n\t    var dummyContainerScrollOffsetAfterScroll = SimpleBar.getOffset(dummyContainerChild);\n\t    return {\n\t      // determines if the scrolling is responding with negative values\n\t      isRtlScrollingInverted: dummyContainerOffset.left !== dummyContainerChildOffset.left && dummyContainerChildOffset.left - dummyContainerScrollOffsetAfterScroll.left !== 0,\n\t      // determines if the origin scrollbar position is inverted or not (positioned on left or right)\n\t      isRtlScrollbarInverted: dummyContainerOffset.left !== dummyContainerChildOffset.left\n\t    };\n\t  };\n\n\t  SimpleBar.getOffset = function getOffset(el) {\n\t    var rect = el.getBoundingClientRect();\n\t    var elDocument = getElementDocument(el);\n\t    var elWindow = getElementWindow(el);\n\t    return {\n\t      top: rect.top + (elWindow.pageYOffset || elDocument.documentElement.scrollTop),\n\t      left: rect.left + (elWindow.pageXOffset || elDocument.documentElement.scrollLeft)\n\t    };\n\t  };\n\n\t  var _proto = SimpleBar.prototype;\n\n\t  _proto.init = function init() {\n\t    // Save a reference to the instance, so we know this DOM node has already been instancied\n\t    SimpleBar.instances.set(this.el, this); // We stop here on server-side\n\n\t    if (canUseDom) {\n\t      this.initDOM();\n\t      this.setAccessibilityAttributes();\n\t      this.scrollbarWidth = this.getScrollbarWidth();\n\t      this.recalculate();\n\t      this.initListeners();\n\t    }\n\t  };\n\n\t  _proto.initDOM = function initDOM() {\n\t    var _this2 = this;\n\n\t    // make sure this element doesn't have the elements yet\n\t    if (Array.prototype.filter.call(this.el.children, function (child) {\n\t      return child.classList.contains(_this2.classNames.wrapper);\n\t    }).length) {\n\t      // assume that element has his DOM already initiated\n\t      this.wrapperEl = this.el.querySelector(\".\" + this.classNames.wrapper);\n\t      this.contentWrapperEl = this.options.scrollableNode || this.el.querySelector(\".\" + this.classNames.contentWrapper);\n\t      this.contentEl = this.options.contentNode || this.el.querySelector(\".\" + this.classNames.contentEl);\n\t      this.offsetEl = this.el.querySelector(\".\" + this.classNames.offset);\n\t      this.maskEl = this.el.querySelector(\".\" + this.classNames.mask);\n\t      this.placeholderEl = this.findChild(this.wrapperEl, \".\" + this.classNames.placeholder);\n\t      this.heightAutoObserverWrapperEl = this.el.querySelector(\".\" + this.classNames.heightAutoObserverWrapperEl);\n\t      this.heightAutoObserverEl = this.el.querySelector(\".\" + this.classNames.heightAutoObserverEl);\n\t      this.axis.x.track.el = this.findChild(this.el, \".\" + this.classNames.track + \".\" + this.classNames.horizontal);\n\t      this.axis.y.track.el = this.findChild(this.el, \".\" + this.classNames.track + \".\" + this.classNames.vertical);\n\t    } else {\n\t      // Prepare DOM\n\t      this.wrapperEl = document.createElement('div');\n\t      this.contentWrapperEl = document.createElement('div');\n\t      this.offsetEl = document.createElement('div');\n\t      this.maskEl = document.createElement('div');\n\t      this.contentEl = document.createElement('div');\n\t      this.placeholderEl = document.createElement('div');\n\t      this.heightAutoObserverWrapperEl = document.createElement('div');\n\t      this.heightAutoObserverEl = document.createElement('div');\n\t      this.wrapperEl.classList.add(this.classNames.wrapper);\n\t      this.contentWrapperEl.classList.add(this.classNames.contentWrapper);\n\t      this.offsetEl.classList.add(this.classNames.offset);\n\t      this.maskEl.classList.add(this.classNames.mask);\n\t      this.contentEl.classList.add(this.classNames.contentEl);\n\t      this.placeholderEl.classList.add(this.classNames.placeholder);\n\t      this.heightAutoObserverWrapperEl.classList.add(this.classNames.heightAutoObserverWrapperEl);\n\t      this.heightAutoObserverEl.classList.add(this.classNames.heightAutoObserverEl);\n\n\t      while (this.el.firstChild) {\n\t        this.contentEl.appendChild(this.el.firstChild);\n\t      }\n\n\t      this.contentWrapperEl.appendChild(this.contentEl);\n\t      this.offsetEl.appendChild(this.contentWrapperEl);\n\t      this.maskEl.appendChild(this.offsetEl);\n\t      this.heightAutoObserverWrapperEl.appendChild(this.heightAutoObserverEl);\n\t      this.wrapperEl.appendChild(this.heightAutoObserverWrapperEl);\n\t      this.wrapperEl.appendChild(this.maskEl);\n\t      this.wrapperEl.appendChild(this.placeholderEl);\n\t      this.el.appendChild(this.wrapperEl);\n\t    }\n\n\t    if (!this.axis.x.track.el || !this.axis.y.track.el) {\n\t      var track = document.createElement('div');\n\t      var scrollbar = document.createElement('div');\n\t      track.classList.add(this.classNames.track);\n\t      scrollbar.classList.add(this.classNames.scrollbar);\n\t      track.appendChild(scrollbar);\n\t      this.axis.x.track.el = track.cloneNode(true);\n\t      this.axis.x.track.el.classList.add(this.classNames.horizontal);\n\t      this.axis.y.track.el = track.cloneNode(true);\n\t      this.axis.y.track.el.classList.add(this.classNames.vertical);\n\t      this.el.appendChild(this.axis.x.track.el);\n\t      this.el.appendChild(this.axis.y.track.el);\n\t    }\n\n\t    this.axis.x.scrollbar.el = this.axis.x.track.el.querySelector(\".\" + this.classNames.scrollbar);\n\t    this.axis.y.scrollbar.el = this.axis.y.track.el.querySelector(\".\" + this.classNames.scrollbar);\n\n\t    if (!this.options.autoHide) {\n\t      this.axis.x.scrollbar.el.classList.add(this.classNames.visible);\n\t      this.axis.y.scrollbar.el.classList.add(this.classNames.visible);\n\t    }\n\n\t    this.el.setAttribute('data-simplebar', 'init');\n\t  };\n\n\t  _proto.setAccessibilityAttributes = function setAccessibilityAttributes() {\n\t    var ariaLabel = this.options.ariaLabel || 'scrollable content';\n\t    this.contentWrapperEl.setAttribute('tabindex', '0');\n\t    this.contentWrapperEl.setAttribute('role', 'region');\n\t    this.contentWrapperEl.setAttribute('aria-label', ariaLabel);\n\t  };\n\n\t  _proto.initListeners = function initListeners() {\n\t    var _this3 = this;\n\n\t    var elWindow = getElementWindow(this.el); // Event listeners\n\n\t    if (this.options.autoHide) {\n\t      this.el.addEventListener('mouseenter', this.onMouseEnter);\n\t    }\n\n\t    ['mousedown', 'click', 'dblclick'].forEach(function (e) {\n\t      _this3.el.addEventListener(e, _this3.onPointerEvent, true);\n\t    });\n\t    ['touchstart', 'touchend', 'touchmove'].forEach(function (e) {\n\t      _this3.el.addEventListener(e, _this3.onPointerEvent, {\n\t        capture: true,\n\t        passive: true\n\t      });\n\t    });\n\t    this.el.addEventListener('mousemove', this.onMouseMove);\n\t    this.el.addEventListener('mouseleave', this.onMouseLeave);\n\t    this.contentWrapperEl.addEventListener('scroll', this.onScroll); // Browser zoom triggers a window resize\n\n\t    elWindow.addEventListener('resize', this.onWindowResize); // Hack for https://github.com/WICG/ResizeObserver/issues/38\n\n\t    var resizeObserverStarted = false;\n\t    var resizeAnimationFrameId = null;\n\t    var resizeObserver = elWindow.ResizeObserver || ResizeObserver;\n\t    this.resizeObserver = new resizeObserver(function () {\n\t      if (!resizeObserverStarted || resizeAnimationFrameId !== null) return;\n\t      resizeAnimationFrameId = elWindow.requestAnimationFrame(function () {\n\t        _this3.recalculate();\n\n\t        resizeAnimationFrameId = null;\n\t      });\n\t    });\n\t    this.resizeObserver.observe(this.el);\n\t    this.resizeObserver.observe(this.contentEl);\n\t    elWindow.requestAnimationFrame(function () {\n\t      resizeObserverStarted = true;\n\t    }); // This is required to detect horizontal scroll. Vertical scroll only needs the resizeObserver.\n\n\t    this.mutationObserver = new elWindow.MutationObserver(this.recalculate);\n\t    this.mutationObserver.observe(this.contentEl, {\n\t      childList: true,\n\t      subtree: true,\n\t      characterData: true\n\t    });\n\t  };\n\n\t  _proto.recalculate = function recalculate() {\n\t    var elWindow = getElementWindow(this.el);\n\t    this.elStyles = elWindow.getComputedStyle(this.el);\n\t    this.isRtl = this.elStyles.direction === 'rtl';\n\t    var isHeightAuto = this.heightAutoObserverEl.offsetHeight <= 1;\n\t    var isWidthAuto = this.heightAutoObserverEl.offsetWidth <= 1;\n\t    var contentElOffsetWidth = this.contentEl.offsetWidth;\n\t    var contentWrapperElOffsetWidth = this.contentWrapperEl.offsetWidth;\n\t    var elOverflowX = this.elStyles.overflowX;\n\t    var elOverflowY = this.elStyles.overflowY;\n\t    this.contentEl.style.padding = this.elStyles.paddingTop + \" \" + this.elStyles.paddingRight + \" \" + this.elStyles.paddingBottom + \" \" + this.elStyles.paddingLeft;\n\t    this.wrapperEl.style.margin = \"-\" + this.elStyles.paddingTop + \" -\" + this.elStyles.paddingRight + \" -\" + this.elStyles.paddingBottom + \" -\" + this.elStyles.paddingLeft;\n\t    var contentElScrollHeight = this.contentEl.scrollHeight;\n\t    var contentElScrollWidth = this.contentEl.scrollWidth;\n\t    this.contentWrapperEl.style.height = isHeightAuto ? 'auto' : '100%'; // Determine placeholder size\n\n\t    this.placeholderEl.style.width = isWidthAuto ? contentElOffsetWidth + \"px\" : 'auto';\n\t    this.placeholderEl.style.height = contentElScrollHeight + \"px\";\n\t    var contentWrapperElOffsetHeight = this.contentWrapperEl.offsetHeight;\n\t    this.axis.x.isOverflowing = contentElScrollWidth > contentElOffsetWidth;\n\t    this.axis.y.isOverflowing = contentElScrollHeight > contentWrapperElOffsetHeight; // Set isOverflowing to false if user explicitely set hidden overflow\n\n\t    this.axis.x.isOverflowing = elOverflowX === 'hidden' ? false : this.axis.x.isOverflowing;\n\t    this.axis.y.isOverflowing = elOverflowY === 'hidden' ? false : this.axis.y.isOverflowing;\n\t    this.axis.x.forceVisible = this.options.forceVisible === 'x' || this.options.forceVisible === true;\n\t    this.axis.y.forceVisible = this.options.forceVisible === 'y' || this.options.forceVisible === true;\n\t    this.hideNativeScrollbar(); // Set isOverflowing to false if scrollbar is not necessary (content is shorter than offset)\n\n\t    var offsetForXScrollbar = this.axis.x.isOverflowing ? this.scrollbarWidth : 0;\n\t    var offsetForYScrollbar = this.axis.y.isOverflowing ? this.scrollbarWidth : 0;\n\t    this.axis.x.isOverflowing = this.axis.x.isOverflowing && contentElScrollWidth > contentWrapperElOffsetWidth - offsetForYScrollbar;\n\t    this.axis.y.isOverflowing = this.axis.y.isOverflowing && contentElScrollHeight > contentWrapperElOffsetHeight - offsetForXScrollbar;\n\t    this.axis.x.scrollbar.size = this.getScrollbarSize('x');\n\t    this.axis.y.scrollbar.size = this.getScrollbarSize('y');\n\t    this.axis.x.scrollbar.el.style.width = this.axis.x.scrollbar.size + \"px\";\n\t    this.axis.y.scrollbar.el.style.height = this.axis.y.scrollbar.size + \"px\";\n\t    this.positionScrollbar('x');\n\t    this.positionScrollbar('y');\n\t    this.toggleTrackVisibility('x');\n\t    this.toggleTrackVisibility('y');\n\t  }\n\t  /**\n\t   * Calculate scrollbar size\n\t   */\n\t  ;\n\n\t  _proto.getScrollbarSize = function getScrollbarSize(axis) {\n\t    if (axis === void 0) {\n\t      axis = 'y';\n\t    }\n\n\t    if (!this.axis[axis].isOverflowing) {\n\t      return 0;\n\t    }\n\n\t    var contentSize = this.contentEl[this.axis[axis].scrollSizeAttr];\n\t    var trackSize = this.axis[axis].track.el[this.axis[axis].offsetSizeAttr];\n\t    var scrollbarSize;\n\t    var scrollbarRatio = trackSize / contentSize; // Calculate new height/position of drag handle.\n\n\t    scrollbarSize = Math.max(~~(scrollbarRatio * trackSize), this.options.scrollbarMinSize);\n\n\t    if (this.options.scrollbarMaxSize) {\n\t      scrollbarSize = Math.min(scrollbarSize, this.options.scrollbarMaxSize);\n\t    }\n\n\t    return scrollbarSize;\n\t  };\n\n\t  _proto.positionScrollbar = function positionScrollbar(axis) {\n\t    if (axis === void 0) {\n\t      axis = 'y';\n\t    }\n\n\t    if (!this.axis[axis].isOverflowing) {\n\t      return;\n\t    }\n\n\t    var contentSize = this.contentWrapperEl[this.axis[axis].scrollSizeAttr];\n\t    var trackSize = this.axis[axis].track.el[this.axis[axis].offsetSizeAttr];\n\t    var hostSize = parseInt(this.elStyles[this.axis[axis].sizeAttr], 10);\n\t    var scrollbar = this.axis[axis].scrollbar;\n\t    var scrollOffset = this.contentWrapperEl[this.axis[axis].scrollOffsetAttr];\n\t    scrollOffset = axis === 'x' && this.isRtl && SimpleBar.getRtlHelpers().isRtlScrollingInverted ? -scrollOffset : scrollOffset;\n\t    var scrollPourcent = scrollOffset / (contentSize - hostSize);\n\t    var handleOffset = ~~((trackSize - scrollbar.size) * scrollPourcent);\n\t    handleOffset = axis === 'x' && this.isRtl && SimpleBar.getRtlHelpers().isRtlScrollbarInverted ? handleOffset + (trackSize - scrollbar.size) : handleOffset;\n\t    scrollbar.el.style.transform = axis === 'x' ? \"translate3d(\" + handleOffset + \"px, 0, 0)\" : \"translate3d(0, \" + handleOffset + \"px, 0)\";\n\t  };\n\n\t  _proto.toggleTrackVisibility = function toggleTrackVisibility(axis) {\n\t    if (axis === void 0) {\n\t      axis = 'y';\n\t    }\n\n\t    var track = this.axis[axis].track.el;\n\t    var scrollbar = this.axis[axis].scrollbar.el;\n\n\t    if (this.axis[axis].isOverflowing || this.axis[axis].forceVisible) {\n\t      track.style.visibility = 'visible';\n\t      this.contentWrapperEl.style[this.axis[axis].overflowAttr] = 'scroll';\n\t    } else {\n\t      track.style.visibility = 'hidden';\n\t      this.contentWrapperEl.style[this.axis[axis].overflowAttr] = 'hidden';\n\t    } // Even if forceVisible is enabled, scrollbar itself should be hidden\n\n\n\t    if (this.axis[axis].isOverflowing) {\n\t      scrollbar.style.display = 'block';\n\t    } else {\n\t      scrollbar.style.display = 'none';\n\t    }\n\t  };\n\n\t  _proto.hideNativeScrollbar = function hideNativeScrollbar() {\n\t    this.offsetEl.style[this.isRtl ? 'left' : 'right'] = this.axis.y.isOverflowing || this.axis.y.forceVisible ? \"-\" + this.scrollbarWidth + \"px\" : 0;\n\t    this.offsetEl.style.bottom = this.axis.x.isOverflowing || this.axis.x.forceVisible ? \"-\" + this.scrollbarWidth + \"px\" : 0;\n\t  }\n\t  /**\n\t   * On scroll event handling\n\t   */\n\t  ;\n\n\t  _proto.onMouseMoveForAxis = function onMouseMoveForAxis(axis) {\n\t    if (axis === void 0) {\n\t      axis = 'y';\n\t    }\n\n\t    this.axis[axis].track.rect = this.axis[axis].track.el.getBoundingClientRect();\n\t    this.axis[axis].scrollbar.rect = this.axis[axis].scrollbar.el.getBoundingClientRect();\n\t    var isWithinScrollbarBoundsX = this.isWithinBounds(this.axis[axis].scrollbar.rect);\n\n\t    if (isWithinScrollbarBoundsX) {\n\t      this.axis[axis].scrollbar.el.classList.add(this.classNames.hover);\n\t    } else {\n\t      this.axis[axis].scrollbar.el.classList.remove(this.classNames.hover);\n\t    }\n\n\t    if (this.isWithinBounds(this.axis[axis].track.rect)) {\n\t      this.showScrollbar(axis);\n\t      this.axis[axis].track.el.classList.add(this.classNames.hover);\n\t    } else {\n\t      this.axis[axis].track.el.classList.remove(this.classNames.hover);\n\t    }\n\t  };\n\n\t  _proto.onMouseLeaveForAxis = function onMouseLeaveForAxis(axis) {\n\t    if (axis === void 0) {\n\t      axis = 'y';\n\t    }\n\n\t    this.axis[axis].track.el.classList.remove(this.classNames.hover);\n\t    this.axis[axis].scrollbar.el.classList.remove(this.classNames.hover);\n\t  };\n\n\t  /**\n\t   * Show scrollbar\n\t   */\n\t  _proto.showScrollbar = function showScrollbar(axis) {\n\t    if (axis === void 0) {\n\t      axis = 'y';\n\t    }\n\n\t    var scrollbar = this.axis[axis].scrollbar.el;\n\n\t    if (!this.axis[axis].isVisible) {\n\t      scrollbar.classList.add(this.classNames.visible);\n\t      this.axis[axis].isVisible = true;\n\t    }\n\n\t    if (this.options.autoHide) {\n\t      this.hideScrollbars();\n\t    }\n\t  }\n\t  /**\n\t   * Hide Scrollbar\n\t   */\n\t  ;\n\n\t  /**\n\t   * on scrollbar handle drag movement starts\n\t   */\n\t  _proto.onDragStart = function onDragStart(e, axis) {\n\t    if (axis === void 0) {\n\t      axis = 'y';\n\t    }\n\n\t    var elDocument = getElementDocument(this.el);\n\t    var elWindow = getElementWindow(this.el);\n\t    var scrollbar = this.axis[axis].scrollbar; // Measure how far the user's mouse is from the top of the scrollbar drag handle.\n\n\t    var eventOffset = axis === 'y' ? e.pageY : e.pageX;\n\t    this.axis[axis].dragOffset = eventOffset - scrollbar.rect[this.axis[axis].offsetAttr];\n\t    this.draggedAxis = axis;\n\t    this.el.classList.add(this.classNames.dragging);\n\t    elDocument.addEventListener('mousemove', this.drag, true);\n\t    elDocument.addEventListener('mouseup', this.onEndDrag, true);\n\n\t    if (this.removePreventClickId === null) {\n\t      elDocument.addEventListener('click', this.preventClick, true);\n\t      elDocument.addEventListener('dblclick', this.preventClick, true);\n\t    } else {\n\t      elWindow.clearTimeout(this.removePreventClickId);\n\t      this.removePreventClickId = null;\n\t    }\n\t  }\n\t  /**\n\t   * Drag scrollbar handle\n\t   */\n\t  ;\n\n\t  _proto.onTrackClick = function onTrackClick(e, axis) {\n\t    var _this4 = this;\n\n\t    if (axis === void 0) {\n\t      axis = 'y';\n\t    }\n\n\t    if (!this.options.clickOnTrack) return;\n\t    var elWindow = getElementWindow(this.el);\n\t    this.axis[axis].scrollbar.rect = this.axis[axis].scrollbar.el.getBoundingClientRect();\n\t    var scrollbar = this.axis[axis].scrollbar;\n\t    var scrollbarOffset = scrollbar.rect[this.axis[axis].offsetAttr];\n\t    var hostSize = parseInt(this.elStyles[this.axis[axis].sizeAttr], 10);\n\t    var scrolled = this.contentWrapperEl[this.axis[axis].scrollOffsetAttr];\n\t    var t = axis === 'y' ? this.mouseY - scrollbarOffset : this.mouseX - scrollbarOffset;\n\t    var dir = t < 0 ? -1 : 1;\n\t    var scrollSize = dir === -1 ? scrolled - hostSize : scrolled + hostSize;\n\n\t    var scrollTo = function scrollTo() {\n\t      if (dir === -1) {\n\t        if (scrolled > scrollSize) {\n\t          var _this4$contentWrapper;\n\n\t          scrolled -= _this4.options.clickOnTrackSpeed;\n\n\t          _this4.contentWrapperEl.scrollTo((_this4$contentWrapper = {}, _this4$contentWrapper[_this4.axis[axis].offsetAttr] = scrolled, _this4$contentWrapper));\n\n\t          elWindow.requestAnimationFrame(scrollTo);\n\t        }\n\t      } else {\n\t        if (scrolled < scrollSize) {\n\t          var _this4$contentWrapper2;\n\n\t          scrolled += _this4.options.clickOnTrackSpeed;\n\n\t          _this4.contentWrapperEl.scrollTo((_this4$contentWrapper2 = {}, _this4$contentWrapper2[_this4.axis[axis].offsetAttr] = scrolled, _this4$contentWrapper2));\n\n\t          elWindow.requestAnimationFrame(scrollTo);\n\t        }\n\t      }\n\t    };\n\n\t    scrollTo();\n\t  }\n\t  /**\n\t   * Getter for content element\n\t   */\n\t  ;\n\n\t  _proto.getContentElement = function getContentElement() {\n\t    return this.contentEl;\n\t  }\n\t  /**\n\t   * Getter for original scrolling element\n\t   */\n\t  ;\n\n\t  _proto.getScrollElement = function getScrollElement() {\n\t    return this.contentWrapperEl;\n\t  };\n\n\t  _proto.getScrollbarWidth = function getScrollbarWidth() {\n\t    // Try/catch for FF 56 throwing on undefined computedStyles\n\t    try {\n\t      // Detect browsers supporting CSS scrollbar styling and do not calculate\n\t      if (getComputedStyle(this.contentWrapperEl, '::-webkit-scrollbar').display === 'none' || 'scrollbarWidth' in document.documentElement.style || '-ms-overflow-style' in document.documentElement.style) {\n\t        return 0;\n\t      } else {\n\t        return scrollbarWidth(this.el);\n\t      }\n\t    } catch (e) {\n\t      return scrollbarWidth(this.el);\n\t    }\n\t  };\n\n\t  _proto.removeListeners = function removeListeners() {\n\t    var _this5 = this;\n\n\t    var elWindow = getElementWindow(this.el); // Event listeners\n\n\t    if (this.options.autoHide) {\n\t      this.el.removeEventListener('mouseenter', this.onMouseEnter);\n\t    }\n\n\t    ['mousedown', 'click', 'dblclick'].forEach(function (e) {\n\t      _this5.el.removeEventListener(e, _this5.onPointerEvent, true);\n\t    });\n\t    ['touchstart', 'touchend', 'touchmove'].forEach(function (e) {\n\t      _this5.el.removeEventListener(e, _this5.onPointerEvent, {\n\t        capture: true,\n\t        passive: true\n\t      });\n\t    });\n\t    this.el.removeEventListener('mousemove', this.onMouseMove);\n\t    this.el.removeEventListener('mouseleave', this.onMouseLeave);\n\n\t    if (this.contentWrapperEl) {\n\t      this.contentWrapperEl.removeEventListener('scroll', this.onScroll);\n\t    }\n\n\t    elWindow.removeEventListener('resize', this.onWindowResize);\n\n\t    if (this.mutationObserver) {\n\t      this.mutationObserver.disconnect();\n\t    }\n\n\t    if (this.resizeObserver) {\n\t      this.resizeObserver.disconnect();\n\t    } // Cancel all debounced functions\n\n\n\t    this.recalculate.cancel();\n\t    this.onMouseMove.cancel();\n\t    this.hideScrollbars.cancel();\n\t    this.onWindowResize.cancel();\n\t  }\n\t  /**\n\t   * UnMount mutation observer and delete SimpleBar instance from DOM element\n\t   */\n\t  ;\n\n\t  _proto.unMount = function unMount() {\n\t    this.removeListeners();\n\t    SimpleBar.instances.delete(this.el);\n\t  }\n\t  /**\n\t   * Check if mouse is within bounds\n\t   */\n\t  ;\n\n\t  _proto.isWithinBounds = function isWithinBounds(bbox) {\n\t    return this.mouseX >= bbox.left && this.mouseX <= bbox.left + bbox.width && this.mouseY >= bbox.top && this.mouseY <= bbox.top + bbox.height;\n\t  }\n\t  /**\n\t   * Find element children matches query\n\t   */\n\t  ;\n\n\t  _proto.findChild = function findChild(el, query) {\n\t    var matches = el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector;\n\t    return Array.prototype.filter.call(el.children, function (child) {\n\t      return matches.call(child, query);\n\t    })[0];\n\t  };\n\n\t  return SimpleBar;\n\t}();\n\n\tSimpleBar.defaultOptions = {\n\t  autoHide: true,\n\t  forceVisible: false,\n\t  clickOnTrack: true,\n\t  clickOnTrackSpeed: 40,\n\t  classNames: {\n\t    contentEl: 'simplebar-content',\n\t    contentWrapper: 'simplebar-content-wrapper',\n\t    offset: 'simplebar-offset',\n\t    mask: 'simplebar-mask',\n\t    wrapper: 'simplebar-wrapper',\n\t    placeholder: 'simplebar-placeholder',\n\t    scrollbar: 'simplebar-scrollbar',\n\t    track: 'simplebar-track',\n\t    heightAutoObserverWrapperEl: 'simplebar-height-auto-observer-wrapper',\n\t    heightAutoObserverEl: 'simplebar-height-auto-observer',\n\t    visible: 'simplebar-visible',\n\t    horizontal: 'simplebar-horizontal',\n\t    vertical: 'simplebar-vertical',\n\t    hover: 'simplebar-hover',\n\t    dragging: 'simplebar-dragging'\n\t  },\n\t  scrollbarMinSize: 25,\n\t  scrollbarMaxSize: 0,\n\t  timeout: 1000\n\t};\n\tSimpleBar.instances = new WeakMap();\n\n\tSimpleBar.initDOMLoadedElements = function () {\n\t  document.removeEventListener('DOMContentLoaded', this.initDOMLoadedElements);\n\t  window.removeEventListener('load', this.initDOMLoadedElements);\n\t  Array.prototype.forEach.call(document.querySelectorAll('[data-simplebar]'), function (el) {\n\t    if (el.getAttribute('data-simplebar') !== 'init' && !SimpleBar.instances.has(el)) new SimpleBar(el, getOptions(el.attributes));\n\t  });\n\t};\n\n\tSimpleBar.removeObserver = function () {\n\t  this.globalObserver.disconnect();\n\t};\n\n\tSimpleBar.initHtmlApi = function () {\n\t  this.initDOMLoadedElements = this.initDOMLoadedElements.bind(this); // MutationObserver is IE11+\n\n\t  if (typeof MutationObserver !== 'undefined') {\n\t    // Mutation observer to observe dynamically added elements\n\t    this.globalObserver = new MutationObserver(SimpleBar.handleMutations);\n\t    this.globalObserver.observe(document, {\n\t      childList: true,\n\t      subtree: true\n\t    });\n\t  } // Taken from jQuery `ready` function\n\t  // Instantiate elements already present on the page\n\n\n\t  if (document.readyState === 'complete' || document.readyState !== 'loading' && !document.documentElement.doScroll) {\n\t    // Handle it asynchronously to allow scripts the opportunity to delay init\n\t    window.setTimeout(this.initDOMLoadedElements);\n\t  } else {\n\t    document.addEventListener('DOMContentLoaded', this.initDOMLoadedElements);\n\t    window.addEventListener('load', this.initDOMLoadedElements);\n\t  }\n\t};\n\n\tSimpleBar.handleMutations = function (mutations) {\n\t  mutations.forEach(function (mutation) {\n\t    Array.prototype.forEach.call(mutation.addedNodes, function (addedNode) {\n\t      if (addedNode.nodeType === 1) {\n\t        if (addedNode.hasAttribute('data-simplebar')) {\n\t          !SimpleBar.instances.has(addedNode) && document.documentElement.contains(addedNode) && new SimpleBar(addedNode, getOptions(addedNode.attributes));\n\t        } else {\n\t          Array.prototype.forEach.call(addedNode.querySelectorAll('[data-simplebar]'), function (el) {\n\t            if (el.getAttribute('data-simplebar') !== 'init' && !SimpleBar.instances.has(el) && document.documentElement.contains(el)) new SimpleBar(el, getOptions(el.attributes));\n\t          });\n\t        }\n\t      }\n\t    });\n\t    Array.prototype.forEach.call(mutation.removedNodes, function (removedNode) {\n\t      if (removedNode.nodeType === 1) {\n\t        if (removedNode.getAttribute('data-simplebar') === 'init') {\n\t          SimpleBar.instances.has(removedNode) && !document.documentElement.contains(removedNode) && SimpleBar.instances.get(removedNode).unMount();\n\t        } else {\n\t          Array.prototype.forEach.call(removedNode.querySelectorAll('[data-simplebar=\"init\"]'), function (el) {\n\t            SimpleBar.instances.has(el) && !document.documentElement.contains(el) && SimpleBar.instances.get(el).unMount();\n\t          });\n\t        }\n\t      }\n\t    });\n\t  });\n\t};\n\n\tSimpleBar.getOptions = getOptions;\n\t/**\n\t * HTML API\n\t * Called only in a browser env.\n\t */\n\n\tif (canUseDom) {\n\t  SimpleBar.initHtmlApi();\n\t}\n\n\treturn SimpleBar;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2ltcGxlYmFyL2Rpc3Qvc2ltcGxlYmFyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLEtBQTREO0FBQzdELENBQUMsQ0FDdUQ7QUFDeEQsQ0FBQyxzQkFBc0I7O0FBRXZCLHVIQUF1SCxxQkFBTSxtQkFBbUIscUJBQU07O0FBRXRKO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsa0RBQWtEO0FBQ3ZGLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLGdFQUFnRTs7QUFFaEU7O0FBRUE7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRixFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixhQUFhO0FBQzFDO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVEsV0FBVztBQUMvQixZQUFZLFNBQVM7QUFDckI7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnREFBZ0QsaUJBQWlCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVEsV0FBVztBQUMvQixZQUFZLFNBQVM7QUFDckI7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELG1CQUFtQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxHQUFHO0FBQ2YsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEdBQUc7QUFDZixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxHQUFHO0FBQ2YsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksR0FBRztBQUNmLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVEsV0FBVztBQUMvQixZQUFZLFNBQVM7QUFDckI7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnREFBZ0QsaUJBQWlCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxHQUFHO0FBQ2YsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEdBQUc7QUFDZixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxHQUFHO0FBQ2YsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksR0FBRztBQUNmLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsR0FBRztBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksR0FBRztBQUNmLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFF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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUYsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLGtDQUFrQztBQUNsQyxpQ0FBaUM7QUFDakMsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Vyx3Q0FBd0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHNFQUFzRTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7Ozs7Ozs7QUFRQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQkFBMEI7QUFDL0M7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZ0VBQWdFO0FBQzNFO0FBQ0EsRUFBRTs7QUFFRjs7Ozs7Ozs7O0FBU0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLG1CQUFtQjs7QUFFaEQ7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGdCQUFnQjtBQUNoQixNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxJQUFJO0FBQzlDLG1EQUFtRCxJQUFJOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFD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O0FBQ0E7QUFDQSxtREFBbUQ7O0FBRW5EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUVBQXVFOztBQUV2RTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUEsd0VBQXdFOztBQUV4RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUVBQXVFOztBQUV2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3NpbXBsZWJhci9kaXN0L3NpbXBsZWJhci5qcz8yYTU0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU2ltcGxlQmFyLmpzIC0gdjUuMy45XG4gKiBTY3JvbGxiYXJzLCBzaW1wbGVyLlxuICogaHR0cHM6Ly9ncnNtdG8uZ2l0aHViLmlvL3NpbXBsZWJhci9cbiAqXG4gKiBNYWRlIGJ5IEFkcmllbiBEZW5hdCBmcm9tIGEgZm9yayBieSBKb25hdGhhbiBOaWNvbFxuICogVW5kZXIgTUlUIExpY2Vuc2VcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLlNpbXBsZUJhciA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuXHR2YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuXHRmdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG5cdFx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xuXHR9XG5cblx0dmFyIGNoZWNrID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgcmV0dXJuIGl0ICYmIGl0Lk1hdGggPT0gTWF0aCAmJiBpdDtcblx0fTtcblxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxuXHR2YXIgZ2xvYmFsXzEgPVxuXHQgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLWdsb2JhbC10aGlzIC0tIHNhZmVcblx0ICBjaGVjayh0eXBlb2YgZ2xvYmFsVGhpcyA9PSAnb2JqZWN0JyAmJiBnbG9iYWxUaGlzKSB8fFxuXHQgIGNoZWNrKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93KSB8fFxuXHQgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgLS0gc2FmZVxuXHQgIGNoZWNrKHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYpIHx8XG5cdCAgY2hlY2sodHlwZW9mIGNvbW1vbmpzR2xvYmFsID09ICdvYmplY3QnICYmIGNvbW1vbmpzR2xvYmFsKSB8fFxuXHQgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYyAtLSBmYWxsYmFja1xuXHQgIChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSgpIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcblx0dmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5cdHZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cdCAgdHJ5IHtcblx0ICAgIGRlZmluZVByb3BlcnR5KGdsb2JhbF8xLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pO1xuXHQgIH0gY2F0Y2ggKGVycm9yKSB7XG5cdCAgICBnbG9iYWxfMVtrZXldID0gdmFsdWU7XG5cdCAgfSByZXR1cm4gdmFsdWU7XG5cdH07XG5cblx0dmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xuXHR2YXIgc3RvcmUgPSBnbG9iYWxfMVtTSEFSRURdIHx8IGRlZmluZUdsb2JhbFByb3BlcnR5KFNIQVJFRCwge30pO1xuXG5cdHZhciBzaGFyZWRTdG9yZSA9IHN0b3JlO1xuXG5cdHZhciBzaGFyZWQgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5cdChtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cdCAgcmV0dXJuIHNoYXJlZFN0b3JlW2tleV0gfHwgKHNoYXJlZFN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG5cdH0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcblx0ICB2ZXJzaW9uOiAnMy4yMi42Jyxcblx0ICBtb2RlOiAgJ2dsb2JhbCcsXG5cdCAgY29weXJpZ2h0OiAnwqkgMjAxNC0yMDIyIERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJyxcblx0ICBsaWNlbnNlOiAnaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvYmxvYi92My4yMi42L0xJQ0VOU0UnLFxuXHQgIHNvdXJjZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzJ1xuXHR9KTtcblx0fSk7XG5cblx0dmFyIGZhaWxzID0gZnVuY3Rpb24gKGV4ZWMpIHtcblx0ICB0cnkge1xuXHQgICAgcmV0dXJuICEhZXhlYygpO1xuXHQgIH0gY2F0Y2ggKGVycm9yKSB7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9XG5cdH07XG5cblx0dmFyIGZ1bmN0aW9uQmluZE5hdGl2ZSA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG5cdCAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tZnVuY3Rpb24tcHJvdG90eXBlLWJpbmQgLS0gc2FmZVxuXHQgIHZhciB0ZXN0ID0gKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSkuYmluZCgpO1xuXHQgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuXHQgIHJldHVybiB0eXBlb2YgdGVzdCAhPSAnZnVuY3Rpb24nIHx8IHRlc3QuaGFzT3duUHJvcGVydHkoJ3Byb3RvdHlwZScpO1xuXHR9KTtcblxuXHR2YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cdHZhciBiaW5kID0gRnVuY3Rpb25Qcm90b3R5cGUuYmluZDtcblx0dmFyIGNhbGwgPSBGdW5jdGlvblByb3RvdHlwZS5jYWxsO1xuXHR2YXIgdW5jdXJyeVRoaXMgPSBmdW5jdGlvbkJpbmROYXRpdmUgJiYgYmluZC5iaW5kKGNhbGwsIGNhbGwpO1xuXG5cdHZhciBmdW5jdGlvblVuY3VycnlUaGlzID0gZnVuY3Rpb25CaW5kTmF0aXZlID8gZnVuY3Rpb24gKGZuKSB7XG5cdCAgcmV0dXJuIGZuICYmIHVuY3VycnlUaGlzKGZuKTtcblx0fSA6IGZ1bmN0aW9uIChmbikge1xuXHQgIHJldHVybiBmbiAmJiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gY2FsbC5hcHBseShmbiwgYXJndW1lbnRzKTtcblx0ICB9O1xuXHR9O1xuXG5cdHZhciBUeXBlRXJyb3IkMSA9IGdsb2JhbF8xLlR5cGVFcnJvcjtcblxuXHQvLyBgUmVxdWlyZU9iamVjdENvZXJjaWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG5cdC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVxdWlyZW9iamVjdGNvZXJjaWJsZVxuXHR2YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IGZ1bmN0aW9uIChpdCkge1xuXHQgIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvciQxKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gXCIgKyBpdCk7XG5cdCAgcmV0dXJuIGl0O1xuXHR9O1xuXG5cdHZhciBPYmplY3QkMSA9IGdsb2JhbF8xLk9iamVjdDtcblxuXHQvLyBgVG9PYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuXHQvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvb2JqZWN0XG5cdHZhciB0b09iamVjdCA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuXHQgIHJldHVybiBPYmplY3QkMShyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KSk7XG5cdH07XG5cblx0dmFyIGhhc093blByb3BlcnR5ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcyh7fS5oYXNPd25Qcm9wZXJ0eSk7XG5cblx0Ly8gYEhhc093blByb3BlcnR5YCBhYnN0cmFjdCBvcGVyYXRpb25cblx0Ly8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1oYXNvd25wcm9wZXJ0eVxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtaGFzb3duIC0tIHNhZmVcblx0dmFyIGhhc093blByb3BlcnR5XzEgPSBPYmplY3QuaGFzT3duIHx8IGZ1bmN0aW9uIGhhc093bihpdCwga2V5KSB7XG5cdCAgcmV0dXJuIGhhc093blByb3BlcnR5KHRvT2JqZWN0KGl0KSwga2V5KTtcblx0fTtcblxuXHR2YXIgaWQgPSAwO1xuXHR2YXIgcG9zdGZpeCA9IE1hdGgucmFuZG9tKCk7XG5cdHZhciB0b1N0cmluZyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXMoMS4wLnRvU3RyaW5nKTtcblxuXHR2YXIgdWlkID0gZnVuY3Rpb24gKGtleSkge1xuXHQgIHJldHVybiAnU3ltYm9sKCcgKyAoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSkgKyAnKV8nICsgdG9TdHJpbmcoKytpZCArIHBvc3RmaXgsIDM2KTtcblx0fTtcblxuXHQvLyBgSXNDYWxsYWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG5cdC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNjYWxsYWJsZVxuXHR2YXIgaXNDYWxsYWJsZSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuXHQgIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT0gJ2Z1bmN0aW9uJztcblx0fTtcblxuXHR2YXIgYUZ1bmN0aW9uID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG5cdCAgcmV0dXJuIGlzQ2FsbGFibGUoYXJndW1lbnQpID8gYXJndW1lbnQgOiB1bmRlZmluZWQ7XG5cdH07XG5cblx0dmFyIGdldEJ1aWx0SW4gPSBmdW5jdGlvbiAobmFtZXNwYWNlLCBtZXRob2QpIHtcblx0ICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBhRnVuY3Rpb24oZ2xvYmFsXzFbbmFtZXNwYWNlXSkgOiBnbG9iYWxfMVtuYW1lc3BhY2VdICYmIGdsb2JhbF8xW25hbWVzcGFjZV1bbWV0aG9kXTtcblx0fTtcblxuXHR2YXIgZW5naW5lVXNlckFnZW50ID0gZ2V0QnVpbHRJbignbmF2aWdhdG9yJywgJ3VzZXJBZ2VudCcpIHx8ICcnO1xuXG5cdHZhciBwcm9jZXNzID0gZ2xvYmFsXzEucHJvY2Vzcztcblx0dmFyIERlbm8gPSBnbG9iYWxfMS5EZW5vO1xuXHR2YXIgdmVyc2lvbnMgPSBwcm9jZXNzICYmIHByb2Nlc3MudmVyc2lvbnMgfHwgRGVubyAmJiBEZW5vLnZlcnNpb247XG5cdHZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4O1xuXHR2YXIgbWF0Y2gsIHZlcnNpb247XG5cblx0aWYgKHY4KSB7XG5cdCAgbWF0Y2ggPSB2OC5zcGxpdCgnLicpO1xuXHQgIC8vIGluIG9sZCBDaHJvbWUsIHZlcnNpb25zIG9mIFY4IGlzbid0IFY4ID0gQ2hyb21lIC8gMTBcblx0ICAvLyBidXQgdGhlaXIgY29ycmVjdCB2ZXJzaW9ucyBhcmUgbm90IGludGVyZXN0aW5nIGZvciB1c1xuXHQgIHZlcnNpb24gPSBtYXRjaFswXSA+IDAgJiYgbWF0Y2hbMF0gPCA0ID8gMSA6ICsobWF0Y2hbMF0gKyBtYXRjaFsxXSk7XG5cdH1cblxuXHQvLyBCcm93c2VyRlMgTm9kZUpTIGBwcm9jZXNzYCBwb2x5ZmlsbCBpbmNvcnJlY3RseSBzZXQgYC52OGAgdG8gYDAuMGBcblx0Ly8gc28gY2hlY2sgYHVzZXJBZ2VudGAgZXZlbiBpZiBgLnY4YCBleGlzdHMsIGJ1dCAwXG5cdGlmICghdmVyc2lvbiAmJiBlbmdpbmVVc2VyQWdlbnQpIHtcblx0ICBtYXRjaCA9IGVuZ2luZVVzZXJBZ2VudC5tYXRjaCgvRWRnZVxcLyhcXGQrKS8pO1xuXHQgIGlmICghbWF0Y2ggfHwgbWF0Y2hbMV0gPj0gNzQpIHtcblx0ICAgIG1hdGNoID0gZW5naW5lVXNlckFnZW50Lm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKTtcblx0ICAgIGlmIChtYXRjaCkgdmVyc2lvbiA9ICttYXRjaFsxXTtcblx0ICB9XG5cdH1cblxuXHR2YXIgZW5naW5lVjhWZXJzaW9uID0gdmVyc2lvbjtcblxuXHQvKiBlc2xpbnQtZGlzYWJsZSBlcy14L25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xuXG5cblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG5cdHZhciBuYXRpdmVTeW1ib2wgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7XG5cdCAgLy8gQ2hyb21lIDM4IFN5bWJvbCBoYXMgaW5jb3JyZWN0IHRvU3RyaW5nIGNvbnZlcnNpb25cblx0ICAvLyBgZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzYCBwb2x5ZmlsbCBzeW1ib2xzIGNvbnZlcnRlZCB0byBvYmplY3QgYXJlIG5vdCBTeW1ib2wgaW5zdGFuY2VzXG5cdCAgcmV0dXJuICFTdHJpbmcoc3ltYm9sKSB8fCAhKE9iamVjdChzeW1ib2wpIGluc3RhbmNlb2YgU3ltYm9sKSB8fFxuXHQgICAgLy8gQ2hyb21lIDM4LTQwIHN5bWJvbHMgYXJlIG5vdCBpbmhlcml0ZWQgZnJvbSBET00gY29sbGVjdGlvbnMgcHJvdG90eXBlcyB0byBpbnN0YW5jZXNcblx0ICAgICFTeW1ib2wuc2hhbSAmJiBlbmdpbmVWOFZlcnNpb24gJiYgZW5naW5lVjhWZXJzaW9uIDwgNDE7XG5cdH0pO1xuXG5cdC8qIGVzbGludC1kaXNhYmxlIGVzLXgvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG5cblxuXHR2YXIgdXNlU3ltYm9sQXNVaWQgPSBuYXRpdmVTeW1ib2xcblx0ICAmJiAhU3ltYm9sLnNoYW1cblx0ICAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnO1xuXG5cdHZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUgPSBzaGFyZWQoJ3drcycpO1xuXHR2YXIgU3ltYm9sJDEgPSBnbG9iYWxfMS5TeW1ib2w7XG5cdHZhciBzeW1ib2xGb3IgPSBTeW1ib2wkMSAmJiBTeW1ib2wkMVsnZm9yJ107XG5cdHZhciBjcmVhdGVXZWxsS25vd25TeW1ib2wgPSB1c2VTeW1ib2xBc1VpZCA/IFN5bWJvbCQxIDogU3ltYm9sJDEgJiYgU3ltYm9sJDEud2l0aG91dFNldHRlciB8fCB1aWQ7XG5cblx0dmFyIHdlbGxLbm93blN5bWJvbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdCAgaWYgKCFoYXNPd25Qcm9wZXJ0eV8xKFdlbGxLbm93blN5bWJvbHNTdG9yZSwgbmFtZSkgfHwgIShuYXRpdmVTeW1ib2wgfHwgdHlwZW9mIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9PSAnc3RyaW5nJykpIHtcblx0ICAgIHZhciBkZXNjcmlwdGlvbiA9ICdTeW1ib2wuJyArIG5hbWU7XG5cdCAgICBpZiAobmF0aXZlU3ltYm9sICYmIGhhc093blByb3BlcnR5XzEoU3ltYm9sJDEsIG5hbWUpKSB7XG5cdCAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IFN5bWJvbCQxW25hbWVdO1xuXHQgICAgfSBlbHNlIGlmICh1c2VTeW1ib2xBc1VpZCAmJiBzeW1ib2xGb3IpIHtcblx0ICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gc3ltYm9sRm9yKGRlc2NyaXB0aW9uKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IGNyZWF0ZVdlbGxLbm93blN5bWJvbChkZXNjcmlwdGlvbik7XG5cdCAgICB9XG5cdCAgfSByZXR1cm4gV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdO1xuXHR9O1xuXG5cdHZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xuXHR2YXIgdGVzdCA9IHt9O1xuXG5cdHRlc3RbVE9fU1RSSU5HX1RBR10gPSAneic7XG5cblx0dmFyIHRvU3RyaW5nVGFnU3VwcG9ydCA9IFN0cmluZyh0ZXN0KSA9PT0gJ1tvYmplY3Qgel0nO1xuXG5cdC8vIERldGVjdCBJRTgncyBpbmNvbXBsZXRlIGRlZmluZVByb3BlcnR5IGltcGxlbWVudGF0aW9uXG5cdHZhciBkZXNjcmlwdG9ycyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG5cdCAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG5cdCAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgMSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSlbMV0gIT0gNztcblx0fSk7XG5cblx0dmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogaXNDYWxsYWJsZShpdCk7XG5cdH07XG5cblx0dmFyIGRvY3VtZW50JDEgPSBnbG9iYWxfMS5kb2N1bWVudDtcblx0Ly8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG5cdHZhciBFWElTVFMgPSBpc09iamVjdChkb2N1bWVudCQxKSAmJiBpc09iamVjdChkb2N1bWVudCQxLmNyZWF0ZUVsZW1lbnQpO1xuXG5cdHZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoaXQpIHtcblx0ICByZXR1cm4gRVhJU1RTID8gZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xuXHR9O1xuXG5cdC8vIFRoYW5rcyB0byBJRTggZm9yIGl0cyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxuXHR2YXIgaWU4RG9tRGVmaW5lID0gIWRlc2NyaXB0b3JzICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG5cdCAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG5cdCAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkb2N1bWVudENyZWF0ZUVsZW1lbnQoJ2RpdicpLCAnYScsIHtcblx0ICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfVxuXHQgIH0pLmEgIT0gNztcblx0fSk7XG5cblx0Ly8gVjggfiBDaHJvbWUgMzYtXG5cdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMzMzRcblx0dmFyIHY4UHJvdG90eXBlRGVmaW5lQnVnID0gZGVzY3JpcHRvcnMgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuXHQgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuXHQgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAncHJvdG90eXBlJywge1xuXHQgICAgdmFsdWU6IDQyLFxuXHQgICAgd3JpdGFibGU6IGZhbHNlXG5cdCAgfSkucHJvdG90eXBlICE9IDQyO1xuXHR9KTtcblxuXHR2YXIgU3RyaW5nJDEgPSBnbG9iYWxfMS5TdHJpbmc7XG5cdHZhciBUeXBlRXJyb3IkMiA9IGdsb2JhbF8xLlR5cGVFcnJvcjtcblxuXHQvLyBgQXNzZXJ0OiBUeXBlKGFyZ3VtZW50KSBpcyBPYmplY3RgXG5cdHZhciBhbk9iamVjdCA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuXHQgIGlmIChpc09iamVjdChhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcblx0ICB0aHJvdyBUeXBlRXJyb3IkMihTdHJpbmckMShhcmd1bWVudCkgKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcblx0fTtcblxuXHR2YXIgY2FsbCQxID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XG5cblx0dmFyIGZ1bmN0aW9uQ2FsbCA9IGZ1bmN0aW9uQmluZE5hdGl2ZSA/IGNhbGwkMS5iaW5kKGNhbGwkMSkgOiBmdW5jdGlvbiAoKSB7XG5cdCAgcmV0dXJuIGNhbGwkMS5hcHBseShjYWxsJDEsIGFyZ3VtZW50cyk7XG5cdH07XG5cblx0dmFyIG9iamVjdElzUHJvdG90eXBlT2YgPSBmdW5jdGlvblVuY3VycnlUaGlzKHt9LmlzUHJvdG90eXBlT2YpO1xuXG5cdHZhciBPYmplY3QkMiA9IGdsb2JhbF8xLk9iamVjdDtcblxuXHR2YXIgaXNTeW1ib2wgPSB1c2VTeW1ib2xBc1VpZCA/IGZ1bmN0aW9uIChpdCkge1xuXHQgIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG5cdH0gOiBmdW5jdGlvbiAoaXQpIHtcblx0ICB2YXIgJFN5bWJvbCA9IGdldEJ1aWx0SW4oJ1N5bWJvbCcpO1xuXHQgIHJldHVybiBpc0NhbGxhYmxlKCRTeW1ib2wpICYmIG9iamVjdElzUHJvdG90eXBlT2YoJFN5bWJvbC5wcm90b3R5cGUsIE9iamVjdCQyKGl0KSk7XG5cdH07XG5cblx0dmFyIFN0cmluZyQyID0gZ2xvYmFsXzEuU3RyaW5nO1xuXG5cdHZhciB0cnlUb1N0cmluZyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuXHQgIHRyeSB7XG5cdCAgICByZXR1cm4gU3RyaW5nJDIoYXJndW1lbnQpO1xuXHQgIH0gY2F0Y2ggKGVycm9yKSB7XG5cdCAgICByZXR1cm4gJ09iamVjdCc7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBUeXBlRXJyb3IkMyA9IGdsb2JhbF8xLlR5cGVFcnJvcjtcblxuXHQvLyBgQXNzZXJ0OiBJc0NhbGxhYmxlKGFyZ3VtZW50KSBpcyB0cnVlYFxuXHR2YXIgYUNhbGxhYmxlID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG5cdCAgaWYgKGlzQ2FsbGFibGUoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG5cdCAgdGhyb3cgVHlwZUVycm9yJDModHJ5VG9TdHJpbmcoYXJndW1lbnQpICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuXHR9O1xuXG5cdC8vIGBHZXRNZXRob2RgIGFic3RyYWN0IG9wZXJhdGlvblxuXHQvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldG1ldGhvZFxuXHR2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24gKFYsIFApIHtcblx0ICB2YXIgZnVuYyA9IFZbUF07XG5cdCAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGFDYWxsYWJsZShmdW5jKTtcblx0fTtcblxuXHR2YXIgVHlwZUVycm9yJDQgPSBnbG9iYWxfMS5UeXBlRXJyb3I7XG5cblx0Ly8gYE9yZGluYXJ5VG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuXHQvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9yZGluYXJ5dG9wcmltaXRpdmVcblx0dmFyIG9yZGluYXJ5VG9QcmltaXRpdmUgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcblx0ICB2YXIgZm4sIHZhbDtcblx0ICBpZiAocHJlZiA9PT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZShmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QodmFsID0gZnVuY3Rpb25DYWxsKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuXHQgIGlmIChpc0NhbGxhYmxlKGZuID0gaW5wdXQudmFsdWVPZikgJiYgIWlzT2JqZWN0KHZhbCA9IGZ1bmN0aW9uQ2FsbChmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcblx0ICBpZiAocHJlZiAhPT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZShmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QodmFsID0gZnVuY3Rpb25DYWxsKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuXHQgIHRocm93IFR5cGVFcnJvciQ0KFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xuXHR9O1xuXG5cdHZhciBUeXBlRXJyb3IkNSA9IGdsb2JhbF8xLlR5cGVFcnJvcjtcblx0dmFyIFRPX1BSSU1JVElWRSA9IHdlbGxLbm93blN5bWJvbCgndG9QcmltaXRpdmUnKTtcblxuXHQvLyBgVG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuXHQvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXG5cdHZhciB0b1ByaW1pdGl2ZSA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuXHQgIGlmICghaXNPYmplY3QoaW5wdXQpIHx8IGlzU3ltYm9sKGlucHV0KSkgcmV0dXJuIGlucHV0O1xuXHQgIHZhciBleG90aWNUb1ByaW0gPSBnZXRNZXRob2QoaW5wdXQsIFRPX1BSSU1JVElWRSk7XG5cdCAgdmFyIHJlc3VsdDtcblx0ICBpZiAoZXhvdGljVG9QcmltKSB7XG5cdCAgICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ2RlZmF1bHQnO1xuXHQgICAgcmVzdWx0ID0gZnVuY3Rpb25DYWxsKGV4b3RpY1RvUHJpbSwgaW5wdXQsIHByZWYpO1xuXHQgICAgaWYgKCFpc09iamVjdChyZXN1bHQpIHx8IGlzU3ltYm9sKHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG5cdCAgICB0aHJvdyBUeXBlRXJyb3IkNShcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcblx0ICB9XG5cdCAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdudW1iZXInO1xuXHQgIHJldHVybiBvcmRpbmFyeVRvUHJpbWl0aXZlKGlucHV0LCBwcmVmKTtcblx0fTtcblxuXHQvLyBgVG9Qcm9wZXJ0eUtleWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG5cdC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcm9wZXJ0eWtleVxuXHR2YXIgdG9Qcm9wZXJ0eUtleSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuXHQgIHZhciBrZXkgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgJ3N0cmluZycpO1xuXHQgIHJldHVybiBpc1N5bWJvbChrZXkpID8ga2V5IDoga2V5ICsgJyc7XG5cdH07XG5cblx0dmFyIFR5cGVFcnJvciQ2ID0gZ2xvYmFsXzEuVHlwZUVycm9yO1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxuXHR2YXIgJGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcblx0dmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXHR2YXIgRU5VTUVSQUJMRSA9ICdlbnVtZXJhYmxlJztcblx0dmFyIENPTkZJR1VSQUJMRSA9ICdjb25maWd1cmFibGUnO1xuXHR2YXIgV1JJVEFCTEUgPSAnd3JpdGFibGUnO1xuXG5cdC8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuXHR2YXIgZiA9IGRlc2NyaXB0b3JzID8gdjhQcm90b3R5cGVEZWZpbmVCdWcgPyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG5cdCAgYW5PYmplY3QoTyk7XG5cdCAgUCA9IHRvUHJvcGVydHlLZXkoUCk7XG5cdCAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG5cdCAgaWYgKHR5cGVvZiBPID09PSAnZnVuY3Rpb24nICYmIFAgPT09ICdwcm90b3R5cGUnICYmICd2YWx1ZScgaW4gQXR0cmlidXRlcyAmJiBXUklUQUJMRSBpbiBBdHRyaWJ1dGVzICYmICFBdHRyaWJ1dGVzW1dSSVRBQkxFXSkge1xuXHQgICAgdmFyIGN1cnJlbnQgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApO1xuXHQgICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudFtXUklUQUJMRV0pIHtcblx0ICAgICAgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG5cdCAgICAgIEF0dHJpYnV0ZXMgPSB7XG5cdCAgICAgICAgY29uZmlndXJhYmxlOiBDT05GSUdVUkFCTEUgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbQ09ORklHVVJBQkxFXSA6IGN1cnJlbnRbQ09ORklHVVJBQkxFXSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiBFTlVNRVJBQkxFIGluIEF0dHJpYnV0ZXMgPyBBdHRyaWJ1dGVzW0VOVU1FUkFCTEVdIDogY3VycmVudFtFTlVNRVJBQkxFXSxcblx0ICAgICAgICB3cml0YWJsZTogZmFsc2Vcblx0ICAgICAgfTtcblx0ICAgIH1cblx0ICB9IHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG5cdH0gOiAkZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG5cdCAgYW5PYmplY3QoTyk7XG5cdCAgUCA9IHRvUHJvcGVydHlLZXkoUCk7XG5cdCAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG5cdCAgaWYgKGllOERvbURlZmluZSkgdHJ5IHtcblx0ICAgIHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG5cdCAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXHQgIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvciQ2KCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xuXHQgIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuXHQgIHJldHVybiBPO1xuXHR9O1xuXG5cdHZhciBvYmplY3REZWZpbmVQcm9wZXJ0eSA9IHtcblx0XHRmOiBmXG5cdH07XG5cblx0dmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG5cdCAgcmV0dXJuIHtcblx0ICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG5cdCAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG5cdCAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcblx0ICAgIHZhbHVlOiB2YWx1ZVxuXHQgIH07XG5cdH07XG5cblx0dmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IGRlc2NyaXB0b3JzID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuXHQgIHJldHVybiBvYmplY3REZWZpbmVQcm9wZXJ0eS5mKG9iamVjdCwga2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgdmFsdWUpKTtcblx0fSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcblx0ICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuXHQgIHJldHVybiBvYmplY3Q7XG5cdH07XG5cblx0dmFyIEZ1bmN0aW9uUHJvdG90eXBlJDEgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxuXHR2YXIgZ2V0RGVzY3JpcHRvciA9IGRlc2NyaXB0b3JzICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cblx0dmFyIEVYSVNUUyQxID0gaGFzT3duUHJvcGVydHlfMShGdW5jdGlvblByb3RvdHlwZSQxLCAnbmFtZScpO1xuXHQvLyBhZGRpdGlvbmFsIHByb3RlY3Rpb24gZnJvbSBtaW5pZmllZCAvIG1hbmdsZWQgLyBkcm9wcGVkIGZ1bmN0aW9uIG5hbWVzXG5cdHZhciBQUk9QRVIgPSBFWElTVFMkMSAmJiAoZnVuY3Rpb24gc29tZXRoaW5nKCkgeyAvKiBlbXB0eSAqLyB9KS5uYW1lID09PSAnc29tZXRoaW5nJztcblx0dmFyIENPTkZJR1VSQUJMRSQxID0gRVhJU1RTJDEgJiYgKCFkZXNjcmlwdG9ycyB8fCAoZGVzY3JpcHRvcnMgJiYgZ2V0RGVzY3JpcHRvcihGdW5jdGlvblByb3RvdHlwZSQxLCAnbmFtZScpLmNvbmZpZ3VyYWJsZSkpO1xuXG5cdHZhciBmdW5jdGlvbk5hbWUgPSB7XG5cdCAgRVhJU1RTOiBFWElTVFMkMSxcblx0ICBQUk9QRVI6IFBST1BFUixcblx0ICBDT05GSUdVUkFCTEU6IENPTkZJR1VSQUJMRSQxXG5cdH07XG5cblx0dmFyIGZ1bmN0aW9uVG9TdHJpbmcgPSBmdW5jdGlvblVuY3VycnlUaGlzKEZ1bmN0aW9uLnRvU3RyaW5nKTtcblxuXHQvLyB0aGlzIGhlbHBlciBicm9rZW4gaW4gYGNvcmUtanNAMy40LjEtMy40LjRgLCBzbyB3ZSBjYW4ndCB1c2UgYHNoYXJlZGAgaGVscGVyXG5cdGlmICghaXNDYWxsYWJsZShzaGFyZWRTdG9yZS5pbnNwZWN0U291cmNlKSkge1xuXHQgIHNoYXJlZFN0b3JlLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcblx0ICAgIHJldHVybiBmdW5jdGlvblRvU3RyaW5nKGl0KTtcblx0ICB9O1xuXHR9XG5cblx0dmFyIGluc3BlY3RTb3VyY2UgPSBzaGFyZWRTdG9yZS5pbnNwZWN0U291cmNlO1xuXG5cdHZhciBXZWFrTWFwJDEgPSBnbG9iYWxfMS5XZWFrTWFwO1xuXG5cdHZhciBuYXRpdmVXZWFrTWFwID0gaXNDYWxsYWJsZShXZWFrTWFwJDEpICYmIC9uYXRpdmUgY29kZS8udGVzdChpbnNwZWN0U291cmNlKFdlYWtNYXAkMSkpO1xuXG5cdHZhciBrZXlzID0gc2hhcmVkKCdrZXlzJyk7XG5cblx0dmFyIHNoYXJlZEtleSA9IGZ1bmN0aW9uIChrZXkpIHtcblx0ICByZXR1cm4ga2V5c1trZXldIHx8IChrZXlzW2tleV0gPSB1aWQoa2V5KSk7XG5cdH07XG5cblx0dmFyIGhpZGRlbktleXMgPSB7fTtcblxuXHR2YXIgT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQgPSAnT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQnO1xuXHR2YXIgVHlwZUVycm9yJDcgPSBnbG9iYWxfMS5UeXBlRXJyb3I7XG5cdHZhciBXZWFrTWFwJDIgPSBnbG9iYWxfMS5XZWFrTWFwO1xuXHR2YXIgc2V0LCBnZXQsIGhhcztcblxuXHR2YXIgZW5mb3JjZSA9IGZ1bmN0aW9uIChpdCkge1xuXHQgIHJldHVybiBoYXMoaXQpID8gZ2V0KGl0KSA6IHNldChpdCwge30pO1xuXHR9O1xuXG5cdHZhciBnZXR0ZXJGb3IgPSBmdW5jdGlvbiAoVFlQRSkge1xuXHQgIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcblx0ICAgIHZhciBzdGF0ZTtcblx0ICAgIGlmICghaXNPYmplY3QoaXQpIHx8IChzdGF0ZSA9IGdldChpdCkpLnR5cGUgIT09IFRZUEUpIHtcblx0ICAgICAgdGhyb3cgVHlwZUVycm9yJDcoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG5cdCAgICB9IHJldHVybiBzdGF0ZTtcblx0ICB9O1xuXHR9O1xuXG5cdGlmIChuYXRpdmVXZWFrTWFwIHx8IHNoYXJlZFN0b3JlLnN0YXRlKSB7XG5cdCAgdmFyIHN0b3JlJDEgPSBzaGFyZWRTdG9yZS5zdGF0ZSB8fCAoc2hhcmVkU3RvcmUuc3RhdGUgPSBuZXcgV2Vha01hcCQyKCkpO1xuXHQgIHZhciB3bWdldCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXMoc3RvcmUkMS5nZXQpO1xuXHQgIHZhciB3bWhhcyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXMoc3RvcmUkMS5oYXMpO1xuXHQgIHZhciB3bXNldCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXMoc3RvcmUkMS5zZXQpO1xuXHQgIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcblx0ICAgIGlmICh3bWhhcyhzdG9yZSQxLCBpdCkpIHRocm93IG5ldyBUeXBlRXJyb3IkNyhPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG5cdCAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcblx0ICAgIHdtc2V0KHN0b3JlJDEsIGl0LCBtZXRhZGF0YSk7XG5cdCAgICByZXR1cm4gbWV0YWRhdGE7XG5cdCAgfTtcblx0ICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcblx0ICAgIHJldHVybiB3bWdldChzdG9yZSQxLCBpdCkgfHwge307XG5cdCAgfTtcblx0ICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcblx0ICAgIHJldHVybiB3bWhhcyhzdG9yZSQxLCBpdCk7XG5cdCAgfTtcblx0fSBlbHNlIHtcblx0ICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkoJ3N0YXRlJyk7XG5cdCAgaGlkZGVuS2V5c1tTVEFURV0gPSB0cnVlO1xuXHQgIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcblx0ICAgIGlmIChoYXNPd25Qcm9wZXJ0eV8xKGl0LCBTVEFURSkpIHRocm93IG5ldyBUeXBlRXJyb3IkNyhPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG5cdCAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcblx0ICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShpdCwgU1RBVEUsIG1ldGFkYXRhKTtcblx0ICAgIHJldHVybiBtZXRhZGF0YTtcblx0ICB9O1xuXHQgIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuXHQgICAgcmV0dXJuIGhhc093blByb3BlcnR5XzEoaXQsIFNUQVRFKSA/IGl0W1NUQVRFXSA6IHt9O1xuXHQgIH07XG5cdCAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgICByZXR1cm4gaGFzT3duUHJvcGVydHlfMShpdCwgU1RBVEUpO1xuXHQgIH07XG5cdH1cblxuXHR2YXIgaW50ZXJuYWxTdGF0ZSA9IHtcblx0ICBzZXQ6IHNldCxcblx0ICBnZXQ6IGdldCxcblx0ICBoYXM6IGhhcyxcblx0ICBlbmZvcmNlOiBlbmZvcmNlLFxuXHQgIGdldHRlckZvcjogZ2V0dGVyRm9yXG5cdH07XG5cblx0dmFyIG1ha2VCdWlsdEluXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5cdHZhciBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSA9IGZ1bmN0aW9uTmFtZS5DT05GSUdVUkFCTEU7XG5cblxuXG5cdHZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGUuZW5mb3JjZTtcblx0dmFyIGdldEludGVybmFsU3RhdGUgPSBpbnRlcm5hbFN0YXRlLmdldDtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcblx0dmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5cdHZhciBDT05GSUdVUkFCTEVfTEVOR1RIID0gZGVzY3JpcHRvcnMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAnbGVuZ3RoJywgeyB2YWx1ZTogOCB9KS5sZW5ndGggIT09IDg7XG5cdH0pO1xuXG5cdHZhciBURU1QTEFURSA9IFN0cmluZyhTdHJpbmcpLnNwbGl0KCdTdHJpbmcnKTtcblxuXHR2YXIgbWFrZUJ1aWx0SW4gPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgb3B0aW9ucykge1xuXHQgIGlmIChTdHJpbmcobmFtZSkuc2xpY2UoMCwgNykgPT09ICdTeW1ib2woJykge1xuXHQgICAgbmFtZSA9ICdbJyArIFN0cmluZyhuYW1lKS5yZXBsYWNlKC9eU3ltYm9sXFwoKFteKV0qKVxcKS8sICckMScpICsgJ10nO1xuXHQgIH1cblx0ICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmdldHRlcikgbmFtZSA9ICdnZXQgJyArIG5hbWU7XG5cdCAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXR0ZXIpIG5hbWUgPSAnc2V0ICcgKyBuYW1lO1xuXHQgIGlmICghaGFzT3duUHJvcGVydHlfMSh2YWx1ZSwgJ25hbWUnKSB8fCAoQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgJiYgdmFsdWUubmFtZSAhPT0gbmFtZSkpIHtcblx0ICAgIGRlZmluZVByb3BlcnR5KHZhbHVlLCAnbmFtZScsIHsgdmFsdWU6IG5hbWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcblx0ICB9XG5cdCAgaWYgKENPTkZJR1VSQUJMRV9MRU5HVEggJiYgb3B0aW9ucyAmJiBoYXNPd25Qcm9wZXJ0eV8xKG9wdGlvbnMsICdhcml0eScpICYmIHZhbHVlLmxlbmd0aCAhPT0gb3B0aW9ucy5hcml0eSkge1xuXHQgICAgZGVmaW5lUHJvcGVydHkodmFsdWUsICdsZW5ndGgnLCB7IHZhbHVlOiBvcHRpb25zLmFyaXR5IH0pO1xuXHQgIH1cblx0ICBpZiAob3B0aW9ucyAmJiBoYXNPd25Qcm9wZXJ0eV8xKG9wdGlvbnMsICdjb25zdHJ1Y3RvcicpICYmIG9wdGlvbnMuY29uc3RydWN0b3IpIHtcblx0ICAgIGlmIChkZXNjcmlwdG9ycykgdHJ5IHtcblx0ICAgICAgZGVmaW5lUHJvcGVydHkodmFsdWUsICdwcm90b3R5cGUnLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTtcblx0ICAgIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblx0ICB9IGVsc2UgdmFsdWUucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuXHQgIHZhciBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlKHZhbHVlKTtcblx0ICBpZiAoIWhhc093blByb3BlcnR5XzEoc3RhdGUsICdzb3VyY2UnKSkge1xuXHQgICAgc3RhdGUuc291cmNlID0gVEVNUExBVEUuam9pbih0eXBlb2YgbmFtZSA9PSAnc3RyaW5nJyA/IG5hbWUgOiAnJyk7XG5cdCAgfSByZXR1cm4gdmFsdWU7XG5cdH07XG5cblx0Ly8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRlbmQtbmF0aXZlIC0tIHJlcXVpcmVkXG5cdEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IG1ha2VCdWlsdEluKGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHQgIHJldHVybiBpc0NhbGxhYmxlKHRoaXMpICYmIGdldEludGVybmFsU3RhdGUodGhpcykuc291cmNlIHx8IGluc3BlY3RTb3VyY2UodGhpcyk7XG5cdH0sICd0b1N0cmluZycpO1xuXHR9KTtcblxuXHR2YXIgZGVmaW5lQnVpbHRJbiA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG5cdCAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG5cdCAgdmFyIHNpbXBsZSA9IG9wdGlvbnMuZW51bWVyYWJsZTtcblx0ICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uYW1lIDoga2V5O1xuXHQgIGlmIChpc0NhbGxhYmxlKHZhbHVlKSkgbWFrZUJ1aWx0SW5fMSh2YWx1ZSwgbmFtZSwgb3B0aW9ucyk7XG5cdCAgaWYgKG9wdGlvbnMuZ2xvYmFsKSB7XG5cdCAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcblx0ICAgIGVsc2UgZGVmaW5lR2xvYmFsUHJvcGVydHkoa2V5LCB2YWx1ZSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGlmICghb3B0aW9ucy51bnNhZmUpIGRlbGV0ZSBPW2tleV07XG5cdCAgICBlbHNlIGlmIChPW2tleV0pIHNpbXBsZSA9IHRydWU7XG5cdCAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcblx0ICAgIGVsc2UgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KE8sIGtleSwgdmFsdWUpO1xuXHQgIH0gcmV0dXJuIE87XG5cdH07XG5cblx0dmFyIHRvU3RyaW5nJDEgPSBmdW5jdGlvblVuY3VycnlUaGlzKHt9LnRvU3RyaW5nKTtcblx0dmFyIHN0cmluZ1NsaWNlID0gZnVuY3Rpb25VbmN1cnJ5VGhpcygnJy5zbGljZSk7XG5cblx0dmFyIGNsYXNzb2ZSYXcgPSBmdW5jdGlvbiAoaXQpIHtcblx0ICByZXR1cm4gc3RyaW5nU2xpY2UodG9TdHJpbmckMShpdCksIDgsIC0xKTtcblx0fTtcblxuXHR2YXIgVE9fU1RSSU5HX1RBRyQxID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xuXHR2YXIgT2JqZWN0JDMgPSBnbG9iYWxfMS5PYmplY3Q7XG5cblx0Ly8gRVMzIHdyb25nIGhlcmVcblx0dmFyIENPUlJFQ1RfQVJHVU1FTlRTID0gY2xhc3NvZlJhdyhmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cblx0Ly8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3Jcblx0dmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG5cdCAgdHJ5IHtcblx0ICAgIHJldHVybiBpdFtrZXldO1xuXHQgIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblx0fTtcblxuXHQvLyBnZXR0aW5nIHRhZyBmcm9tIEVTNisgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgXG5cdHZhciBjbGFzc29mID0gdG9TdHJpbmdUYWdTdXBwb3J0ID8gY2xhc3NvZlJhdyA6IGZ1bmN0aW9uIChpdCkge1xuXHQgIHZhciBPLCB0YWcsIHJlc3VsdDtcblx0ICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcblx0ICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuXHQgICAgOiB0eXBlb2YgKHRhZyA9IHRyeUdldChPID0gT2JqZWN0JDMoaXQpLCBUT19TVFJJTkdfVEFHJDEpKSA9PSAnc3RyaW5nJyA/IHRhZ1xuXHQgICAgLy8gYnVpbHRpblRhZyBjYXNlXG5cdCAgICA6IENPUlJFQ1RfQVJHVU1FTlRTID8gY2xhc3NvZlJhdyhPKVxuXHQgICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuXHQgICAgOiAocmVzdWx0ID0gY2xhc3NvZlJhdyhPKSkgPT0gJ09iamVjdCcgJiYgaXNDYWxsYWJsZShPLmNhbGxlZSkgPyAnQXJndW1lbnRzJyA6IHJlc3VsdDtcblx0fTtcblxuXHQvLyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kIGltcGxlbWVudGF0aW9uXG5cdC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xuXHR2YXIgb2JqZWN0VG9TdHJpbmcgPSB0b1N0cmluZ1RhZ1N1cHBvcnQgPyB7fS50b1N0cmluZyA6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHQgIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcblx0fTtcblxuXHQvLyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xuXHRpZiAoIXRvU3RyaW5nVGFnU3VwcG9ydCkge1xuXHQgIGRlZmluZUJ1aWx0SW4oT2JqZWN0LnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgb2JqZWN0VG9TdHJpbmcsIHsgdW5zYWZlOiB0cnVlIH0pO1xuXHR9XG5cblx0Ly8gaXRlcmFibGUgRE9NIGNvbGxlY3Rpb25zXG5cdC8vIGZsYWcgLSBgaXRlcmFibGVgIGludGVyZmFjZSAtICdlbnRyaWVzJywgJ2tleXMnLCAndmFsdWVzJywgJ2ZvckVhY2gnIG1ldGhvZHNcblx0dmFyIGRvbUl0ZXJhYmxlcyA9IHtcblx0ICBDU1NSdWxlTGlzdDogMCxcblx0ICBDU1NTdHlsZURlY2xhcmF0aW9uOiAwLFxuXHQgIENTU1ZhbHVlTGlzdDogMCxcblx0ICBDbGllbnRSZWN0TGlzdDogMCxcblx0ICBET01SZWN0TGlzdDogMCxcblx0ICBET01TdHJpbmdMaXN0OiAwLFxuXHQgIERPTVRva2VuTGlzdDogMSxcblx0ICBEYXRhVHJhbnNmZXJJdGVtTGlzdDogMCxcblx0ICBGaWxlTGlzdDogMCxcblx0ICBIVE1MQWxsQ29sbGVjdGlvbjogMCxcblx0ICBIVE1MQ29sbGVjdGlvbjogMCxcblx0ICBIVE1MRm9ybUVsZW1lbnQ6IDAsXG5cdCAgSFRNTFNlbGVjdEVsZW1lbnQ6IDAsXG5cdCAgTWVkaWFMaXN0OiAwLFxuXHQgIE1pbWVUeXBlQXJyYXk6IDAsXG5cdCAgTmFtZWROb2RlTWFwOiAwLFxuXHQgIE5vZGVMaXN0OiAxLFxuXHQgIFBhaW50UmVxdWVzdExpc3Q6IDAsXG5cdCAgUGx1Z2luOiAwLFxuXHQgIFBsdWdpbkFycmF5OiAwLFxuXHQgIFNWR0xlbmd0aExpc3Q6IDAsXG5cdCAgU1ZHTnVtYmVyTGlzdDogMCxcblx0ICBTVkdQYXRoU2VnTGlzdDogMCxcblx0ICBTVkdQb2ludExpc3Q6IDAsXG5cdCAgU1ZHU3RyaW5nTGlzdDogMCxcblx0ICBTVkdUcmFuc2Zvcm1MaXN0OiAwLFxuXHQgIFNvdXJjZUJ1ZmZlckxpc3Q6IDAsXG5cdCAgU3R5bGVTaGVldExpc3Q6IDAsXG5cdCAgVGV4dFRyYWNrQ3VlTGlzdDogMCxcblx0ICBUZXh0VHJhY2tMaXN0OiAwLFxuXHQgIFRvdWNoTGlzdDogMFxuXHR9O1xuXG5cdC8vIGluIG9sZCBXZWJLaXQgdmVyc2lvbnMsIGBlbGVtZW50LmNsYXNzTGlzdGAgaXMgbm90IGFuIGluc3RhbmNlIG9mIGdsb2JhbCBgRE9NVG9rZW5MaXN0YFxuXG5cblx0dmFyIGNsYXNzTGlzdCA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCgnc3BhbicpLmNsYXNzTGlzdDtcblx0dmFyIERPTVRva2VuTGlzdFByb3RvdHlwZSA9IGNsYXNzTGlzdCAmJiBjbGFzc0xpc3QuY29uc3RydWN0b3IgJiYgY2xhc3NMaXN0LmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxuXHR2YXIgZG9tVG9rZW5MaXN0UHJvdG90eXBlID0gRE9NVG9rZW5MaXN0UHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlID8gdW5kZWZpbmVkIDogRE9NVG9rZW5MaXN0UHJvdG90eXBlO1xuXG5cdHZhciBiaW5kJDEgPSBmdW5jdGlvblVuY3VycnlUaGlzKGZ1bmN0aW9uVW5jdXJyeVRoaXMuYmluZCk7XG5cblx0Ly8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG5cdHZhciBmdW5jdGlvbkJpbmRDb250ZXh0ID0gZnVuY3Rpb24gKGZuLCB0aGF0KSB7XG5cdCAgYUNhbGxhYmxlKGZuKTtcblx0ICByZXR1cm4gdGhhdCA9PT0gdW5kZWZpbmVkID8gZm4gOiBmdW5jdGlvbkJpbmROYXRpdmUgPyBiaW5kJDEoZm4sIHRoYXQpIDogZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcblx0ICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuXHQgIH07XG5cdH07XG5cblx0dmFyIE9iamVjdCQ0ID0gZ2xvYmFsXzEuT2JqZWN0O1xuXHR2YXIgc3BsaXQgPSBmdW5jdGlvblVuY3VycnlUaGlzKCcnLnNwbGl0KTtcblxuXHQvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xuXHR2YXIgaW5kZXhlZE9iamVjdCA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICAvLyB0aHJvd3MgYW4gZXJyb3IgaW4gcmhpbm8sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9yaGluby9pc3N1ZXMvMzQ2XG5cdCAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucyAtLSBzYWZlXG5cdCAgcmV0dXJuICFPYmplY3QkNCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApO1xuXHR9KSA/IGZ1bmN0aW9uIChpdCkge1xuXHQgIHJldHVybiBjbGFzc29mUmF3KGl0KSA9PSAnU3RyaW5nJyA/IHNwbGl0KGl0LCAnJykgOiBPYmplY3QkNChpdCk7XG5cdH0gOiBPYmplY3QkNDtcblxuXHR2YXIgY2VpbCA9IE1hdGguY2VpbDtcblx0dmFyIGZsb29yID0gTWF0aC5mbG9vcjtcblxuXHQvLyBgTWF0aC50cnVuY2AgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWF0aC50cnVuY1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1tYXRoLXRydW5jIC0tIHNhZmVcblx0dmFyIG1hdGhUcnVuYyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24gdHJ1bmMoeCkge1xuXHQgIHZhciBuID0gK3g7XG5cdCAgcmV0dXJuIChuID4gMCA/IGZsb29yIDogY2VpbCkobik7XG5cdH07XG5cblx0Ly8gYFRvSW50ZWdlck9ySW5maW5pdHlgIGFic3RyYWN0IG9wZXJhdGlvblxuXHQvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvaW50ZWdlcm9yaW5maW5pdHlcblx0dmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcblx0ICB2YXIgbnVtYmVyID0gK2FyZ3VtZW50O1xuXHQgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG5cdCAgcmV0dXJuIG51bWJlciAhPT0gbnVtYmVyIHx8IG51bWJlciA9PT0gMCA/IDAgOiBtYXRoVHJ1bmMobnVtYmVyKTtcblx0fTtcblxuXHR2YXIgbWluID0gTWF0aC5taW47XG5cblx0Ly8gYFRvTGVuZ3RoYCBhYnN0cmFjdCBvcGVyYXRpb25cblx0Ly8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2xlbmd0aFxuXHR2YXIgdG9MZW5ndGggPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcblx0ICByZXR1cm4gYXJndW1lbnQgPiAwID8gbWluKHRvSW50ZWdlck9ySW5maW5pdHkoYXJndW1lbnQpLCAweDFGRkZGRkZGRkZGRkZGKSA6IDA7IC8vIDIgKiogNTMgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcblx0fTtcblxuXHQvLyBgTGVuZ3RoT2ZBcnJheUxpa2VgIGFic3RyYWN0IG9wZXJhdGlvblxuXHQvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWxlbmd0aG9mYXJyYXlsaWtlXG5cdHZhciBsZW5ndGhPZkFycmF5TGlrZSA9IGZ1bmN0aW9uIChvYmopIHtcblx0ICByZXR1cm4gdG9MZW5ndGgob2JqLmxlbmd0aCk7XG5cdH07XG5cblx0Ly8gYElzQXJyYXlgIGFic3RyYWN0IG9wZXJhdGlvblxuXHQvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzYXJyYXlcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tYXJyYXktaXNhcnJheSAtLSBzYWZlXG5cdHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZ3VtZW50KSB7XG5cdCAgcmV0dXJuIGNsYXNzb2ZSYXcoYXJndW1lbnQpID09ICdBcnJheSc7XG5cdH07XG5cblx0dmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG5cdHZhciBlbXB0eSA9IFtdO1xuXHR2YXIgY29uc3RydWN0ID0gZ2V0QnVpbHRJbignUmVmbGVjdCcsICdjb25zdHJ1Y3QnKTtcblx0dmFyIGNvbnN0cnVjdG9yUmVnRXhwID0gL15cXHMqKD86Y2xhc3N8ZnVuY3Rpb24pXFxiLztcblx0dmFyIGV4ZWMgPSBmdW5jdGlvblVuY3VycnlUaGlzKGNvbnN0cnVjdG9yUmVnRXhwLmV4ZWMpO1xuXHR2YXIgSU5DT1JSRUNUX1RPX1NUUklORyA9ICFjb25zdHJ1Y3RvclJlZ0V4cC5leGVjKG5vb3ApO1xuXG5cdHZhciBpc0NvbnN0cnVjdG9yTW9kZXJuID0gZnVuY3Rpb24gaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkge1xuXHQgIGlmICghaXNDYWxsYWJsZShhcmd1bWVudCkpIHJldHVybiBmYWxzZTtcblx0ICB0cnkge1xuXHQgICAgY29uc3RydWN0KG5vb3AsIGVtcHR5LCBhcmd1bWVudCk7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0fTtcblxuXHR2YXIgaXNDb25zdHJ1Y3RvckxlZ2FjeSA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcblx0ICBpZiAoIWlzQ2FsbGFibGUoYXJndW1lbnQpKSByZXR1cm4gZmFsc2U7XG5cdCAgc3dpdGNoIChjbGFzc29mKGFyZ3VtZW50KSkge1xuXHQgICAgY2FzZSAnQXN5bmNGdW5jdGlvbic6XG5cdCAgICBjYXNlICdHZW5lcmF0b3JGdW5jdGlvbic6XG5cdCAgICBjYXNlICdBc3luY0dlbmVyYXRvckZ1bmN0aW9uJzogcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0ICB0cnkge1xuXHQgICAgLy8gd2UgY2FuJ3QgY2hlY2sgLnByb3RvdHlwZSBzaW5jZSBjb25zdHJ1Y3RvcnMgcHJvZHVjZWQgYnkgLmJpbmQgaGF2ZW4ndCBpdFxuXHQgICAgLy8gYEZ1bmN0aW9uI3RvU3RyaW5nYCB0aHJvd3Mgb24gc29tZSBidWlsdC1pdCBmdW5jdGlvbiBpbiBzb21lIGxlZ2FjeSBlbmdpbmVzXG5cdCAgICAvLyAoZm9yIGV4YW1wbGUsIGBET01RdWFkYCBhbmQgc2ltaWxhciBpbiBGRjQxLSlcblx0ICAgIHJldHVybiBJTkNPUlJFQ1RfVE9fU1RSSU5HIHx8ICEhZXhlYyhjb25zdHJ1Y3RvclJlZ0V4cCwgaW5zcGVjdFNvdXJjZShhcmd1bWVudCkpO1xuXHQgIH0gY2F0Y2ggKGVycm9yKSB7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9XG5cdH07XG5cblx0aXNDb25zdHJ1Y3RvckxlZ2FjeS5zaGFtID0gdHJ1ZTtcblxuXHQvLyBgSXNDb25zdHJ1Y3RvcmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG5cdC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNjb25zdHJ1Y3RvclxuXHR2YXIgaXNDb25zdHJ1Y3RvciA9ICFjb25zdHJ1Y3QgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuXHQgIHZhciBjYWxsZWQ7XG5cdCAgcmV0dXJuIGlzQ29uc3RydWN0b3JNb2Rlcm4oaXNDb25zdHJ1Y3Rvck1vZGVybi5jYWxsKVxuXHQgICAgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oT2JqZWN0KVxuXHQgICAgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oZnVuY3Rpb24gKCkgeyBjYWxsZWQgPSB0cnVlOyB9KVxuXHQgICAgfHwgY2FsbGVkO1xuXHR9KSA/IGlzQ29uc3RydWN0b3JMZWdhY3kgOiBpc0NvbnN0cnVjdG9yTW9kZXJuO1xuXG5cdHZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cdHZhciBBcnJheSQxID0gZ2xvYmFsXzEuQXJyYXk7XG5cblx0Ly8gYSBwYXJ0IG9mIGBBcnJheVNwZWNpZXNDcmVhdGVgIGFic3RyYWN0IG9wZXJhdGlvblxuXHQvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5c3BlY2llc2NyZWF0ZVxuXHR2YXIgYXJyYXlTcGVjaWVzQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSkge1xuXHQgIHZhciBDO1xuXHQgIGlmIChpc0FycmF5KG9yaWdpbmFsQXJyYXkpKSB7XG5cdCAgICBDID0gb3JpZ2luYWxBcnJheS5jb25zdHJ1Y3Rvcjtcblx0ICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG5cdCAgICBpZiAoaXNDb25zdHJ1Y3RvcihDKSAmJiAoQyA9PT0gQXJyYXkkMSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpIEMgPSB1bmRlZmluZWQ7XG5cdCAgICBlbHNlIGlmIChpc09iamVjdChDKSkge1xuXHQgICAgICBDID0gQ1tTUEVDSUVTXTtcblx0ICAgICAgaWYgKEMgPT09IG51bGwpIEMgPSB1bmRlZmluZWQ7XG5cdCAgICB9XG5cdCAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkkMSA6IEM7XG5cdH07XG5cblx0Ly8gYEFycmF5U3BlY2llc0NyZWF0ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG5cdC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXG5cdHZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSwgbGVuZ3RoKSB7XG5cdCAgcmV0dXJuIG5ldyAoYXJyYXlTcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWxBcnJheSkpKGxlbmd0aCA9PT0gMCA/IDAgOiBsZW5ndGgpO1xuXHR9O1xuXG5cdHZhciBwdXNoID0gZnVuY3Rpb25VbmN1cnJ5VGhpcyhbXS5wdXNoKTtcblxuXHQvLyBgQXJyYXkucHJvdG90eXBlLnsgZm9yRWFjaCwgbWFwLCBmaWx0ZXIsIHNvbWUsIGV2ZXJ5LCBmaW5kLCBmaW5kSW5kZXgsIGZpbHRlclJlamVjdCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG5cdHZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoVFlQRSkge1xuXHQgIHZhciBJU19NQVAgPSBUWVBFID09IDE7XG5cdCAgdmFyIElTX0ZJTFRFUiA9IFRZUEUgPT0gMjtcblx0ICB2YXIgSVNfU09NRSA9IFRZUEUgPT0gMztcblx0ICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7XG5cdCAgdmFyIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDY7XG5cdCAgdmFyIElTX0ZJTFRFUl9SRUpFQ1QgPSBUWVBFID09IDc7XG5cdCAgdmFyIE5PX0hPTEVTID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVg7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCwgc3BlY2lmaWNDcmVhdGUpIHtcblx0ICAgIHZhciBPID0gdG9PYmplY3QoJHRoaXMpO1xuXHQgICAgdmFyIHNlbGYgPSBpbmRleGVkT2JqZWN0KE8pO1xuXHQgICAgdmFyIGJvdW5kRnVuY3Rpb24gPSBmdW5jdGlvbkJpbmRDb250ZXh0KGNhbGxiYWNrZm4sIHRoYXQpO1xuXHQgICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKHNlbGYpO1xuXHQgICAgdmFyIGluZGV4ID0gMDtcblx0ICAgIHZhciBjcmVhdGUgPSBzcGVjaWZpY0NyZWF0ZSB8fCBhcnJheVNwZWNpZXNDcmVhdGU7XG5cdCAgICB2YXIgdGFyZ2V0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSIHx8IElTX0ZJTFRFUl9SRUpFQ1QgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuXHQgICAgdmFyIHZhbHVlLCByZXN1bHQ7XG5cdCAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpIHtcblx0ICAgICAgdmFsdWUgPSBzZWxmW2luZGV4XTtcblx0ICAgICAgcmVzdWx0ID0gYm91bmRGdW5jdGlvbih2YWx1ZSwgaW5kZXgsIE8pO1xuXHQgICAgICBpZiAoVFlQRSkge1xuXHQgICAgICAgIGlmIChJU19NQVApIHRhcmdldFtpbmRleF0gPSByZXN1bHQ7IC8vIG1hcFxuXHQgICAgICAgIGVsc2UgaWYgKHJlc3VsdCkgc3dpdGNoIChUWVBFKSB7XG5cdCAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAgLy8gc29tZVxuXHQgICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsdWU7ICAgICAgICAgICAgIC8vIGZpbmRcblx0ICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgICAvLyBmaW5kSW5kZXhcblx0ICAgICAgICAgIGNhc2UgMjogcHVzaCh0YXJnZXQsIHZhbHVlKTsgICAgICAvLyBmaWx0ZXJcblx0ICAgICAgICB9IGVsc2Ugc3dpdGNoIChUWVBFKSB7XG5cdCAgICAgICAgICBjYXNlIDQ6IHJldHVybiBmYWxzZTsgICAgICAgICAgICAgLy8gZXZlcnlcblx0ICAgICAgICAgIGNhc2UgNzogcHVzaCh0YXJnZXQsIHZhbHVlKTsgICAgICAvLyBmaWx0ZXJSZWplY3Rcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiB0YXJnZXQ7XG5cdCAgfTtcblx0fTtcblxuXHR2YXIgYXJyYXlJdGVyYXRpb24gPSB7XG5cdCAgLy8gYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2Rcblx0ICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mb3JlYWNoXG5cdCAgZm9yRWFjaDogY3JlYXRlTWV0aG9kKDApLFxuXHQgIC8vIGBBcnJheS5wcm90b3R5cGUubWFwYCBtZXRob2Rcblx0ICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5tYXBcblx0ICBtYXA6IGNyZWF0ZU1ldGhvZCgxKSxcblx0ICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kXG5cdCAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsdGVyXG5cdCAgZmlsdGVyOiBjcmVhdGVNZXRob2QoMiksXG5cdCAgLy8gYEFycmF5LnByb3RvdHlwZS5zb21lYCBtZXRob2Rcblx0ICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zb21lXG5cdCAgc29tZTogY3JlYXRlTWV0aG9kKDMpLFxuXHQgIC8vIGBBcnJheS5wcm90b3R5cGUuZXZlcnlgIG1ldGhvZFxuXHQgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmV2ZXJ5XG5cdCAgZXZlcnk6IGNyZWF0ZU1ldGhvZCg0KSxcblx0ICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbmRgIG1ldGhvZFxuXHQgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRcblx0ICBmaW5kOiBjcmVhdGVNZXRob2QoNSksXG5cdCAgLy8gYEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhgIG1ldGhvZFxuXHQgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRJbmRleFxuXHQgIGZpbmRJbmRleDogY3JlYXRlTWV0aG9kKDYpLFxuXHQgIC8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyUmVqZWN0YCBtZXRob2Rcblx0ICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1hcnJheS1maWx0ZXJpbmdcblx0ICBmaWx0ZXJSZWplY3Q6IGNyZWF0ZU1ldGhvZCg3KVxuXHR9O1xuXG5cdHZhciBhcnJheU1ldGhvZElzU3RyaWN0ID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FLCBhcmd1bWVudCkge1xuXHQgIHZhciBtZXRob2QgPSBbXVtNRVRIT0RfTkFNRV07XG5cdCAgcmV0dXJuICEhbWV0aG9kICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNhbGwgLS0gcmVxdWlyZWQgZm9yIHRlc3Rpbmdcblx0ICAgIG1ldGhvZC5jYWxsKG51bGwsIGFyZ3VtZW50IHx8IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDE7IH0sIDEpO1xuXHQgIH0pO1xuXHR9O1xuXG5cdHZhciAkZm9yRWFjaCA9IGFycmF5SXRlcmF0aW9uLmZvckVhY2g7XG5cblxuXHR2YXIgU1RSSUNUX01FVEhPRCA9IGFycmF5TWV0aG9kSXNTdHJpY3QoJ2ZvckVhY2gnKTtcblxuXHQvLyBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuXHQvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mb3JlYWNoXG5cdHZhciBhcnJheUZvckVhY2ggPSAhU1RSSUNUX01FVEhPRCA/IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcblx0ICByZXR1cm4gJGZvckVhY2godGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1hcnJheS1wcm90b3R5cGUtZm9yZWFjaCAtLSBzYWZlXG5cdH0gOiBbXS5mb3JFYWNoO1xuXG5cdHZhciBoYW5kbGVQcm90b3R5cGUgPSBmdW5jdGlvbiAoQ29sbGVjdGlvblByb3RvdHlwZSkge1xuXHQgIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuXHQgIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlICYmIENvbGxlY3Rpb25Qcm90b3R5cGUuZm9yRWFjaCAhPT0gYXJyYXlGb3JFYWNoKSB0cnkge1xuXHQgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsICdmb3JFYWNoJywgYXJyYXlGb3JFYWNoKTtcblx0ICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgQ29sbGVjdGlvblByb3RvdHlwZS5mb3JFYWNoID0gYXJyYXlGb3JFYWNoO1xuXHQgIH1cblx0fTtcblxuXHRmb3IgKHZhciBDT0xMRUNUSU9OX05BTUUgaW4gZG9tSXRlcmFibGVzKSB7XG5cdCAgaWYgKGRvbUl0ZXJhYmxlc1tDT0xMRUNUSU9OX05BTUVdKSB7XG5cdCAgICBoYW5kbGVQcm90b3R5cGUoZ2xvYmFsXzFbQ09MTEVDVElPTl9OQU1FXSAmJiBnbG9iYWxfMVtDT0xMRUNUSU9OX05BTUVdLnByb3RvdHlwZSk7XG5cdCAgfVxuXHR9XG5cblx0aGFuZGxlUHJvdG90eXBlKGRvbVRva2VuTGlzdFByb3RvdHlwZSk7XG5cblx0dmFyIGNhblVzZURPTSA9ICEhKFxuXHQgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG5cdCAgd2luZG93LmRvY3VtZW50ICYmXG5cdCAgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnRcblx0KTtcblxuXHR2YXIgY2FuVXNlRG9tID0gY2FuVXNlRE9NO1xuXG5cdHZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG5cdHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5cdC8vIE5hc2hvcm4gfiBKREs4IGJ1Z1xuXHR2YXIgTkFTSE9STl9CVUcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgISRwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgMTogMiB9LCAxKTtcblxuXHQvLyBgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG5cdC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eWlzZW51bWVyYWJsZVxuXHR2YXIgZiQxID0gTkFTSE9STl9CVUcgPyBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG5cdCAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcywgVik7XG5cdCAgcmV0dXJuICEhZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmVudW1lcmFibGU7XG5cdH0gOiAkcHJvcGVydHlJc0VudW1lcmFibGU7XG5cblx0dmFyIG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlID0ge1xuXHRcdGY6IGYkMVxuXHR9O1xuXG5cdC8vIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG5cblxuXG5cdHZhciB0b0luZGV4ZWRPYmplY3QgPSBmdW5jdGlvbiAoaXQpIHtcblx0ICByZXR1cm4gaW5kZXhlZE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGl0KSk7XG5cdH07XG5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG5cdHZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5cdC8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG5cdHZhciBmJDIgPSBkZXNjcmlwdG9ycyA/ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG5cdCAgTyA9IHRvSW5kZXhlZE9iamVjdChPKTtcblx0ICBQID0gdG9Qcm9wZXJ0eUtleShQKTtcblx0ICBpZiAoaWU4RG9tRGVmaW5lKSB0cnkge1xuXHQgICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMShPLCBQKTtcblx0ICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cdCAgaWYgKGhhc093blByb3BlcnR5XzEoTywgUCkpIHJldHVybiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoIWZ1bmN0aW9uQ2FsbChvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZS5mLCBPLCBQKSwgT1tQXSk7XG5cdH07XG5cblx0dmFyIG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHtcblx0XHRmOiBmJDJcblx0fTtcblxuXHR2YXIgbWF4ID0gTWF0aC5tYXg7XG5cdHZhciBtaW4kMSA9IE1hdGgubWluO1xuXG5cdC8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuXHQvLyBMZXQgaW50ZWdlciBiZSA/IFRvSW50ZWdlcihpbmRleCkuXG5cdC8vIElmIGludGVnZXIgPCAwLCBsZXQgcmVzdWx0IGJlIG1heCgobGVuZ3RoICsgaW50ZWdlciksIDApOyBlbHNlIGxldCByZXN1bHQgYmUgbWluKGludGVnZXIsIGxlbmd0aCkuXG5cdHZhciB0b0Fic29sdXRlSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuXHQgIHZhciBpbnRlZ2VyID0gdG9JbnRlZ2VyT3JJbmZpbml0eShpbmRleCk7XG5cdCAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4KGludGVnZXIgKyBsZW5ndGgsIDApIDogbWluJDEoaW50ZWdlciwgbGVuZ3RoKTtcblx0fTtcblxuXHQvLyBgQXJyYXkucHJvdG90eXBlLnsgaW5kZXhPZiwgaW5jbHVkZXMgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxuXHR2YXIgY3JlYXRlTWV0aG9kJDEgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcblx0ICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG5cdCAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCgkdGhpcyk7XG5cdCAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UoTyk7XG5cdCAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuXHQgICAgdmFyIHZhbHVlO1xuXHQgICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuXHQgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcblx0ICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG5cdCAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcblx0ICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcblx0ICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcblx0ICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3Rcblx0ICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuXHQgICAgICBpZiAoKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pICYmIE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG5cdCAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG5cdCAgfTtcblx0fTtcblxuXHR2YXIgYXJyYXlJbmNsdWRlcyA9IHtcblx0ICAvLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2Rcblx0ICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuXHQgIGluY2x1ZGVzOiBjcmVhdGVNZXRob2QkMSh0cnVlKSxcblx0ICAvLyBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuXHQgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2Zcblx0ICBpbmRleE9mOiBjcmVhdGVNZXRob2QkMShmYWxzZSlcblx0fTtcblxuXHR2YXIgaW5kZXhPZiA9IGFycmF5SW5jbHVkZXMuaW5kZXhPZjtcblxuXG5cdHZhciBwdXNoJDEgPSBmdW5jdGlvblVuY3VycnlUaGlzKFtdLnB1c2gpO1xuXG5cdHZhciBvYmplY3RLZXlzSW50ZXJuYWwgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuXHQgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KG9iamVjdCk7XG5cdCAgdmFyIGkgPSAwO1xuXHQgIHZhciByZXN1bHQgPSBbXTtcblx0ICB2YXIga2V5O1xuXHQgIGZvciAoa2V5IGluIE8pICFoYXNPd25Qcm9wZXJ0eV8xKGhpZGRlbktleXMsIGtleSkgJiYgaGFzT3duUHJvcGVydHlfMShPLCBrZXkpICYmIHB1c2gkMShyZXN1bHQsIGtleSk7XG5cdCAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuXHQgIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzT3duUHJvcGVydHlfMShPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuXHQgICAgfmluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHB1c2gkMShyZXN1bHQsIGtleSk7XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0Ly8gSUU4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5cdHZhciBlbnVtQnVnS2V5cyA9IFtcblx0ICAnY29uc3RydWN0b3InLFxuXHQgICdoYXNPd25Qcm9wZXJ0eScsXG5cdCAgJ2lzUHJvdG90eXBlT2YnLFxuXHQgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG5cdCAgJ3RvTG9jYWxlU3RyaW5nJyxcblx0ICAndG9TdHJpbmcnLFxuXHQgICd2YWx1ZU9mJ1xuXHRdO1xuXG5cdHZhciBoaWRkZW5LZXlzJDEgPSBlbnVtQnVnS2V5cy5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuXHQvLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eW5hbWVzIC0tIHNhZmVcblx0dmFyIGYkMyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuXHQgIHJldHVybiBvYmplY3RLZXlzSW50ZXJuYWwoTywgaGlkZGVuS2V5cyQxKTtcblx0fTtcblxuXHR2YXIgb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcyA9IHtcblx0XHRmOiBmJDNcblx0fTtcblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHNhZmVcblx0dmFyIGYkNCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cblx0dmFyIG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyA9IHtcblx0XHRmOiBmJDRcblx0fTtcblxuXHR2YXIgY29uY2F0ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcyhbXS5jb25jYXQpO1xuXG5cdC8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcblx0dmFyIG93bktleXMgPSBnZXRCdWlsdEluKCdSZWZsZWN0JywgJ293bktleXMnKSB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG5cdCAgdmFyIGtleXMgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzLmYoYW5PYmplY3QoaXQpKTtcblx0ICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzLmY7XG5cdCAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbmNhdChrZXlzLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpKSA6IGtleXM7XG5cdH07XG5cblx0dmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIGV4Y2VwdGlvbnMpIHtcblx0ICB2YXIga2V5cyA9IG93bktleXMoc291cmNlKTtcblx0ICB2YXIgZGVmaW5lUHJvcGVydHkgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xuXHQgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZjtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXHQgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eV8xKHRhcmdldCwga2V5KSAmJiAhKGV4Y2VwdGlvbnMgJiYgaGFzT3duUHJvcGVydHlfMShleGNlcHRpb25zLCBrZXkpKSkge1xuXHQgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdHZhciByZXBsYWNlbWVudCA9IC8jfFxcLnByb3RvdHlwZVxcLi87XG5cblx0dmFyIGlzRm9yY2VkID0gZnVuY3Rpb24gKGZlYXR1cmUsIGRldGVjdGlvbikge1xuXHQgIHZhciB2YWx1ZSA9IGRhdGFbbm9ybWFsaXplKGZlYXR1cmUpXTtcblx0ICByZXR1cm4gdmFsdWUgPT0gUE9MWUZJTEwgPyB0cnVlXG5cdCAgICA6IHZhbHVlID09IE5BVElWRSA/IGZhbHNlXG5cdCAgICA6IGlzQ2FsbGFibGUoZGV0ZWN0aW9uKSA/IGZhaWxzKGRldGVjdGlvbilcblx0ICAgIDogISFkZXRlY3Rpb247XG5cdH07XG5cblx0dmFyIG5vcm1hbGl6ZSA9IGlzRm9yY2VkLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblx0ICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgJy4nKS50b0xvd2VyQ2FzZSgpO1xuXHR9O1xuXG5cdHZhciBkYXRhID0gaXNGb3JjZWQuZGF0YSA9IHt9O1xuXHR2YXIgTkFUSVZFID0gaXNGb3JjZWQuTkFUSVZFID0gJ04nO1xuXHR2YXIgUE9MWUZJTEwgPSBpc0ZvcmNlZC5QT0xZRklMTCA9ICdQJztcblxuXHR2YXIgaXNGb3JjZWRfMSA9IGlzRm9yY2VkO1xuXG5cdHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvci5mO1xuXG5cblxuXG5cblxuXHQvKlxuXHQgIG9wdGlvbnMudGFyZ2V0ICAgICAgICAgLSBuYW1lIG9mIHRoZSB0YXJnZXQgb2JqZWN0XG5cdCAgb3B0aW9ucy5nbG9iYWwgICAgICAgICAtIHRhcmdldCBpcyB0aGUgZ2xvYmFsIG9iamVjdFxuXHQgIG9wdGlvbnMuc3RhdCAgICAgICAgICAgLSBleHBvcnQgYXMgc3RhdGljIG1ldGhvZHMgb2YgdGFyZ2V0XG5cdCAgb3B0aW9ucy5wcm90byAgICAgICAgICAtIGV4cG9ydCBhcyBwcm90b3R5cGUgbWV0aG9kcyBvZiB0YXJnZXRcblx0ICBvcHRpb25zLnJlYWwgICAgICAgICAgIC0gcmVhbCBwcm90b3R5cGUgbWV0aG9kIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cblx0ICBvcHRpb25zLmZvcmNlZCAgICAgICAgIC0gZXhwb3J0IGV2ZW4gaWYgdGhlIG5hdGl2ZSBmZWF0dXJlIGlzIGF2YWlsYWJsZVxuXHQgIG9wdGlvbnMuYmluZCAgICAgICAgICAgLSBiaW5kIG1ldGhvZHMgdG8gdGhlIHRhcmdldCwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuXHQgIG9wdGlvbnMud3JhcCAgICAgICAgICAgLSB3cmFwIGNvbnN0cnVjdG9ycyB0byBwcmV2ZW50aW5nIGdsb2JhbCBwb2xsdXRpb24sIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cblx0ICBvcHRpb25zLnVuc2FmZSAgICAgICAgIC0gdXNlIHRoZSBzaW1wbGUgYXNzaWdubWVudCBvZiBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGRlbGV0ZSArIGRlZmluZVByb3BlcnR5XG5cdCAgb3B0aW9ucy5zaGFtICAgICAgICAgICAtIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcblx0ICBvcHRpb25zLmVudW1lcmFibGUgICAgIC0gZXhwb3J0IGFzIGVudW1lcmFibGUgcHJvcGVydHlcblx0ICBvcHRpb25zLmRvbnRDYWxsR2V0U2V0IC0gcHJldmVudCBjYWxsaW5nIGEgZ2V0dGVyIG9uIHRhcmdldFxuXHQgIG9wdGlvbnMubmFtZSAgICAgICAgICAgLSB0aGUgLm5hbWUgb2YgdGhlIGZ1bmN0aW9uIGlmIGl0IGRvZXMgbm90IG1hdGNoIHRoZSBrZXlcblx0Ki9cblx0dmFyIF9leHBvcnQgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG5cdCAgdmFyIFRBUkdFVCA9IG9wdGlvbnMudGFyZ2V0O1xuXHQgIHZhciBHTE9CQUwgPSBvcHRpb25zLmdsb2JhbDtcblx0ICB2YXIgU1RBVElDID0gb3B0aW9ucy5zdGF0O1xuXHQgIHZhciBGT1JDRUQsIHRhcmdldCwga2V5LCB0YXJnZXRQcm9wZXJ0eSwgc291cmNlUHJvcGVydHksIGRlc2NyaXB0b3I7XG5cdCAgaWYgKEdMT0JBTCkge1xuXHQgICAgdGFyZ2V0ID0gZ2xvYmFsXzE7XG5cdCAgfSBlbHNlIGlmIChTVEFUSUMpIHtcblx0ICAgIHRhcmdldCA9IGdsb2JhbF8xW1RBUkdFVF0gfHwgZGVmaW5lR2xvYmFsUHJvcGVydHkoVEFSR0VULCB7fSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRhcmdldCA9IChnbG9iYWxfMVtUQVJHRVRdIHx8IHt9KS5wcm90b3R5cGU7XG5cdCAgfVxuXHQgIGlmICh0YXJnZXQpIGZvciAoa2V5IGluIHNvdXJjZSkge1xuXHQgICAgc291cmNlUHJvcGVydHkgPSBzb3VyY2Vba2V5XTtcblx0ICAgIGlmIChvcHRpb25zLmRvbnRDYWxsR2V0U2V0KSB7XG5cdCAgICAgIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSh0YXJnZXQsIGtleSk7XG5cdCAgICAgIHRhcmdldFByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuXHQgICAgfSBlbHNlIHRhcmdldFByb3BlcnR5ID0gdGFyZ2V0W2tleV07XG5cdCAgICBGT1JDRUQgPSBpc0ZvcmNlZF8xKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7XG5cdCAgICAvLyBjb250YWluZWQgaW4gdGFyZ2V0XG5cdCAgICBpZiAoIUZPUkNFRCAmJiB0YXJnZXRQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIGlmICh0eXBlb2Ygc291cmNlUHJvcGVydHkgPT0gdHlwZW9mIHRhcmdldFByb3BlcnR5KSBjb250aW51ZTtcblx0ICAgICAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0UHJvcGVydHkpO1xuXHQgICAgfVxuXHQgICAgLy8gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuXHQgICAgaWYgKG9wdGlvbnMuc2hhbSB8fCAodGFyZ2V0UHJvcGVydHkgJiYgdGFyZ2V0UHJvcGVydHkuc2hhbSkpIHtcblx0ICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHNvdXJjZVByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xuXHQgICAgfVxuXHQgICAgZGVmaW5lQnVpbHRJbih0YXJnZXQsIGtleSwgc291cmNlUHJvcGVydHksIG9wdGlvbnMpO1xuXHQgIH1cblx0fTtcblxuXHR2YXIgU3RyaW5nJDMgPSBnbG9iYWxfMS5TdHJpbmc7XG5cblx0dmFyIHRvU3RyaW5nXzEgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcblx0ICBpZiAoY2xhc3NvZihhcmd1bWVudCkgPT09ICdTeW1ib2wnKSB0aHJvdyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgU3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nJyk7XG5cdCAgcmV0dXJuIFN0cmluZyQzKGFyZ3VtZW50KTtcblx0fTtcblxuXHQvLyBhIHN0cmluZyBvZiBhbGwgdmFsaWQgdW5pY29kZSB3aGl0ZXNwYWNlc1xuXHR2YXIgd2hpdGVzcGFjZXMgPSAnXFx1MDAwOVxcdTAwMEFcXHUwMDBCXFx1MDAwQ1xcdTAwMERcXHUwMDIwXFx1MDBBMFxcdTE2ODBcXHUyMDAwXFx1MjAwMVxcdTIwMDInICtcblx0ICAnXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4XFx1MjAyOVxcdUZFRkYnO1xuXG5cdHZhciByZXBsYWNlID0gZnVuY3Rpb25VbmN1cnJ5VGhpcygnJy5yZXBsYWNlKTtcblx0dmFyIHdoaXRlc3BhY2UgPSAnWycgKyB3aGl0ZXNwYWNlcyArICddJztcblx0dmFyIGx0cmltID0gUmVnRXhwKCdeJyArIHdoaXRlc3BhY2UgKyB3aGl0ZXNwYWNlICsgJyonKTtcblx0dmFyIHJ0cmltID0gUmVnRXhwKHdoaXRlc3BhY2UgKyB3aGl0ZXNwYWNlICsgJyokJyk7XG5cblx0Ly8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltLCB0cmltU3RhcnQsIHRyaW1FbmQsIHRyaW1MZWZ0LCB0cmltUmlnaHQgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxuXHR2YXIgY3JlYXRlTWV0aG9kJDIgPSBmdW5jdGlvbiAoVFlQRSkge1xuXHQgIHJldHVybiBmdW5jdGlvbiAoJHRoaXMpIHtcblx0ICAgIHZhciBzdHJpbmcgPSB0b1N0cmluZ18xKHJlcXVpcmVPYmplY3RDb2VyY2libGUoJHRoaXMpKTtcblx0ICAgIGlmIChUWVBFICYgMSkgc3RyaW5nID0gcmVwbGFjZShzdHJpbmcsIGx0cmltLCAnJyk7XG5cdCAgICBpZiAoVFlQRSAmIDIpIHN0cmluZyA9IHJlcGxhY2Uoc3RyaW5nLCBydHJpbSwgJycpO1xuXHQgICAgcmV0dXJuIHN0cmluZztcblx0ICB9O1xuXHR9O1xuXG5cdHZhciBzdHJpbmdUcmltID0ge1xuXHQgIC8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbUxlZnQsIHRyaW1TdGFydCB9YCBtZXRob2RzXG5cdCAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1zdGFydFxuXHQgIHN0YXJ0OiBjcmVhdGVNZXRob2QkMigxKSxcblx0ICAvLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW1SaWdodCwgdHJpbUVuZCB9YCBtZXRob2RzXG5cdCAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1lbmRcblx0ICBlbmQ6IGNyZWF0ZU1ldGhvZCQyKDIpLFxuXHQgIC8vIGBTdHJpbmcucHJvdG90eXBlLnRyaW1gIG1ldGhvZFxuXHQgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltXG5cdCAgdHJpbTogY3JlYXRlTWV0aG9kJDIoMylcblx0fTtcblxuXHR2YXIgdHJpbSA9IHN0cmluZ1RyaW0udHJpbTtcblxuXG5cdHZhciAkcGFyc2VJbnQgPSBnbG9iYWxfMS5wYXJzZUludDtcblx0dmFyIFN5bWJvbCQyID0gZ2xvYmFsXzEuU3ltYm9sO1xuXHR2YXIgSVRFUkFUT1IgPSBTeW1ib2wkMiAmJiBTeW1ib2wkMi5pdGVyYXRvcjtcblx0dmFyIGhleCA9IC9eWystXT8weC9pO1xuXHR2YXIgZXhlYyQxID0gZnVuY3Rpb25VbmN1cnJ5VGhpcyhoZXguZXhlYyk7XG5cdHZhciBGT1JDRUQgPSAkcGFyc2VJbnQod2hpdGVzcGFjZXMgKyAnMDgnKSAhPT0gOCB8fCAkcGFyc2VJbnQod2hpdGVzcGFjZXMgKyAnMHgxNicpICE9PSAyMlxuXHQgIC8vIE1TIEVkZ2UgMTgtIGJyb2tlbiB3aXRoIGJveGVkIHN5bWJvbHNcblx0ICB8fCAoSVRFUkFUT1IgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHsgJHBhcnNlSW50KE9iamVjdChJVEVSQVRPUikpOyB9KSk7XG5cblx0Ly8gYHBhcnNlSW50YCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wYXJzZWludC1zdHJpbmctcmFkaXhcblx0dmFyIG51bWJlclBhcnNlSW50ID0gRk9SQ0VEID8gZnVuY3Rpb24gcGFyc2VJbnQoc3RyaW5nLCByYWRpeCkge1xuXHQgIHZhciBTID0gdHJpbSh0b1N0cmluZ18xKHN0cmluZykpO1xuXHQgIHJldHVybiAkcGFyc2VJbnQoUywgKHJhZGl4ID4+PiAwKSB8fCAoZXhlYyQxKGhleCwgUykgPyAxNiA6IDEwKSk7XG5cdH0gOiAkcGFyc2VJbnQ7XG5cblx0Ly8gYHBhcnNlSW50YCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wYXJzZWludC1zdHJpbmctcmFkaXhcblx0X2V4cG9ydCh7IGdsb2JhbDogdHJ1ZSwgZm9yY2VkOiBwYXJzZUludCAhPSBudW1iZXJQYXJzZUludCB9LCB7XG5cdCAgcGFyc2VJbnQ6IG51bWJlclBhcnNlSW50XG5cdH0pO1xuXG5cdC8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmtleXNcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWtleXMgLS0gc2FmZVxuXHR2YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuXHQgIHJldHVybiBvYmplY3RLZXlzSW50ZXJuYWwoTywgZW51bUJ1Z0tleXMpO1xuXHR9O1xuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1hc3NpZ24gLS0gc2FmZVxuXHR2YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuXHR2YXIgZGVmaW5lUHJvcGVydHkkMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblx0dmFyIGNvbmNhdCQxID0gZnVuY3Rpb25VbmN1cnJ5VGhpcyhbXS5jb25jYXQpO1xuXG5cdC8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuYXNzaWduXG5cdHZhciBvYmplY3RBc3NpZ24gPSAhJGFzc2lnbiB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG5cdCAgLy8gc2hvdWxkIGhhdmUgY29ycmVjdCBvcmRlciBvZiBvcGVyYXRpb25zIChFZGdlIGJ1Zylcblx0ICBpZiAoZGVzY3JpcHRvcnMgJiYgJGFzc2lnbih7IGI6IDEgfSwgJGFzc2lnbihkZWZpbmVQcm9wZXJ0eSQxKHt9LCAnYScsIHtcblx0ICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgZGVmaW5lUHJvcGVydHkkMSh0aGlzLCAnYicsIHtcblx0ICAgICAgICB2YWx1ZTogMyxcblx0ICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9KSwgeyBiOiAyIH0pKS5iICE9PSAxKSByZXR1cm4gdHJ1ZTtcblx0ICAvLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcblx0ICB2YXIgQSA9IHt9O1xuXHQgIHZhciBCID0ge307XG5cdCAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tc3ltYm9sIC0tIHNhZmVcblx0ICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7XG5cdCAgdmFyIGFscGhhYmV0ID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0Jztcblx0ICBBW3N5bWJvbF0gPSA3O1xuXHQgIGFscGhhYmV0LnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaHIpIHsgQltjaHJdID0gY2hyOyB9KTtcblx0ICByZXR1cm4gJGFzc2lnbih7fSwgQSlbc3ltYm9sXSAhPSA3IHx8IG9iamVjdEtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IGFscGhhYmV0O1xuXHR9KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcblx0ICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdCAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdCAgdmFyIGluZGV4ID0gMTtcblx0ICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzLmY7XG5cdCAgdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUuZjtcblx0ICB3aGlsZSAoYXJndW1lbnRzTGVuZ3RoID4gaW5kZXgpIHtcblx0ICAgIHZhciBTID0gaW5kZXhlZE9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuXHQgICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBjb25jYXQkMShvYmplY3RLZXlzKFMpLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoUykpIDogb2JqZWN0S2V5cyhTKTtcblx0ICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcblx0ICAgIHZhciBqID0gMDtcblx0ICAgIHZhciBrZXk7XG5cdCAgICB3aGlsZSAobGVuZ3RoID4gaikge1xuXHQgICAgICBrZXkgPSBrZXlzW2orK107XG5cdCAgICAgIGlmICghZGVzY3JpcHRvcnMgfHwgZnVuY3Rpb25DYWxsKHByb3BlcnR5SXNFbnVtZXJhYmxlLCBTLCBrZXkpKSBUW2tleV0gPSBTW2tleV07XG5cdCAgICB9XG5cdCAgfSByZXR1cm4gVDtcblx0fSA6ICRhc3NpZ247XG5cblx0Ly8gYE9iamVjdC5hc3NpZ25gIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWFzc2lnbiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuXHRfZXhwb3J0KHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgYXJpdHk6IDIsIGZvcmNlZDogT2JqZWN0LmFzc2lnbiAhPT0gb2JqZWN0QXNzaWduIH0sIHtcblx0ICBhc3NpZ246IG9iamVjdEFzc2lnblxuXHR9KTtcblxuXHR2YXIgU1BFQ0lFUyQxID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cblx0dmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcblx0ICAvLyBXZSBjYW4ndCB1c2UgdGhpcyBmZWF0dXJlIGRldGVjdGlvbiBpbiBWOCBzaW5jZSBpdCBjYXVzZXNcblx0ICAvLyBkZW9wdGltaXphdGlvbiBhbmQgc2VyaW91cyBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvblxuXHQgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82Nzdcblx0ICByZXR1cm4gZW5naW5lVjhWZXJzaW9uID49IDUxIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgYXJyYXkgPSBbXTtcblx0ICAgIHZhciBjb25zdHJ1Y3RvciA9IGFycmF5LmNvbnN0cnVjdG9yID0ge307XG5cdCAgICBjb25zdHJ1Y3RvcltTUEVDSUVTJDFdID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4geyBmb286IDEgfTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gYXJyYXlbTUVUSE9EX05BTUVdKEJvb2xlYW4pLmZvbyAhPT0gMTtcblx0ICB9KTtcblx0fTtcblxuXHR2YXIgJGZpbHRlciA9IGFycmF5SXRlcmF0aW9uLmZpbHRlcjtcblxuXG5cdHZhciBIQVNfU1BFQ0lFU19TVVBQT1JUID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnZmlsdGVyJyk7XG5cblx0Ly8gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWx0ZXJcblx0Ly8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQHNwZWNpZXNcblx0X2V4cG9ydCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogIUhBU19TUEVDSUVTX1NVUFBPUlQgfSwge1xuXHQgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG5cdCAgICByZXR1cm4gJGZpbHRlcih0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG5cdCAgfVxuXHR9KTtcblxuXHQvLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0aWVzXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0aWVzIC0tIHNhZmVcblx0dmFyIGYkNSA9IGRlc2NyaXB0b3JzICYmICF2OFByb3RvdHlwZURlZmluZUJ1ZyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG5cdCAgYW5PYmplY3QoTyk7XG5cdCAgdmFyIHByb3BzID0gdG9JbmRleGVkT2JqZWN0KFByb3BlcnRpZXMpO1xuXHQgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhQcm9wZXJ0aWVzKTtcblx0ICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG5cdCAgdmFyIGluZGV4ID0gMDtcblx0ICB2YXIga2V5O1xuXHQgIHdoaWxlIChsZW5ndGggPiBpbmRleCkgb2JqZWN0RGVmaW5lUHJvcGVydHkuZihPLCBrZXkgPSBrZXlzW2luZGV4KytdLCBwcm9wc1trZXldKTtcblx0ICByZXR1cm4gTztcblx0fTtcblxuXHR2YXIgb2JqZWN0RGVmaW5lUHJvcGVydGllcyA9IHtcblx0XHRmOiBmJDVcblx0fTtcblxuXHR2YXIgaHRtbCA9IGdldEJ1aWx0SW4oJ2RvY3VtZW50JywgJ2RvY3VtZW50RWxlbWVudCcpO1xuXG5cdC8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0IC0tIG9sZCBJRSwgV1NIICovXG5cblxuXG5cblxuXG5cblxuXHR2YXIgR1QgPSAnPic7XG5cdHZhciBMVCA9ICc8Jztcblx0dmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXHR2YXIgU0NSSVBUID0gJ3NjcmlwdCc7XG5cdHZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcblxuXHR2YXIgRW1wdHlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcblxuXHR2YXIgc2NyaXB0VGFnID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcblx0ICByZXR1cm4gTFQgKyBTQ1JJUFQgKyBHVCArIGNvbnRlbnQgKyBMVCArICcvJyArIFNDUklQVCArIEdUO1xuXHR9O1xuXG5cdC8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBBY3RpdmVYIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG5cdHZhciBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYID0gZnVuY3Rpb24gKGFjdGl2ZVhEb2N1bWVudCkge1xuXHQgIGFjdGl2ZVhEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJycpKTtcblx0ICBhY3RpdmVYRG9jdW1lbnQuY2xvc2UoKTtcblx0ICB2YXIgdGVtcCA9IGFjdGl2ZVhEb2N1bWVudC5wYXJlbnRXaW5kb3cuT2JqZWN0O1xuXHQgIGFjdGl2ZVhEb2N1bWVudCA9IG51bGw7IC8vIGF2b2lkIG1lbW9yeSBsZWFrXG5cdCAgcmV0dXJuIHRlbXA7XG5cdH07XG5cblx0Ly8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxuXHR2YXIgTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lID0gZnVuY3Rpb24gKCkge1xuXHQgIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG5cdCAgdmFyIGlmcmFtZSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG5cdCAgdmFyIEpTID0gJ2phdmEnICsgU0NSSVBUICsgJzonO1xuXHQgIHZhciBpZnJhbWVEb2N1bWVudDtcblx0ICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0ICBodG1sLmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cdCAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzQ3NVxuXHQgIGlmcmFtZS5zcmMgPSBTdHJpbmcoSlMpO1xuXHQgIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG5cdCAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuXHQgIGlmcmFtZURvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnZG9jdW1lbnQuRj1PYmplY3QnKSk7XG5cdCAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcblx0ICByZXR1cm4gaWZyYW1lRG9jdW1lbnQuRjtcblx0fTtcblxuXHQvLyBDaGVjayBmb3IgZG9jdW1lbnQuZG9tYWluIGFuZCBhY3RpdmUgeCBzdXBwb3J0XG5cdC8vIE5vIG5lZWQgdG8gdXNlIGFjdGl2ZSB4IGFwcHJvYWNoIHdoZW4gZG9jdW1lbnQuZG9tYWluIGlzIG5vdCBzZXRcblx0Ly8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMvMTUwXG5cdC8vIHZhcmlhdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20va2l0Y2FtYnJpZGdlL2VzNS1zaGltL2NvbW1pdC80ZjczOGFjMDY2MzQ2XG5cdC8vIGF2b2lkIElFIEdDIGJ1Z1xuXHR2YXIgYWN0aXZlWERvY3VtZW50O1xuXHR2YXIgTnVsbFByb3RvT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuXHQgIHRyeSB7XG5cdCAgICBhY3RpdmVYRG9jdW1lbnQgPSBuZXcgQWN0aXZlWE9iamVjdCgnaHRtbGZpbGUnKTtcblx0ICB9IGNhdGNoIChlcnJvcikgeyAvKiBpZ25vcmUgKi8gfVxuXHQgIE51bGxQcm90b09iamVjdCA9IHR5cGVvZiBkb2N1bWVudCAhPSAndW5kZWZpbmVkJ1xuXHQgICAgPyBkb2N1bWVudC5kb21haW4gJiYgYWN0aXZlWERvY3VtZW50XG5cdCAgICAgID8gTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpIC8vIG9sZCBJRVxuXHQgICAgICA6IE51bGxQcm90b09iamVjdFZpYUlGcmFtZSgpXG5cdCAgICA6IE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgoYWN0aXZlWERvY3VtZW50KTsgLy8gV1NIXG5cdCAgdmFyIGxlbmd0aCA9IGVudW1CdWdLZXlzLmxlbmd0aDtcblx0ICB3aGlsZSAobGVuZ3RoLS0pIGRlbGV0ZSBOdWxsUHJvdG9PYmplY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tsZW5ndGhdXTtcblx0ICByZXR1cm4gTnVsbFByb3RvT2JqZWN0KCk7XG5cdH07XG5cblx0aGlkZGVuS2V5c1tJRV9QUk9UT10gPSB0cnVlO1xuXG5cdC8vIGBPYmplY3QuY3JlYXRlYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1jcmVhdGUgLS0gc2FmZVxuXHR2YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuXHQgIHZhciByZXN1bHQ7XG5cdCAgaWYgKE8gIT09IG51bGwpIHtcblx0ICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuXHQgICAgcmVzdWx0ID0gbmV3IEVtcHR5Q29uc3RydWN0b3IoKTtcblx0ICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IG51bGw7XG5cdCAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG5cdCAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcblx0ICB9IGVsc2UgcmVzdWx0ID0gTnVsbFByb3RvT2JqZWN0KCk7XG5cdCAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IG9iamVjdERlZmluZVByb3BlcnRpZXMuZihyZXN1bHQsIFByb3BlcnRpZXMpO1xuXHR9O1xuXG5cdHZhciBkZWZpbmVQcm9wZXJ0eSQyID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcblxuXHR2YXIgVU5TQ09QQUJMRVMgPSB3ZWxsS25vd25TeW1ib2woJ3Vuc2NvcGFibGVzJyk7XG5cdHZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblxuXHQvLyBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cblx0Ly8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuXHRpZiAoQXJyYXlQcm90b3R5cGVbVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZCkge1xuXHQgIGRlZmluZVByb3BlcnR5JDIoQXJyYXlQcm90b3R5cGUsIFVOU0NPUEFCTEVTLCB7XG5cdCAgICBjb25maWd1cmFibGU6IHRydWUsXG5cdCAgICB2YWx1ZTogb2JqZWN0Q3JlYXRlKG51bGwpXG5cdCAgfSk7XG5cdH1cblxuXHQvLyBhZGQgYSBrZXkgdG8gQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG5cdHZhciBhZGRUb1Vuc2NvcGFibGVzID0gZnVuY3Rpb24gKGtleSkge1xuXHQgIEFycmF5UHJvdG90eXBlW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcblx0fTtcblxuXHR2YXIgaXRlcmF0b3JzID0ge307XG5cblx0dmFyIGNvcnJlY3RQcm90b3R5cGVHZXR0ZXIgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuXHQgIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cblx0ICBGLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG51bGw7XG5cdCAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldHByb3RvdHlwZW9mIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG5cdCAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgRigpKSAhPT0gRi5wcm90b3R5cGU7XG5cdH0pO1xuXG5cdHZhciBJRV9QUk9UTyQxID0gc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xuXHR2YXIgT2JqZWN0JDUgPSBnbG9iYWxfMS5PYmplY3Q7XG5cdHZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QkNS5wcm90b3R5cGU7XG5cblx0Ly8gYE9iamVjdC5nZXRQcm90b3R5cGVPZmAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldHByb3RvdHlwZW9mXG5cdHZhciBvYmplY3RHZXRQcm90b3R5cGVPZiA9IGNvcnJlY3RQcm90b3R5cGVHZXR0ZXIgPyBPYmplY3QkNS5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIChPKSB7XG5cdCAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KE8pO1xuXHQgIGlmIChoYXNPd25Qcm9wZXJ0eV8xKG9iamVjdCwgSUVfUFJPVE8kMSkpIHJldHVybiBvYmplY3RbSUVfUFJPVE8kMV07XG5cdCAgdmFyIGNvbnN0cnVjdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuXHQgIGlmIChpc0NhbGxhYmxlKGNvbnN0cnVjdG9yKSAmJiBvYmplY3QgaW5zdGFuY2VvZiBjb25zdHJ1Y3Rvcikge1xuXHQgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnByb3RvdHlwZTtcblx0ICB9IHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBPYmplY3QkNSA/IE9iamVjdFByb3RvdHlwZSA6IG51bGw7XG5cdH07XG5cblx0dmFyIElURVJBVE9SJDEgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG5cdHZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gZmFsc2U7XG5cblx0Ly8gYCVJdGVyYXRvclByb3RvdHlwZSVgIG9iamVjdFxuXHQvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtb2JqZWN0XG5cdHZhciBJdGVyYXRvclByb3RvdHlwZSwgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBhcnJheUl0ZXJhdG9yO1xuXG5cdC8qIGVzbGludC1kaXNhYmxlIGVzLXgvbm8tYXJyYXktcHJvdG90eXBlLWtleXMgLS0gc2FmZSAqL1xuXHRpZiAoW10ua2V5cykge1xuXHQgIGFycmF5SXRlcmF0b3IgPSBbXS5rZXlzKCk7XG5cdCAgLy8gU2FmYXJpIDggaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG5cdCAgaWYgKCEoJ25leHQnIGluIGFycmF5SXRlcmF0b3IpKSBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gdHJ1ZTtcblx0ICBlbHNlIHtcblx0ICAgIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSA9IG9iamVjdEdldFByb3RvdHlwZU9mKG9iamVjdEdldFByb3RvdHlwZU9mKGFycmF5SXRlcmF0b3IpKTtcblx0ICAgIGlmIChQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpIEl0ZXJhdG9yUHJvdG90eXBlID0gUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlO1xuXHQgIH1cblx0fVxuXG5cdHZhciBORVdfSVRFUkFUT1JfUFJPVE9UWVBFID0gSXRlcmF0b3JQcm90b3R5cGUgPT0gdW5kZWZpbmVkIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgdGVzdCA9IHt9O1xuXHQgIC8vIEZGNDQtIGxlZ2FjeSBpdGVyYXRvcnMgY2FzZVxuXHQgIHJldHVybiBJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUiQxXS5jYWxsKHRlc3QpICE9PSB0ZXN0O1xuXHR9KTtcblxuXHRpZiAoTkVXX0lURVJBVE9SX1BST1RPVFlQRSkgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuXHQvLyBgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0laXRlcmF0b3Jwcm90b3R5cGUlLUBAaXRlcmF0b3Jcblx0aWYgKCFpc0NhbGxhYmxlKEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SJDFdKSkge1xuXHQgIGRlZmluZUJ1aWx0SW4oSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SJDEsIGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH0pO1xuXHR9XG5cblx0dmFyIGl0ZXJhdG9yc0NvcmUgPSB7XG5cdCAgSXRlcmF0b3JQcm90b3R5cGU6IEl0ZXJhdG9yUHJvdG90eXBlLFxuXHQgIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlM6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlNcblx0fTtcblxuXHR2YXIgZGVmaW5lUHJvcGVydHkkMyA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG5cblxuXG5cdHZhciBUT19TVFJJTkdfVEFHJDIgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG5cblx0dmFyIHNldFRvU3RyaW5nVGFnID0gZnVuY3Rpb24gKHRhcmdldCwgVEFHLCBTVEFUSUMpIHtcblx0ICBpZiAodGFyZ2V0ICYmICFTVEFUSUMpIHRhcmdldCA9IHRhcmdldC5wcm90b3R5cGU7XG5cdCAgaWYgKHRhcmdldCAmJiAhaGFzT3duUHJvcGVydHlfMSh0YXJnZXQsIFRPX1NUUklOR19UQUckMikpIHtcblx0ICAgIGRlZmluZVByb3BlcnR5JDModGFyZ2V0LCBUT19TVFJJTkdfVEFHJDIsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogVEFHIH0pO1xuXHQgIH1cblx0fTtcblxuXHR2YXIgSXRlcmF0b3JQcm90b3R5cGUkMSA9IGl0ZXJhdG9yc0NvcmUuSXRlcmF0b3JQcm90b3R5cGU7XG5cblxuXG5cblxuXHR2YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cblx0dmFyIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCwgRU5VTUVSQUJMRV9ORVhUKSB7XG5cdCAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG5cdCAgSXRlcmF0b3JDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBvYmplY3RDcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUkMSwgeyBuZXh0OiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoKyFFTlVNRVJBQkxFX05FWFQsIG5leHQpIH0pO1xuXHQgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yQ29uc3RydWN0b3IsIFRPX1NUUklOR19UQUcsIGZhbHNlKTtcblx0ICBpdGVyYXRvcnNbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzO1xuXHQgIHJldHVybiBJdGVyYXRvckNvbnN0cnVjdG9yO1xuXHR9O1xuXG5cdHZhciBTdHJpbmckNCA9IGdsb2JhbF8xLlN0cmluZztcblx0dmFyIFR5cGVFcnJvciQ4ID0gZ2xvYmFsXzEuVHlwZUVycm9yO1xuXG5cdHZhciBhUG9zc2libGVQcm90b3R5cGUgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcblx0ICBpZiAodHlwZW9mIGFyZ3VtZW50ID09ICdvYmplY3QnIHx8IGlzQ2FsbGFibGUoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG5cdCAgdGhyb3cgVHlwZUVycm9yJDgoXCJDYW4ndCBzZXQgXCIgKyBTdHJpbmckNChhcmd1bWVudCkgKyAnIGFzIGEgcHJvdG90eXBlJyk7XG5cdH07XG5cblx0LyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gLS0gc2FmZSAqL1xuXG5cblxuXG5cdC8vIGBPYmplY3Quc2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5zZXRwcm90b3R5cGVvZlxuXHQvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LXNldHByb3RvdHlwZW9mIC0tIHNhZmVcblx0dmFyIG9iamVjdFNldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgQ09SUkVDVF9TRVRURVIgPSBmYWxzZTtcblx0ICB2YXIgdGVzdCA9IHt9O1xuXHQgIHZhciBzZXR0ZXI7XG5cdCAgdHJ5IHtcblx0ICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxuXHQgICAgc2V0dGVyID0gZnVuY3Rpb25VbmN1cnJ5VGhpcyhPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQpO1xuXHQgICAgc2V0dGVyKHRlc3QsIFtdKTtcblx0ICAgIENPUlJFQ1RfU0VUVEVSID0gdGVzdCBpbnN0YW5jZW9mIEFycmF5O1xuXHQgIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblx0ICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcblx0ICAgIGFuT2JqZWN0KE8pO1xuXHQgICAgYVBvc3NpYmxlUHJvdG90eXBlKHByb3RvKTtcblx0ICAgIGlmIChDT1JSRUNUX1NFVFRFUikgc2V0dGVyKE8sIHByb3RvKTtcblx0ICAgIGVsc2UgTy5fX3Byb3RvX18gPSBwcm90bztcblx0ICAgIHJldHVybiBPO1xuXHQgIH07XG5cdH0oKSA6IHVuZGVmaW5lZCk7XG5cblx0dmFyIFBST1BFUl9GVU5DVElPTl9OQU1FID0gZnVuY3Rpb25OYW1lLlBST1BFUjtcblx0dmFyIENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FID0gZnVuY3Rpb25OYW1lLkNPTkZJR1VSQUJMRTtcblx0dmFyIEl0ZXJhdG9yUHJvdG90eXBlJDIgPSBpdGVyYXRvcnNDb3JlLkl0ZXJhdG9yUHJvdG90eXBlO1xuXHR2YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxID0gaXRlcmF0b3JzQ29yZS5CVUdHWV9TQUZBUklfSVRFUkFUT1JTO1xuXHR2YXIgSVRFUkFUT1IkMiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcblx0dmFyIEtFWVMgPSAna2V5cyc7XG5cdHZhciBWQUxVRVMgPSAndmFsdWVzJztcblx0dmFyIEVOVFJJRVMgPSAnZW50cmllcyc7XG5cblx0dmFyIHJldHVyblRoaXMkMSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cblx0dmFyIGRlZmluZUl0ZXJhdG9yID0gZnVuY3Rpb24gKEl0ZXJhYmxlLCBOQU1FLCBJdGVyYXRvckNvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuXHQgIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG5cblx0ICB2YXIgZ2V0SXRlcmF0aW9uTWV0aG9kID0gZnVuY3Rpb24gKEtJTkQpIHtcblx0ICAgIGlmIChLSU5EID09PSBERUZBVUxUICYmIGRlZmF1bHRJdGVyYXRvcikgcmV0dXJuIGRlZmF1bHRJdGVyYXRvcjtcblx0ICAgIGlmICghQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxICYmIEtJTkQgaW4gSXRlcmFibGVQcm90b3R5cGUpIHJldHVybiBJdGVyYWJsZVByb3RvdHlwZVtLSU5EXTtcblx0ICAgIHN3aXRjaCAoS0lORCkge1xuXHQgICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG5cdCAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG5cdCAgICAgIGNhc2UgRU5UUklFUzogcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcblx0ICAgIH0gcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMpOyB9O1xuXHQgIH07XG5cblx0ICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcblx0ICB2YXIgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gZmFsc2U7XG5cdCAgdmFyIEl0ZXJhYmxlUHJvdG90eXBlID0gSXRlcmFibGUucHJvdG90eXBlO1xuXHQgIHZhciBuYXRpdmVJdGVyYXRvciA9IEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SJDJdXG5cdCAgICB8fCBJdGVyYWJsZVByb3RvdHlwZVsnQEBpdGVyYXRvciddXG5cdCAgICB8fCBERUZBVUxUICYmIEl0ZXJhYmxlUHJvdG90eXBlW0RFRkFVTFRdO1xuXHQgIHZhciBkZWZhdWx0SXRlcmF0b3IgPSAhQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxICYmIG5hdGl2ZUl0ZXJhdG9yIHx8IGdldEl0ZXJhdGlvbk1ldGhvZChERUZBVUxUKTtcblx0ICB2YXIgYW55TmF0aXZlSXRlcmF0b3IgPSBOQU1FID09ICdBcnJheScgPyBJdGVyYWJsZVByb3RvdHlwZS5lbnRyaWVzIHx8IG5hdGl2ZUl0ZXJhdG9yIDogbmF0aXZlSXRlcmF0b3I7XG5cdCAgdmFyIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgbWV0aG9kcywgS0VZO1xuXG5cdCAgLy8gZml4IG5hdGl2ZVxuXHQgIGlmIChhbnlOYXRpdmVJdGVyYXRvcikge1xuXHQgICAgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlID0gb2JqZWN0R2V0UHJvdG90eXBlT2YoYW55TmF0aXZlSXRlcmF0b3IuY2FsbChuZXcgSXRlcmFibGUoKSkpO1xuXHQgICAgaWYgKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuXHQgICAgICBpZiAoIG9iamVjdEdldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSkgIT09IEl0ZXJhdG9yUHJvdG90eXBlJDIpIHtcblx0ICAgICAgICBpZiAob2JqZWN0U2V0UHJvdG90eXBlT2YpIHtcblx0ICAgICAgICAgIG9iamVjdFNldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSXRlcmF0b3JQcm90b3R5cGUkMik7XG5cdCAgICAgICAgfSBlbHNlIGlmICghaXNDYWxsYWJsZShDdXJyZW50SXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1IkMl0pKSB7XG5cdCAgICAgICAgICBkZWZpbmVCdWlsdEluKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IkMiwgcmV0dXJuVGhpcyQxKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuXHQgICAgICBzZXRUb1N0cmluZ1RhZyhDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIHRydWUpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8vIGZpeCBBcnJheS5wcm90b3R5cGUueyB2YWx1ZXMsIEBAaXRlcmF0b3IgfS5uYW1lIGluIFY4IC8gRkZcblx0ICBpZiAoUFJPUEVSX0ZVTkNUSU9OX05BTUUgJiYgREVGQVVMVCA9PSBWQUxVRVMgJiYgbmF0aXZlSXRlcmF0b3IgJiYgbmF0aXZlSXRlcmF0b3IubmFtZSAhPT0gVkFMVUVTKSB7XG5cdCAgICBpZiAoIENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FKSB7XG5cdCAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShJdGVyYWJsZVByb3RvdHlwZSwgJ25hbWUnLCBWQUxVRVMpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gdHJ1ZTtcblx0ICAgICAgZGVmYXVsdEl0ZXJhdG9yID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gZnVuY3Rpb25DYWxsKG5hdGl2ZUl0ZXJhdG9yLCB0aGlzKTsgfTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICAvLyBleHBvcnQgYWRkaXRpb25hbCBtZXRob2RzXG5cdCAgaWYgKERFRkFVTFQpIHtcblx0ICAgIG1ldGhvZHMgPSB7XG5cdCAgICAgIHZhbHVlczogZ2V0SXRlcmF0aW9uTWV0aG9kKFZBTFVFUyksXG5cdCAgICAgIGtleXM6IElTX1NFVCA/IGRlZmF1bHRJdGVyYXRvciA6IGdldEl0ZXJhdGlvbk1ldGhvZChLRVlTKSxcblx0ICAgICAgZW50cmllczogZ2V0SXRlcmF0aW9uTWV0aG9kKEVOVFJJRVMpXG5cdCAgICB9O1xuXHQgICAgaWYgKEZPUkNFRCkgZm9yIChLRVkgaW4gbWV0aG9kcykge1xuXHQgICAgICBpZiAoQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB8fCAhKEtFWSBpbiBJdGVyYWJsZVByb3RvdHlwZSkpIHtcblx0ICAgICAgICBkZWZpbmVCdWlsdEluKEl0ZXJhYmxlUHJvdG90eXBlLCBLRVksIG1ldGhvZHNbS0VZXSk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBfZXhwb3J0KHsgdGFyZ2V0OiBOQU1FLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDEgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIH0sIG1ldGhvZHMpO1xuXHQgIH1cblxuXHQgIC8vIGRlZmluZSBpdGVyYXRvclxuXHQgIGlmICggSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1IkMl0gIT09IGRlZmF1bHRJdGVyYXRvcikge1xuXHQgICAgZGVmaW5lQnVpbHRJbihJdGVyYWJsZVByb3RvdHlwZSwgSVRFUkFUT1IkMiwgZGVmYXVsdEl0ZXJhdG9yLCB7IG5hbWU6IERFRkFVTFQgfSk7XG5cdCAgfVxuXHQgIGl0ZXJhdG9yc1tOQU1FXSA9IGRlZmF1bHRJdGVyYXRvcjtcblxuXHQgIHJldHVybiBtZXRob2RzO1xuXHR9O1xuXG5cdHZhciBkZWZpbmVQcm9wZXJ0eSQ0ID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcblxuXG5cblxuXHR2YXIgQVJSQVlfSVRFUkFUT1IgPSAnQXJyYXkgSXRlcmF0b3InO1xuXHR2YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGUuc2V0O1xuXHR2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGUuZ2V0dGVyRm9yKEFSUkFZX0lURVJBVE9SKTtcblxuXHQvLyBgQXJyYXkucHJvdG90eXBlLmVudHJpZXNgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5lbnRyaWVzXG5cdC8vIGBBcnJheS5wcm90b3R5cGUua2V5c2AgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmtleXNcblx0Ly8gYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS52YWx1ZXNcblx0Ly8gYEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAaXRlcmF0b3Jcblx0Ly8gYENyZWF0ZUFycmF5SXRlcmF0b3JgIGludGVybmFsIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZWFycmF5aXRlcmF0b3Jcblx0dmFyIGVzX2FycmF5X2l0ZXJhdG9yID0gZGVmaW5lSXRlcmF0b3IoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuXHQgIHNldEludGVybmFsU3RhdGUodGhpcywge1xuXHQgICAgdHlwZTogQVJSQVlfSVRFUkFUT1IsXG5cdCAgICB0YXJnZXQ6IHRvSW5kZXhlZE9iamVjdChpdGVyYXRlZCksIC8vIHRhcmdldFxuXHQgICAgaW5kZXg6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG5cdCAgICBraW5kOiBraW5kICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtpbmRcblx0ICB9KTtcblx0Ly8gYCVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0lYXJyYXlpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxuXHR9LCBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcblx0ICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0O1xuXHQgIHZhciBraW5kID0gc3RhdGUua2luZDtcblx0ICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleCsrO1xuXHQgIGlmICghdGFyZ2V0IHx8IGluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcblx0ICAgIHN0YXRlLnRhcmdldCA9IHVuZGVmaW5lZDtcblx0ICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcblx0ICB9XG5cdCAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4geyB2YWx1ZTogaW5kZXgsIGRvbmU6IGZhbHNlIH07XG5cdCAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiB7IHZhbHVlOiB0YXJnZXRbaW5kZXhdLCBkb25lOiBmYWxzZSB9O1xuXHQgIHJldHVybiB7IHZhbHVlOiBbaW5kZXgsIHRhcmdldFtpbmRleF1dLCBkb25lOiBmYWxzZSB9O1xuXHR9LCAndmFsdWVzJyk7XG5cblx0Ly8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlXG5cdC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRldW5tYXBwZWRhcmd1bWVudHNvYmplY3Rcblx0Ly8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGVtYXBwZWRhcmd1bWVudHNvYmplY3Rcblx0dmFyIHZhbHVlcyA9IGl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBpdGVyYXRvcnMuQXJyYXk7XG5cblx0Ly8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuXHRhZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5cdGFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuXHRhZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG5cblx0Ly8gVjggfiBDaHJvbWUgNDUtIGJ1Z1xuXHRpZiAoIGRlc2NyaXB0b3JzICYmIHZhbHVlcy5uYW1lICE9PSAndmFsdWVzJykgdHJ5IHtcblx0ICBkZWZpbmVQcm9wZXJ0eSQ0KHZhbHVlcywgJ25hbWUnLCB7IHZhbHVlOiAndmFsdWVzJyB9KTtcblx0fSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXG5cdHZhciBjaGFyQXQgPSBmdW5jdGlvblVuY3VycnlUaGlzKCcnLmNoYXJBdCk7XG5cdHZhciBjaGFyQ29kZUF0ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcygnJy5jaGFyQ29kZUF0KTtcblx0dmFyIHN0cmluZ1NsaWNlJDEgPSBmdW5jdGlvblVuY3VycnlUaGlzKCcnLnNsaWNlKTtcblxuXHR2YXIgY3JlYXRlTWV0aG9kJDMgPSBmdW5jdGlvbiAoQ09OVkVSVF9UT19TVFJJTkcpIHtcblx0ICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBwb3MpIHtcblx0ICAgIHZhciBTID0gdG9TdHJpbmdfMShyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKCR0aGlzKSk7XG5cdCAgICB2YXIgcG9zaXRpb24gPSB0b0ludGVnZXJPckluZmluaXR5KHBvcyk7XG5cdCAgICB2YXIgc2l6ZSA9IFMubGVuZ3RoO1xuXHQgICAgdmFyIGZpcnN0LCBzZWNvbmQ7XG5cdCAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IHNpemUpIHJldHVybiBDT05WRVJUX1RPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuXHQgICAgZmlyc3QgPSBjaGFyQ29kZUF0KFMsIHBvc2l0aW9uKTtcblx0ICAgIHJldHVybiBmaXJzdCA8IDB4RDgwMCB8fCBmaXJzdCA+IDB4REJGRiB8fCBwb3NpdGlvbiArIDEgPT09IHNpemVcblx0ICAgICAgfHwgKHNlY29uZCA9IGNoYXJDb2RlQXQoUywgcG9zaXRpb24gKyAxKSkgPCAweERDMDAgfHwgc2Vjb25kID4gMHhERkZGXG5cdCAgICAgICAgPyBDT05WRVJUX1RPX1NUUklOR1xuXHQgICAgICAgICAgPyBjaGFyQXQoUywgcG9zaXRpb24pXG5cdCAgICAgICAgICA6IGZpcnN0XG5cdCAgICAgICAgOiBDT05WRVJUX1RPX1NUUklOR1xuXHQgICAgICAgICAgPyBzdHJpbmdTbGljZSQxKFMsIHBvc2l0aW9uLCBwb3NpdGlvbiArIDIpXG5cdCAgICAgICAgICA6IChmaXJzdCAtIDB4RDgwMCA8PCAxMCkgKyAoc2Vjb25kIC0gMHhEQzAwKSArIDB4MTAwMDA7XG5cdCAgfTtcblx0fTtcblxuXHR2YXIgc3RyaW5nTXVsdGlieXRlID0ge1xuXHQgIC8vIGBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0YCBtZXRob2Rcblx0ICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuY29kZXBvaW50YXRcblx0ICBjb2RlQXQ6IGNyZWF0ZU1ldGhvZCQzKGZhbHNlKSxcblx0ICAvLyBgU3RyaW5nLnByb3RvdHlwZS5hdGAgbWV0aG9kXG5cdCAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxuXHQgIGNoYXJBdDogY3JlYXRlTWV0aG9kJDModHJ1ZSlcblx0fTtcblxuXHR2YXIgY2hhckF0JDEgPSBzdHJpbmdNdWx0aWJ5dGUuY2hhckF0O1xuXG5cblxuXG5cdHZhciBTVFJJTkdfSVRFUkFUT1IgPSAnU3RyaW5nIEl0ZXJhdG9yJztcblx0dmFyIHNldEludGVybmFsU3RhdGUkMSA9IGludGVybmFsU3RhdGUuc2V0O1xuXHR2YXIgZ2V0SW50ZXJuYWxTdGF0ZSQxID0gaW50ZXJuYWxTdGF0ZS5nZXR0ZXJGb3IoU1RSSU5HX0lURVJBVE9SKTtcblxuXHQvLyBgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS1AQGl0ZXJhdG9yXG5cdGRlZmluZUl0ZXJhdG9yKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuXHQgIHNldEludGVybmFsU3RhdGUkMSh0aGlzLCB7XG5cdCAgICB0eXBlOiBTVFJJTkdfSVRFUkFUT1IsXG5cdCAgICBzdHJpbmc6IHRvU3RyaW5nXzEoaXRlcmF0ZWQpLFxuXHQgICAgaW5kZXg6IDBcblx0ICB9KTtcblx0Ly8gYCVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXN0cmluZ2l0ZXJhdG9ycHJvdG90eXBlJS5uZXh0XG5cdH0sIGZ1bmN0aW9uIG5leHQoKSB7XG5cdCAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSQxKHRoaXMpO1xuXHQgIHZhciBzdHJpbmcgPSBzdGF0ZS5zdHJpbmc7XG5cdCAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXg7XG5cdCAgdmFyIHBvaW50O1xuXHQgIGlmIChpbmRleCA+PSBzdHJpbmcubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG5cdCAgcG9pbnQgPSBjaGFyQXQkMShzdHJpbmcsIGluZGV4KTtcblx0ICBzdGF0ZS5pbmRleCArPSBwb2ludC5sZW5ndGg7XG5cdCAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xuXHR9KTtcblxuXHR2YXIgZGVmaW5lQnVpbHRJbnMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIG9wdGlvbnMpIHtcblx0ICBmb3IgKHZhciBrZXkgaW4gc3JjKSBkZWZpbmVCdWlsdEluKHRhcmdldCwga2V5LCBzcmNba2V5XSwgb3B0aW9ucyk7XG5cdCAgcmV0dXJuIHRhcmdldDtcblx0fTtcblxuXHR2YXIgY3JlYXRlUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG5cdCAgdmFyIHByb3BlcnR5S2V5ID0gdG9Qcm9wZXJ0eUtleShrZXkpO1xuXHQgIGlmIChwcm9wZXJ0eUtleSBpbiBvYmplY3QpIG9iamVjdERlZmluZVByb3BlcnR5LmYob2JqZWN0LCBwcm9wZXJ0eUtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDAsIHZhbHVlKSk7XG5cdCAgZWxzZSBvYmplY3RbcHJvcGVydHlLZXldID0gdmFsdWU7XG5cdH07XG5cblx0dmFyIEFycmF5JDIgPSBnbG9iYWxfMS5BcnJheTtcblx0dmFyIG1heCQxID0gTWF0aC5tYXg7XG5cblx0dmFyIGFycmF5U2xpY2VTaW1wbGUgPSBmdW5jdGlvbiAoTywgc3RhcnQsIGVuZCkge1xuXHQgIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZShPKTtcblx0ICB2YXIgayA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuZ3RoKTtcblx0ICB2YXIgZmluID0gdG9BYnNvbHV0ZUluZGV4KGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kLCBsZW5ndGgpO1xuXHQgIHZhciByZXN1bHQgPSBBcnJheSQyKG1heCQxKGZpbiAtIGssIDApKTtcblx0ICBmb3IgKHZhciBuID0gMDsgayA8IGZpbjsgaysrLCBuKyspIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgbiwgT1trXSk7XG5cdCAgcmVzdWx0Lmxlbmd0aCA9IG47XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHQvKiBlc2xpbnQtZGlzYWJsZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eW5hbWVzIC0tIHNhZmUgKi9cblxuXG5cdHZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXMuZjtcblxuXG5cdHZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG5cdCAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cblx0dmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgdHJ5IHtcblx0ICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlOYW1lcyhpdCk7XG5cdCAgfSBjYXRjaCAoZXJyb3IpIHtcblx0ICAgIHJldHVybiBhcnJheVNsaWNlU2ltcGxlKHdpbmRvd05hbWVzKTtcblx0ICB9XG5cdH07XG5cblx0Ly8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xuXHR2YXIgZiQ2ID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuXHQgIHJldHVybiB3aW5kb3dOYW1lcyAmJiBjbGFzc29mUmF3KGl0KSA9PSAnV2luZG93J1xuXHQgICAgPyBnZXRXaW5kb3dOYW1lcyhpdClcblx0ICAgIDogJGdldE93blByb3BlcnR5TmFtZXModG9JbmRleGVkT2JqZWN0KGl0KSk7XG5cdH07XG5cblx0dmFyIG9iamVjdEdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbCA9IHtcblx0XHRmOiBmJDZcblx0fTtcblxuXHQvLyBGRjI2LSBidWc6IEFycmF5QnVmZmVycyBhcmUgbm9uLWV4dGVuc2libGUsIGJ1dCBPYmplY3QuaXNFeHRlbnNpYmxlIGRvZXMgbm90IHJlcG9ydCBpdFxuXG5cblx0dmFyIGFycmF5QnVmZmVyTm9uRXh0ZW5zaWJsZSA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICBpZiAodHlwZW9mIEFycmF5QnVmZmVyID09ICdmdW5jdGlvbicpIHtcblx0ICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoOCk7XG5cdCAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtaXNleHRlbnNpYmxlLCBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG5cdCAgICBpZiAoT2JqZWN0LmlzRXh0ZW5zaWJsZShidWZmZXIpKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoYnVmZmVyLCAnYScsIHsgdmFsdWU6IDggfSk7XG5cdCAgfVxuXHR9KTtcblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtaXNleHRlbnNpYmxlIC0tIHNhZmVcblx0dmFyICRpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xuXHR2YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgJGlzRXh0ZW5zaWJsZSgxKTsgfSk7XG5cblx0Ly8gYE9iamVjdC5pc0V4dGVuc2libGVgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5pc2V4dGVuc2libGVcblx0dmFyIG9iamVjdElzRXh0ZW5zaWJsZSA9IChGQUlMU19PTl9QUklNSVRJVkVTIHx8IGFycmF5QnVmZmVyTm9uRXh0ZW5zaWJsZSkgPyBmdW5jdGlvbiBpc0V4dGVuc2libGUoaXQpIHtcblx0ICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGZhbHNlO1xuXHQgIGlmIChhcnJheUJ1ZmZlck5vbkV4dGVuc2libGUgJiYgY2xhc3NvZlJhdyhpdCkgPT0gJ0FycmF5QnVmZmVyJykgcmV0dXJuIGZhbHNlO1xuXHQgIHJldHVybiAkaXNFeHRlbnNpYmxlID8gJGlzRXh0ZW5zaWJsZShpdCkgOiB0cnVlO1xuXHR9IDogJGlzRXh0ZW5zaWJsZTtcblxuXHR2YXIgZnJlZXppbmcgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuXHQgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1pc2V4dGVuc2libGUsIGVzLXgvbm8tb2JqZWN0LXByZXZlbnRleHRlbnNpb25zIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG5cdCAgcmV0dXJuIE9iamVjdC5pc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG5cdH0pO1xuXG5cdHZhciBpbnRlcm5hbE1ldGFkYXRhID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuXHR2YXIgZGVmaW5lUHJvcGVydHkgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xuXG5cblxuXG5cblxuXHR2YXIgUkVRVUlSRUQgPSBmYWxzZTtcblx0dmFyIE1FVEFEQVRBID0gdWlkKCdtZXRhJyk7XG5cdHZhciBpZCA9IDA7XG5cblx0dmFyIHNldE1ldGFkYXRhID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgZGVmaW5lUHJvcGVydHkoaXQsIE1FVEFEQVRBLCB7IHZhbHVlOiB7XG5cdCAgICBvYmplY3RJRDogJ08nICsgaWQrKywgLy8gb2JqZWN0IElEXG5cdCAgICB3ZWFrRGF0YToge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcblx0ICB9IH0pO1xuXHR9O1xuXG5cdHZhciBmYXN0S2V5ID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcblx0ICAvLyByZXR1cm4gYSBwcmltaXRpdmUgd2l0aCBwcmVmaXhcblx0ICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcblx0ICBpZiAoIWhhc093blByb3BlcnR5XzEoaXQsIE1FVEFEQVRBKSkge1xuXHQgICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3Rcblx0ICAgIGlmICghb2JqZWN0SXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuICdGJztcblx0ICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG5cdCAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJztcblx0ICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG5cdCAgICBzZXRNZXRhZGF0YShpdCk7XG5cdCAgLy8gcmV0dXJuIG9iamVjdCBJRFxuXHQgIH0gcmV0dXJuIGl0W01FVEFEQVRBXS5vYmplY3RJRDtcblx0fTtcblxuXHR2YXIgZ2V0V2Vha0RhdGEgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuXHQgIGlmICghaGFzT3duUHJvcGVydHlfMShpdCwgTUVUQURBVEEpKSB7XG5cdCAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuXHQgICAgaWYgKCFvYmplY3RJc0V4dGVuc2libGUoaXQpKSByZXR1cm4gdHJ1ZTtcblx0ICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG5cdCAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlO1xuXHQgICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcblx0ICAgIHNldE1ldGFkYXRhKGl0KTtcblx0ICAvLyByZXR1cm4gdGhlIHN0b3JlIG9mIHdlYWsgY29sbGVjdGlvbnMgSURzXG5cdCAgfSByZXR1cm4gaXRbTUVUQURBVEFdLndlYWtEYXRhO1xuXHR9O1xuXG5cdC8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xuXHR2YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHtcblx0ICBpZiAoZnJlZXppbmcgJiYgUkVRVUlSRUQgJiYgb2JqZWN0SXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzT3duUHJvcGVydHlfMShpdCwgTUVUQURBVEEpKSBzZXRNZXRhZGF0YShpdCk7XG5cdCAgcmV0dXJuIGl0O1xuXHR9O1xuXG5cdHZhciBlbmFibGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgbWV0YS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG5cdCAgUkVRVUlSRUQgPSB0cnVlO1xuXHQgIHZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcy5mO1xuXHQgIHZhciBzcGxpY2UgPSBmdW5jdGlvblVuY3VycnlUaGlzKFtdLnNwbGljZSk7XG5cdCAgdmFyIHRlc3QgPSB7fTtcblx0ICB0ZXN0W01FVEFEQVRBXSA9IDE7XG5cblx0ICAvLyBwcmV2ZW50IGV4cG9zaW5nIG9mIG1ldGFkYXRhIGtleVxuXHQgIGlmIChnZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QpLmxlbmd0aCkge1xuXHQgICAgb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcy5mID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgICAgIHZhciByZXN1bHQgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KTtcblx0ICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGlmIChyZXN1bHRbaV0gPT09IE1FVEFEQVRBKSB7XG5cdCAgICAgICAgICBzcGxpY2UocmVzdWx0LCBpLCAxKTtcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblxuXHQgICAgX2V4cG9ydCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogdHJ1ZSB9LCB7XG5cdCAgICAgIGdldE93blByb3BlcnR5TmFtZXM6IG9iamVjdEdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbC5mXG5cdCAgICB9KTtcblx0ICB9XG5cdH07XG5cblx0dmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcblx0ICBlbmFibGU6IGVuYWJsZSxcblx0ICBmYXN0S2V5OiBmYXN0S2V5LFxuXHQgIGdldFdlYWtEYXRhOiBnZXRXZWFrRGF0YSxcblx0ICBvbkZyZWV6ZTogb25GcmVlemVcblx0fTtcblxuXHRoaWRkZW5LZXlzW01FVEFEQVRBXSA9IHRydWU7XG5cdH0pO1xuXHR2YXIgaW50ZXJuYWxNZXRhZGF0YV8xID0gaW50ZXJuYWxNZXRhZGF0YS5lbmFibGU7XG5cdHZhciBpbnRlcm5hbE1ldGFkYXRhXzIgPSBpbnRlcm5hbE1ldGFkYXRhLmZhc3RLZXk7XG5cdHZhciBpbnRlcm5hbE1ldGFkYXRhXzMgPSBpbnRlcm5hbE1ldGFkYXRhLmdldFdlYWtEYXRhO1xuXHR2YXIgaW50ZXJuYWxNZXRhZGF0YV80ID0gaW50ZXJuYWxNZXRhZGF0YS5vbkZyZWV6ZTtcblxuXHR2YXIgSVRFUkFUT1IkMyA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcblx0dmFyIEFycmF5UHJvdG90eXBlJDEgPSBBcnJheS5wcm90b3R5cGU7XG5cblx0Ly8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxuXHR2YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKGl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b3R5cGUkMVtJVEVSQVRPUiQzXSA9PT0gaXQpO1xuXHR9O1xuXG5cdHZhciBJVEVSQVRPUiQ0ID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xuXG5cdHZhciBnZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuXHQgIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBnZXRNZXRob2QoaXQsIElURVJBVE9SJDQpXG5cdCAgICB8fCBnZXRNZXRob2QoaXQsICdAQGl0ZXJhdG9yJylcblx0ICAgIHx8IGl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG5cdH07XG5cblx0dmFyIFR5cGVFcnJvciQ5ID0gZ2xvYmFsXzEuVHlwZUVycm9yO1xuXG5cdHZhciBnZXRJdGVyYXRvciA9IGZ1bmN0aW9uIChhcmd1bWVudCwgdXNpbmdJdGVyYXRvcikge1xuXHQgIHZhciBpdGVyYXRvck1ldGhvZCA9IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZ2V0SXRlcmF0b3JNZXRob2QoYXJndW1lbnQpIDogdXNpbmdJdGVyYXRvcjtcblx0ICBpZiAoYUNhbGxhYmxlKGl0ZXJhdG9yTWV0aG9kKSkgcmV0dXJuIGFuT2JqZWN0KGZ1bmN0aW9uQ2FsbChpdGVyYXRvck1ldGhvZCwgYXJndW1lbnQpKTtcblx0ICB0aHJvdyBUeXBlRXJyb3IkOSh0cnlUb1N0cmluZyhhcmd1bWVudCkgKyAnIGlzIG5vdCBpdGVyYWJsZScpO1xuXHR9O1xuXG5cdHZhciBpdGVyYXRvckNsb3NlID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBraW5kLCB2YWx1ZSkge1xuXHQgIHZhciBpbm5lclJlc3VsdCwgaW5uZXJFcnJvcjtcblx0ICBhbk9iamVjdChpdGVyYXRvcik7XG5cdCAgdHJ5IHtcblx0ICAgIGlubmVyUmVzdWx0ID0gZ2V0TWV0aG9kKGl0ZXJhdG9yLCAncmV0dXJuJyk7XG5cdCAgICBpZiAoIWlubmVyUmVzdWx0KSB7XG5cdCAgICAgIGlmIChraW5kID09PSAndGhyb3cnKSB0aHJvdyB2YWx1ZTtcblx0ICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgfVxuXHQgICAgaW5uZXJSZXN1bHQgPSBmdW5jdGlvbkNhbGwoaW5uZXJSZXN1bHQsIGl0ZXJhdG9yKTtcblx0ICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgaW5uZXJFcnJvciA9IHRydWU7XG5cdCAgICBpbm5lclJlc3VsdCA9IGVycm9yO1xuXHQgIH1cblx0ICBpZiAoa2luZCA9PT0gJ3Rocm93JykgdGhyb3cgdmFsdWU7XG5cdCAgaWYgKGlubmVyRXJyb3IpIHRocm93IGlubmVyUmVzdWx0O1xuXHQgIGFuT2JqZWN0KGlubmVyUmVzdWx0KTtcblx0ICByZXR1cm4gdmFsdWU7XG5cdH07XG5cblx0dmFyIFR5cGVFcnJvciRhID0gZ2xvYmFsXzEuVHlwZUVycm9yO1xuXG5cdHZhciBSZXN1bHQgPSBmdW5jdGlvbiAoc3RvcHBlZCwgcmVzdWx0KSB7XG5cdCAgdGhpcy5zdG9wcGVkID0gc3RvcHBlZDtcblx0ICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcblx0fTtcblxuXHR2YXIgUmVzdWx0UHJvdG90eXBlID0gUmVzdWx0LnByb3RvdHlwZTtcblxuXHR2YXIgaXRlcmF0ZSA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgdW5ib3VuZEZ1bmN0aW9uLCBvcHRpb25zKSB7XG5cdCAgdmFyIHRoYXQgPSBvcHRpb25zICYmIG9wdGlvbnMudGhhdDtcblx0ICB2YXIgQVNfRU5UUklFUyA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5BU19FTlRSSUVTKTtcblx0ICB2YXIgSVNfSVRFUkFUT1IgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSVNfSVRFUkFUT1IpO1xuXHQgIHZhciBJTlRFUlJVUFRFRCA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5JTlRFUlJVUFRFRCk7XG5cdCAgdmFyIGZuID0gZnVuY3Rpb25CaW5kQ29udGV4dCh1bmJvdW5kRnVuY3Rpb24sIHRoYXQpO1xuXHQgIHZhciBpdGVyYXRvciwgaXRlckZuLCBpbmRleCwgbGVuZ3RoLCByZXN1bHQsIG5leHQsIHN0ZXA7XG5cblx0ICB2YXIgc3RvcCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcblx0ICAgIGlmIChpdGVyYXRvcikgaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgJ25vcm1hbCcsIGNvbmRpdGlvbik7XG5cdCAgICByZXR1cm4gbmV3IFJlc3VsdCh0cnVlLCBjb25kaXRpb24pO1xuXHQgIH07XG5cblx0ICB2YXIgY2FsbEZuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICBpZiAoQVNfRU5UUklFUykge1xuXHQgICAgICBhbk9iamVjdCh2YWx1ZSk7XG5cdCAgICAgIHJldHVybiBJTlRFUlJVUFRFRCA/IGZuKHZhbHVlWzBdLCB2YWx1ZVsxXSwgc3RvcCkgOiBmbih2YWx1ZVswXSwgdmFsdWVbMV0pO1xuXHQgICAgfSByZXR1cm4gSU5URVJSVVBURUQgPyBmbih2YWx1ZSwgc3RvcCkgOiBmbih2YWx1ZSk7XG5cdCAgfTtcblxuXHQgIGlmIChJU19JVEVSQVRPUikge1xuXHQgICAgaXRlcmF0b3IgPSBpdGVyYWJsZTtcblx0ICB9IGVsc2Uge1xuXHQgICAgaXRlckZuID0gZ2V0SXRlcmF0b3JNZXRob2QoaXRlcmFibGUpO1xuXHQgICAgaWYgKCFpdGVyRm4pIHRocm93IFR5cGVFcnJvciRhKHRyeVRvU3RyaW5nKGl0ZXJhYmxlKSArICcgaXMgbm90IGl0ZXJhYmxlJyk7XG5cdCAgICAvLyBvcHRpbWlzYXRpb24gZm9yIGFycmF5IGl0ZXJhdG9yc1xuXHQgICAgaWYgKGlzQXJyYXlJdGVyYXRvck1ldGhvZChpdGVyRm4pKSB7XG5cdCAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZShpdGVyYWJsZSk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG5cdCAgICAgICAgcmVzdWx0ID0gY2FsbEZuKGl0ZXJhYmxlW2luZGV4XSk7XG5cdCAgICAgICAgaWYgKHJlc3VsdCAmJiBvYmplY3RJc1Byb3RvdHlwZU9mKFJlc3VsdFByb3RvdHlwZSwgcmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgfSByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG5cdCAgICB9XG5cdCAgICBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKGl0ZXJhYmxlLCBpdGVyRm4pO1xuXHQgIH1cblxuXHQgIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuXHQgIHdoaWxlICghKHN0ZXAgPSBmdW5jdGlvbkNhbGwobmV4dCwgaXRlcmF0b3IpKS5kb25lKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICByZXN1bHQgPSBjYWxsRm4oc3RlcC52YWx1ZSk7XG5cdCAgICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgICBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAndGhyb3cnLCBlcnJvcik7XG5cdCAgICB9XG5cdCAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAnb2JqZWN0JyAmJiByZXN1bHQgJiYgb2JqZWN0SXNQcm90b3R5cGVPZihSZXN1bHRQcm90b3R5cGUsIHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG5cdCAgfSByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG5cdH07XG5cblx0dmFyIFR5cGVFcnJvciRiID0gZ2xvYmFsXzEuVHlwZUVycm9yO1xuXG5cdHZhciBhbkluc3RhbmNlID0gZnVuY3Rpb24gKGl0LCBQcm90b3R5cGUpIHtcblx0ICBpZiAob2JqZWN0SXNQcm90b3R5cGVPZihQcm90b3R5cGUsIGl0KSkgcmV0dXJuIGl0O1xuXHQgIHRocm93IFR5cGVFcnJvciRiKCdJbmNvcnJlY3QgaW52b2NhdGlvbicpO1xuXHR9O1xuXG5cdHZhciBJVEVSQVRPUiQ1ID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xuXHR2YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cblx0dHJ5IHtcblx0ICB2YXIgY2FsbGVkID0gMDtcblx0ICB2YXIgaXRlcmF0b3JXaXRoUmV0dXJuID0ge1xuXHQgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4geyBkb25lOiAhIWNhbGxlZCsrIH07XG5cdCAgICB9LFxuXHQgICAgJ3JldHVybic6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgU0FGRV9DTE9TSU5HID0gdHJ1ZTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIGl0ZXJhdG9yV2l0aFJldHVybltJVEVSQVRPUiQ1XSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tYXJyYXktZnJvbSwgbm8tdGhyb3ctbGl0ZXJhbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuXHQgIEFycmF5LmZyb20oaXRlcmF0b3JXaXRoUmV0dXJuLCBmdW5jdGlvbiAoKSB7IHRocm93IDI7IH0pO1xuXHR9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cblx0dmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiA9IGZ1bmN0aW9uIChleGVjLCBTS0lQX0NMT1NJTkcpIHtcblx0ICBpZiAoIVNLSVBfQ0xPU0lORyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG5cdCAgdmFyIElURVJBVElPTl9TVVBQT1JUID0gZmFsc2U7XG5cdCAgdHJ5IHtcblx0ICAgIHZhciBvYmplY3QgPSB7fTtcblx0ICAgIG9iamVjdFtJVEVSQVRPUiQ1XSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICByZXR1cm4geyBkb25lOiBJVEVSQVRJT05fU1VQUE9SVCA9IHRydWUgfTtcblx0ICAgICAgICB9XG5cdCAgICAgIH07XG5cdCAgICB9O1xuXHQgICAgZXhlYyhvYmplY3QpO1xuXHQgIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblx0ICByZXR1cm4gSVRFUkFUSU9OX1NVUFBPUlQ7XG5cdH07XG5cblx0Ly8gbWFrZXMgc3ViY2xhc3Npbmcgd29yayBjb3JyZWN0IGZvciB3cmFwcGVkIGJ1aWx0LWluc1xuXHR2YXIgaW5oZXJpdElmUmVxdWlyZWQgPSBmdW5jdGlvbiAoJHRoaXMsIGR1bW15LCBXcmFwcGVyKSB7XG5cdCAgdmFyIE5ld1RhcmdldCwgTmV3VGFyZ2V0UHJvdG90eXBlO1xuXHQgIGlmIChcblx0ICAgIC8vIGl0IGNhbiB3b3JrIG9ubHkgd2l0aCBuYXRpdmUgYHNldFByb3RvdHlwZU9mYFxuXHQgICAgb2JqZWN0U2V0UHJvdG90eXBlT2YgJiZcblx0ICAgIC8vIHdlIGhhdmVuJ3QgY29tcGxldGVseSBjb3JyZWN0IHByZS1FUzYgd2F5IGZvciBnZXR0aW5nIGBuZXcudGFyZ2V0YCwgc28gdXNlIHRoaXNcblx0ICAgIGlzQ2FsbGFibGUoTmV3VGFyZ2V0ID0gZHVtbXkuY29uc3RydWN0b3IpICYmXG5cdCAgICBOZXdUYXJnZXQgIT09IFdyYXBwZXIgJiZcblx0ICAgIGlzT2JqZWN0KE5ld1RhcmdldFByb3RvdHlwZSA9IE5ld1RhcmdldC5wcm90b3R5cGUpICYmXG5cdCAgICBOZXdUYXJnZXRQcm90b3R5cGUgIT09IFdyYXBwZXIucHJvdG90eXBlXG5cdCAgKSBvYmplY3RTZXRQcm90b3R5cGVPZigkdGhpcywgTmV3VGFyZ2V0UHJvdG90eXBlKTtcblx0ICByZXR1cm4gJHRoaXM7XG5cdH07XG5cblx0dmFyIGNvbGxlY3Rpb24gPSBmdW5jdGlvbiAoQ09OU1RSVUNUT1JfTkFNRSwgd3JhcHBlciwgY29tbW9uKSB7XG5cdCAgdmFyIElTX01BUCA9IENPTlNUUlVDVE9SX05BTUUuaW5kZXhPZignTWFwJykgIT09IC0xO1xuXHQgIHZhciBJU19XRUFLID0gQ09OU1RSVUNUT1JfTkFNRS5pbmRleE9mKCdXZWFrJykgIT09IC0xO1xuXHQgIHZhciBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCc7XG5cdCAgdmFyIE5hdGl2ZUNvbnN0cnVjdG9yID0gZ2xvYmFsXzFbQ09OU1RSVUNUT1JfTkFNRV07XG5cdCAgdmFyIE5hdGl2ZVByb3RvdHlwZSA9IE5hdGl2ZUNvbnN0cnVjdG9yICYmIE5hdGl2ZUNvbnN0cnVjdG9yLnByb3RvdHlwZTtcblx0ICB2YXIgQ29uc3RydWN0b3IgPSBOYXRpdmVDb25zdHJ1Y3Rvcjtcblx0ICB2YXIgZXhwb3J0ZWQgPSB7fTtcblxuXHQgIHZhciBmaXhNZXRob2QgPSBmdW5jdGlvbiAoS0VZKSB7XG5cdCAgICB2YXIgdW5jdXJyaWVkTmF0aXZlTWV0aG9kID0gZnVuY3Rpb25VbmN1cnJ5VGhpcyhOYXRpdmVQcm90b3R5cGVbS0VZXSk7XG5cdCAgICBkZWZpbmVCdWlsdEluKE5hdGl2ZVByb3RvdHlwZSwgS0VZLFxuXHQgICAgICBLRVkgPT0gJ2FkZCcgPyBmdW5jdGlvbiBhZGQodmFsdWUpIHtcblx0ICAgICAgICB1bmN1cnJpZWROYXRpdmVNZXRob2QodGhpcywgdmFsdWUgPT09IDAgPyAwIDogdmFsdWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICB9IDogS0VZID09ICdkZWxldGUnID8gZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChrZXkpID8gZmFsc2UgOiB1bmN1cnJpZWROYXRpdmVNZXRob2QodGhpcywga2V5ID09PSAwID8gMCA6IGtleSk7XG5cdCAgICAgIH0gOiBLRVkgPT0gJ2dldCcgPyBmdW5jdGlvbiBnZXQoa2V5KSB7XG5cdCAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGtleSkgPyB1bmRlZmluZWQgOiB1bmN1cnJpZWROYXRpdmVNZXRob2QodGhpcywga2V5ID09PSAwID8gMCA6IGtleSk7XG5cdCAgICAgIH0gOiBLRVkgPT0gJ2hhcycgPyBmdW5jdGlvbiBoYXMoa2V5KSB7XG5cdCAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGtleSkgPyBmYWxzZSA6IHVuY3VycmllZE5hdGl2ZU1ldGhvZCh0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5KTtcblx0ICAgICAgfSA6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG5cdCAgICAgICAgdW5jdXJyaWVkTmF0aXZlTWV0aG9kKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgfVxuXHQgICAgKTtcblx0ICB9O1xuXG5cdCAgdmFyIFJFUExBQ0UgPSBpc0ZvcmNlZF8xKFxuXHQgICAgQ09OU1RSVUNUT1JfTkFNRSxcblx0ICAgICFpc0NhbGxhYmxlKE5hdGl2ZUNvbnN0cnVjdG9yKSB8fCAhKElTX1dFQUsgfHwgTmF0aXZlUHJvdG90eXBlLmZvckVhY2ggJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKCkuZW50cmllcygpLm5leHQoKTtcblx0ICAgIH0pKVxuXHQgICk7XG5cblx0ICBpZiAoUkVQTEFDRSkge1xuXHQgICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3Jcblx0ICAgIENvbnN0cnVjdG9yID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCwgQURERVIpO1xuXHQgICAgaW50ZXJuYWxNZXRhZGF0YS5lbmFibGUoKTtcblx0ICB9IGVsc2UgaWYgKGlzRm9yY2VkXzEoQ09OU1RSVUNUT1JfTkFNRSwgdHJ1ZSkpIHtcblx0ICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuXHQgICAgLy8gZWFybHkgaW1wbGVtZW50YXRpb25zIG5vdCBzdXBwb3J0cyBjaGFpbmluZ1xuXHQgICAgdmFyIEhBU05UX0NIQUlOSU5HID0gaW5zdGFuY2VbQURERVJdKElTX1dFQUsgPyB7fSA6IC0wLCAxKSAhPSBpbnN0YW5jZTtcblx0ICAgIC8vIFY4IH4gQ2hyb21pdW0gNDAtIHdlYWstY29sbGVjdGlvbnMgdGhyb3dzIG9uIHByaW1pdGl2ZXMsIGJ1dCBzaG91bGQgcmV0dXJuIGZhbHNlXG5cdCAgICB2YXIgVEhST1dTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IGluc3RhbmNlLmhhcygxKTsgfSk7XG5cdCAgICAvLyBtb3N0IGVhcmx5IGltcGxlbWVudGF0aW9ucyBkb2Vzbid0IHN1cHBvcnRzIGl0ZXJhYmxlcywgbW9zdCBtb2Rlcm4gLSBub3QgY2xvc2UgaXQgY29ycmVjdGx5XG5cdCAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG5cdCAgICB2YXIgQUNDRVBUX0lURVJBQkxFUyA9IGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHsgbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKGl0ZXJhYmxlKTsgfSk7XG5cdCAgICAvLyBmb3IgZWFybHkgaW1wbGVtZW50YXRpb25zIC0wIGFuZCArMCBub3QgdGhlIHNhbWVcblx0ICAgIHZhciBCVUdHWV9aRVJPID0gIUlTX1dFQUsgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuXHQgICAgICAvLyBWOCB+IENocm9taXVtIDQyLSBmYWlscyBvbmx5IHdpdGggNSsgZWxlbWVudHNcblx0ICAgICAgdmFyICRpbnN0YW5jZSA9IG5ldyBOYXRpdmVDb25zdHJ1Y3RvcigpO1xuXHQgICAgICB2YXIgaW5kZXggPSA1O1xuXHQgICAgICB3aGlsZSAoaW5kZXgtLSkgJGluc3RhbmNlW0FEREVSXShpbmRleCwgaW5kZXgpO1xuXHQgICAgICByZXR1cm4gISRpbnN0YW5jZS5oYXMoLTApO1xuXHQgICAgfSk7XG5cblx0ICAgIGlmICghQUNDRVBUX0lURVJBQkxFUykge1xuXHQgICAgICBDb25zdHJ1Y3RvciA9IHdyYXBwZXIoZnVuY3Rpb24gKGR1bW15LCBpdGVyYWJsZSkge1xuXHQgICAgICAgIGFuSW5zdGFuY2UoZHVtbXksIE5hdGl2ZVByb3RvdHlwZSk7XG5cdCAgICAgICAgdmFyIHRoYXQgPSBpbmhlcml0SWZSZXF1aXJlZChuZXcgTmF0aXZlQ29uc3RydWN0b3IoKSwgZHVtbXksIENvbnN0cnVjdG9yKTtcblx0ICAgICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBpdGVyYXRlKGl0ZXJhYmxlLCB0aGF0W0FEREVSXSwgeyB0aGF0OiB0aGF0LCBBU19FTlRSSUVTOiBJU19NQVAgfSk7XG5cdCAgICAgICAgcmV0dXJuIHRoYXQ7XG5cdCAgICAgIH0pO1xuXHQgICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBOYXRpdmVQcm90b3R5cGU7XG5cdCAgICAgIE5hdGl2ZVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoVEhST1dTX09OX1BSSU1JVElWRVMgfHwgQlVHR1lfWkVSTykge1xuXHQgICAgICBmaXhNZXRob2QoJ2RlbGV0ZScpO1xuXHQgICAgICBmaXhNZXRob2QoJ2hhcycpO1xuXHQgICAgICBJU19NQVAgJiYgZml4TWV0aG9kKCdnZXQnKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKEJVR0dZX1pFUk8gfHwgSEFTTlRfQ0hBSU5JTkcpIGZpeE1ldGhvZChBRERFUik7XG5cblx0ICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgc2hvdWxkIG5vdCBjb250YWlucyAuY2xlYXIgbWV0aG9kXG5cdCAgICBpZiAoSVNfV0VBSyAmJiBOYXRpdmVQcm90b3R5cGUuY2xlYXIpIGRlbGV0ZSBOYXRpdmVQcm90b3R5cGUuY2xlYXI7XG5cdCAgfVxuXG5cdCAgZXhwb3J0ZWRbQ09OU1RSVUNUT1JfTkFNRV0gPSBDb25zdHJ1Y3Rvcjtcblx0ICBfZXhwb3J0KHsgZ2xvYmFsOiB0cnVlLCBjb25zdHJ1Y3RvcjogdHJ1ZSwgZm9yY2VkOiBDb25zdHJ1Y3RvciAhPSBOYXRpdmVDb25zdHJ1Y3RvciB9LCBleHBvcnRlZCk7XG5cblx0ICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSk7XG5cblx0ICBpZiAoIUlTX1dFQUspIGNvbW1vbi5zZXRTdHJvbmcoQ29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCk7XG5cblx0ICByZXR1cm4gQ29uc3RydWN0b3I7XG5cdH07XG5cblx0dmFyIGdldFdlYWtEYXRhID0gaW50ZXJuYWxNZXRhZGF0YS5nZXRXZWFrRGF0YTtcblxuXG5cblxuXG5cblxuXG5cdHZhciBzZXRJbnRlcm5hbFN0YXRlJDIgPSBpbnRlcm5hbFN0YXRlLnNldDtcblx0dmFyIGludGVybmFsU3RhdGVHZXR0ZXJGb3IgPSBpbnRlcm5hbFN0YXRlLmdldHRlckZvcjtcblx0dmFyIGZpbmQgPSBhcnJheUl0ZXJhdGlvbi5maW5kO1xuXHR2YXIgZmluZEluZGV4ID0gYXJyYXlJdGVyYXRpb24uZmluZEluZGV4O1xuXHR2YXIgc3BsaWNlID0gZnVuY3Rpb25VbmN1cnJ5VGhpcyhbXS5zcGxpY2UpO1xuXHR2YXIgaWQkMSA9IDA7XG5cblx0Ly8gZmFsbGJhY2sgZm9yIHVuY2F1Z2h0IGZyb3plbiBrZXlzXG5cdHZhciB1bmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24gKHN0b3JlKSB7XG5cdCAgcmV0dXJuIHN0b3JlLmZyb3plbiB8fCAoc3RvcmUuZnJvemVuID0gbmV3IFVuY2F1Z2h0RnJvemVuU3RvcmUoKSk7XG5cdH07XG5cblx0dmFyIFVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdGhpcy5lbnRyaWVzID0gW107XG5cdH07XG5cblx0dmFyIGZpbmRVbmNhdWdodEZyb3plbiA9IGZ1bmN0aW9uIChzdG9yZSwga2V5KSB7XG5cdCAgcmV0dXJuIGZpbmQoc3RvcmUuZW50cmllcywgZnVuY3Rpb24gKGl0KSB7XG5cdCAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcblx0ICB9KTtcblx0fTtcblxuXHRVbmNhdWdodEZyb3plblN0b3JlLnByb3RvdHlwZSA9IHtcblx0ICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuXHQgICAgaWYgKGVudHJ5KSByZXR1cm4gZW50cnlbMV07XG5cdCAgfSxcblx0ICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgIHJldHVybiAhIWZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuXHQgIH0sXG5cdCAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHQgICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG5cdCAgICBpZiAoZW50cnkpIGVudHJ5WzFdID0gdmFsdWU7XG5cdCAgICBlbHNlIHRoaXMuZW50cmllcy5wdXNoKFtrZXksIHZhbHVlXSk7XG5cdCAgfSxcblx0ICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuXHQgICAgdmFyIGluZGV4ID0gZmluZEluZGV4KHRoaXMuZW50cmllcywgZnVuY3Rpb24gKGl0KSB7XG5cdCAgICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuXHQgICAgfSk7XG5cdCAgICBpZiAofmluZGV4KSBzcGxpY2UodGhpcy5lbnRyaWVzLCBpbmRleCwgMSk7XG5cdCAgICByZXR1cm4gISF+aW5kZXg7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBjb2xsZWN0aW9uV2VhayA9IHtcblx0ICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCwgQURERVIpIHtcblx0ICAgIHZhciBDb25zdHJ1Y3RvciA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG5cdCAgICAgIGFuSW5zdGFuY2UodGhhdCwgUHJvdG90eXBlKTtcblx0ICAgICAgc2V0SW50ZXJuYWxTdGF0ZSQyKHRoYXQsIHtcblx0ICAgICAgICB0eXBlOiBDT05TVFJVQ1RPUl9OQU1FLFxuXHQgICAgICAgIGlkOiBpZCQxKyssXG5cdCAgICAgICAgZnJvemVuOiB1bmRlZmluZWRcblx0ICAgICAgfSk7XG5cdCAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGl0ZXJhdGUoaXRlcmFibGUsIHRoYXRbQURERVJdLCB7IHRoYXQ6IHRoYXQsIEFTX0VOVFJJRVM6IElTX01BUCB9KTtcblx0ICAgIH0pO1xuXG5cdCAgICB2YXIgUHJvdG90eXBlID0gQ29uc3RydWN0b3IucHJvdG90eXBlO1xuXG5cdCAgICB2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IoQ09OU1RSVUNUT1JfTkFNRSk7XG5cblx0ICAgIHZhciBkZWZpbmUgPSBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuXHQgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuXHQgICAgICB2YXIgZGF0YSA9IGdldFdlYWtEYXRhKGFuT2JqZWN0KGtleSksIHRydWUpO1xuXHQgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgdW5jYXVnaHRGcm96ZW5TdG9yZShzdGF0ZSkuc2V0KGtleSwgdmFsdWUpO1xuXHQgICAgICBlbHNlIGRhdGFbc3RhdGUuaWRdID0gdmFsdWU7XG5cdCAgICAgIHJldHVybiB0aGF0O1xuXHQgICAgfTtcblxuXHQgICAgZGVmaW5lQnVpbHRJbnMoUHJvdG90eXBlLCB7XG5cdCAgICAgIC8vIGB7IFdlYWtNYXAsIFdlYWtTZXQgfS5wcm90b3R5cGUuZGVsZXRlKGtleSlgIG1ldGhvZHNcblx0ICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy13ZWFrbWFwLnByb3RvdHlwZS5kZWxldGVcblx0ICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy13ZWFrc2V0LnByb3RvdHlwZS5kZWxldGVcblx0ICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuXHQgICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIHZhciBkYXRhID0gZ2V0V2Vha0RhdGEoa2V5KTtcblx0ICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUoc3RhdGUpWydkZWxldGUnXShrZXkpO1xuXHQgICAgICAgIHJldHVybiBkYXRhICYmIGhhc093blByb3BlcnR5XzEoZGF0YSwgc3RhdGUuaWQpICYmIGRlbGV0ZSBkYXRhW3N0YXRlLmlkXTtcblx0ICAgICAgfSxcblx0ICAgICAgLy8gYHsgV2Vha01hcCwgV2Vha1NldCB9LnByb3RvdHlwZS5oYXMoa2V5KWAgbWV0aG9kc1xuXHQgICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXdlYWttYXAucHJvdG90eXBlLmhhc1xuXHQgICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXdlYWtzZXQucHJvdG90eXBlLmhhc1xuXHQgICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcblx0ICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuXHQgICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIHZhciBkYXRhID0gZ2V0V2Vha0RhdGEoa2V5KTtcblx0ICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUoc3RhdGUpLmhhcyhrZXkpO1xuXHQgICAgICAgIHJldHVybiBkYXRhICYmIGhhc093blByb3BlcnR5XzEoZGF0YSwgc3RhdGUuaWQpO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgZGVmaW5lQnVpbHRJbnMoUHJvdG90eXBlLCBJU19NQVAgPyB7XG5cdCAgICAgIC8vIGBXZWFrTWFwLnByb3RvdHlwZS5nZXQoa2V5KWAgbWV0aG9kXG5cdCAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtd2Vha21hcC5wcm90b3R5cGUuZ2V0XG5cdCAgICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuXHQgICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG5cdCAgICAgICAgaWYgKGlzT2JqZWN0KGtleSkpIHtcblx0ICAgICAgICAgIHZhciBkYXRhID0gZ2V0V2Vha0RhdGEoa2V5KTtcblx0ICAgICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZShzdGF0ZSkuZ2V0KGtleSk7XG5cdCAgICAgICAgICByZXR1cm4gZGF0YSA/IGRhdGFbc3RhdGUuaWRdIDogdW5kZWZpbmVkO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSxcblx0ICAgICAgLy8gYFdlYWtNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKWAgbWV0aG9kXG5cdCAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtd2Vha21hcC5wcm90b3R5cGUuc2V0XG5cdCAgICAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gZGVmaW5lKHRoaXMsIGtleSwgdmFsdWUpO1xuXHQgICAgICB9XG5cdCAgICB9IDoge1xuXHQgICAgICAvLyBgV2Vha1NldC5wcm90b3R5cGUuYWRkKHZhbHVlKWAgbWV0aG9kXG5cdCAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtd2Vha3NldC5wcm90b3R5cGUuYWRkXG5cdCAgICAgIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIGRlZmluZSh0aGlzLCB2YWx1ZSwgdHJ1ZSk7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICByZXR1cm4gQ29uc3RydWN0b3I7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGUuZW5mb3JjZTtcblxuXG5cdHZhciBJU19JRTExID0gIWdsb2JhbF8xLkFjdGl2ZVhPYmplY3QgJiYgJ0FjdGl2ZVhPYmplY3QnIGluIGdsb2JhbF8xO1xuXHR2YXIgSW50ZXJuYWxXZWFrTWFwO1xuXG5cdHZhciB3cmFwcGVyID0gZnVuY3Rpb24gKGluaXQpIHtcblx0ICByZXR1cm4gZnVuY3Rpb24gV2Vha01hcCgpIHtcblx0ICAgIHJldHVybiBpbml0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuXHQgIH07XG5cdH07XG5cblx0Ly8gYFdlYWtNYXBgIGNvbnN0cnVjdG9yXG5cdC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtd2Vha21hcC1jb25zdHJ1Y3RvclxuXHR2YXIgJFdlYWtNYXAgPSBjb2xsZWN0aW9uKCdXZWFrTWFwJywgd3JhcHBlciwgY29sbGVjdGlvbldlYWspO1xuXG5cdC8vIElFMTEgV2Vha01hcCBmcm96ZW4ga2V5cyBmaXhcblx0Ly8gV2UgY2FuJ3QgdXNlIGZlYXR1cmUgZGV0ZWN0aW9uIGJlY2F1c2UgaXQgY3Jhc2ggc29tZSBvbGQgSUUgYnVpbGRzXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy80ODVcblx0aWYgKG5hdGl2ZVdlYWtNYXAgJiYgSVNfSUUxMSkge1xuXHQgIEludGVybmFsV2Vha01hcCA9IGNvbGxlY3Rpb25XZWFrLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsICdXZWFrTWFwJywgdHJ1ZSk7XG5cdCAgaW50ZXJuYWxNZXRhZGF0YS5lbmFibGUoKTtcblx0ICB2YXIgV2Vha01hcFByb3RvdHlwZSA9ICRXZWFrTWFwLnByb3RvdHlwZTtcblx0ICB2YXIgbmF0aXZlRGVsZXRlID0gZnVuY3Rpb25VbmN1cnJ5VGhpcyhXZWFrTWFwUHJvdG90eXBlWydkZWxldGUnXSk7XG5cdCAgdmFyIG5hdGl2ZUhhcyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXMoV2Vha01hcFByb3RvdHlwZS5oYXMpO1xuXHQgIHZhciBuYXRpdmVHZXQgPSBmdW5jdGlvblVuY3VycnlUaGlzKFdlYWtNYXBQcm90b3R5cGUuZ2V0KTtcblx0ICB2YXIgbmF0aXZlU2V0ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcyhXZWFrTWFwUHJvdG90eXBlLnNldCk7XG5cdCAgZGVmaW5lQnVpbHRJbnMoV2Vha01hcFByb3RvdHlwZSwge1xuXHQgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgaWYgKGlzT2JqZWN0KGtleSkgJiYgIW9iamVjdElzRXh0ZW5zaWJsZShrZXkpKSB7XG5cdCAgICAgICAgdmFyIHN0YXRlID0gZW5mb3JjZUludGVybmFsU3RhdGUodGhpcyk7XG5cdCAgICAgICAgaWYgKCFzdGF0ZS5mcm96ZW4pIHN0YXRlLmZyb3plbiA9IG5ldyBJbnRlcm5hbFdlYWtNYXAoKTtcblx0ICAgICAgICByZXR1cm4gbmF0aXZlRGVsZXRlKHRoaXMsIGtleSkgfHwgc3RhdGUuZnJvemVuWydkZWxldGUnXShrZXkpO1xuXHQgICAgICB9IHJldHVybiBuYXRpdmVEZWxldGUodGhpcywga2V5KTtcblx0ICAgIH0sXG5cdCAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcblx0ICAgICAgaWYgKGlzT2JqZWN0KGtleSkgJiYgIW9iamVjdElzRXh0ZW5zaWJsZShrZXkpKSB7XG5cdCAgICAgICAgdmFyIHN0YXRlID0gZW5mb3JjZUludGVybmFsU3RhdGUodGhpcyk7XG5cdCAgICAgICAgaWYgKCFzdGF0ZS5mcm96ZW4pIHN0YXRlLmZyb3plbiA9IG5ldyBJbnRlcm5hbFdlYWtNYXAoKTtcblx0ICAgICAgICByZXR1cm4gbmF0aXZlSGFzKHRoaXMsIGtleSkgfHwgc3RhdGUuZnJvemVuLmhhcyhrZXkpO1xuXHQgICAgICB9IHJldHVybiBuYXRpdmVIYXModGhpcywga2V5KTtcblx0ICAgIH0sXG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcblx0ICAgICAgaWYgKGlzT2JqZWN0KGtleSkgJiYgIW9iamVjdElzRXh0ZW5zaWJsZShrZXkpKSB7XG5cdCAgICAgICAgdmFyIHN0YXRlID0gZW5mb3JjZUludGVybmFsU3RhdGUodGhpcyk7XG5cdCAgICAgICAgaWYgKCFzdGF0ZS5mcm96ZW4pIHN0YXRlLmZyb3plbiA9IG5ldyBJbnRlcm5hbFdlYWtNYXAoKTtcblx0ICAgICAgICByZXR1cm4gbmF0aXZlSGFzKHRoaXMsIGtleSkgPyBuYXRpdmVHZXQodGhpcywga2V5KSA6IHN0YXRlLmZyb3plbi5nZXQoa2V5KTtcblx0ICAgICAgfSByZXR1cm4gbmF0aXZlR2V0KHRoaXMsIGtleSk7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuXHQgICAgICBpZiAoaXNPYmplY3Qoa2V5KSAmJiAhb2JqZWN0SXNFeHRlbnNpYmxlKGtleSkpIHtcblx0ICAgICAgICB2YXIgc3RhdGUgPSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh0aGlzKTtcblx0ICAgICAgICBpZiAoIXN0YXRlLmZyb3plbikgc3RhdGUuZnJvemVuID0gbmV3IEludGVybmFsV2Vha01hcCgpO1xuXHQgICAgICAgIG5hdGl2ZUhhcyh0aGlzLCBrZXkpID8gbmF0aXZlU2V0KHRoaXMsIGtleSwgdmFsdWUpIDogc3RhdGUuZnJvemVuLnNldChrZXksIHZhbHVlKTtcblx0ICAgICAgfSBlbHNlIG5hdGl2ZVNldCh0aGlzLCBrZXksIHZhbHVlKTtcblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cdCAgfSk7XG5cdH1cblxuXHR2YXIgSVRFUkFUT1IkNiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcblx0dmFyIFRPX1NUUklOR19UQUckMyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcblx0dmFyIEFycmF5VmFsdWVzID0gZXNfYXJyYXlfaXRlcmF0b3IudmFsdWVzO1xuXG5cdHZhciBoYW5kbGVQcm90b3R5cGUkMSA9IGZ1bmN0aW9uIChDb2xsZWN0aW9uUHJvdG90eXBlLCBDT0xMRUNUSU9OX05BTUUpIHtcblx0ICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZSkge1xuXHQgICAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XG5cdCAgICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUiQ2XSAhPT0gQXJyYXlWYWx1ZXMpIHRyeSB7XG5cdCAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDb2xsZWN0aW9uUHJvdG90eXBlLCBJVEVSQVRPUiQ2LCBBcnJheVZhbHVlcyk7XG5cdCAgICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgICBDb2xsZWN0aW9uUHJvdG90eXBlW0lURVJBVE9SJDZdID0gQXJyYXlWYWx1ZXM7XG5cdCAgICB9XG5cdCAgICBpZiAoIUNvbGxlY3Rpb25Qcm90b3R5cGVbVE9fU1RSSU5HX1RBRyQzXSkge1xuXHQgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRyQzLCBDT0xMRUNUSU9OX05BTUUpO1xuXHQgICAgfVxuXHQgICAgaWYgKGRvbUl0ZXJhYmxlc1tDT0xMRUNUSU9OX05BTUVdKSBmb3IgKHZhciBNRVRIT0RfTkFNRSBpbiBlc19hcnJheV9pdGVyYXRvcikge1xuXHQgICAgICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3Rcblx0ICAgICAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdICE9PSBlc19hcnJheV9pdGVyYXRvcltNRVRIT0RfTkFNRV0pIHRyeSB7XG5cdCAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsIE1FVEhPRF9OQU1FLCBlc19hcnJheV9pdGVyYXRvcltNRVRIT0RfTkFNRV0pO1xuXHQgICAgICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdID0gZXNfYXJyYXlfaXRlcmF0b3JbTUVUSE9EX05BTUVdO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdGZvciAodmFyIENPTExFQ1RJT05fTkFNRSQxIGluIGRvbUl0ZXJhYmxlcykge1xuXHQgIGhhbmRsZVByb3RvdHlwZSQxKGdsb2JhbF8xW0NPTExFQ1RJT05fTkFNRSQxXSAmJiBnbG9iYWxfMVtDT0xMRUNUSU9OX05BTUUkMV0ucHJvdG90eXBlLCBDT0xMRUNUSU9OX05BTUUkMSk7XG5cdH1cblxuXHRoYW5kbGVQcm90b3R5cGUkMShkb21Ub2tlbkxpc3RQcm90b3R5cGUsICdET01Ub2tlbkxpc3QnKTtcblxuXHQvKipcblx0ICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuXHQgKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2Bcblx0ICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG5cdCAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cblx0ICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cblx0ICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG5cdCAqL1xuXG5cdC8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXG5cdHZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cblx0LyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG5cdHZhciBOQU4gPSAwIC8gMDtcblxuXHQvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG5cdHZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuXHQvKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xuXHR2YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cblx0LyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cblx0dmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuXHQvKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG5cdHZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG5cdC8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xuXHR2YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuXHQvKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xuXHR2YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgY29tbW9uanNHbG9iYWw7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cblx0dmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cblx0LyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG5cdHZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5cdC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cblx0dmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuXHQvKipcblx0ICogVXNlZCB0byByZXNvbHZlIHRoZVxuXHQgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcblx0ICogb2YgdmFsdWVzLlxuXHQgKi9cblx0dmFyIG9iamVjdFRvU3RyaW5nJDEgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuXHQvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG5cdHZhciBuYXRpdmVNYXggPSBNYXRoLm1heCxcblx0ICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2Vcblx0ICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDIuNC4wXG5cdCAqIEBjYXRlZ29yeSBEYXRlXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuXHQgKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG5cdCAqIH0sIF8ubm93KCkpO1xuXHQgKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuXHQgKi9cblx0dmFyIG5vdyA9IGZ1bmN0aW9uKCkge1xuXHQgIHJldHVybiByb290LkRhdGUubm93KCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuXHQgKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcblx0ICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuXHQgKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cblx0ICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG5cdCAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcblx0ICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuXHQgKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuXHQgKiBpbnZvY2F0aW9uLlxuXHQgKlxuXHQgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG5cdCAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG5cdCAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cblx0ICpcblx0ICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG5cdCAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cblx0ICpcblx0ICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG5cdCAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDAuMS4wXG5cdCAqIEBjYXRlZ29yeSBGdW5jdGlvblxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cblx0ICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuXHQgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cblx0ICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG5cdCAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG5cdCAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG5cdCAqXG5cdCAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuXHQgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG5cdCAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuXHQgKiAgICd0cmFpbGluZyc6IGZhbHNlXG5cdCAqIH0pKTtcblx0ICpcblx0ICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cblx0ICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG5cdCAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcblx0ICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuXHQgKlxuXHQgKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuXHQgKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcblx0ICovXG5cdGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcblx0ICB2YXIgbGFzdEFyZ3MsXG5cdCAgICAgIGxhc3RUaGlzLFxuXHQgICAgICBtYXhXYWl0LFxuXHQgICAgICByZXN1bHQsXG5cdCAgICAgIHRpbWVySWQsXG5cdCAgICAgIGxhc3RDYWxsVGltZSxcblx0ICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuXHQgICAgICBsZWFkaW5nID0gZmFsc2UsXG5cdCAgICAgIG1heGluZyA9IGZhbHNlLFxuXHQgICAgICB0cmFpbGluZyA9IHRydWU7XG5cblx0ICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuXHQgIH1cblx0ICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcblx0ICBpZiAoaXNPYmplY3QkMShvcHRpb25zKSkge1xuXHQgICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuXHQgICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG5cdCAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuXHQgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcblx0ICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG5cdCAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG5cdCAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuXHQgICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuXHQgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuXHQgICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cblx0ICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcblx0ICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG5cdCAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuXHQgICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG5cdCAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG5cdCAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuXHQgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG5cdCAgICAgICAgcmVzdWx0ID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG5cdCAgICByZXR1cm4gbWF4aW5nID8gbmF0aXZlTWluKHJlc3VsdCwgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpIDogcmVzdWx0O1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG5cdCAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuXHQgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cblx0ICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG5cdCAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuXHQgICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuXHQgICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcblx0ICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG5cdCAgICB2YXIgdGltZSA9IG5vdygpO1xuXHQgICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuXHQgICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuXHQgICAgfVxuXHQgICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG5cdCAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG5cdCAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG5cdCAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG5cdCAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cblx0ICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuXHQgICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcblx0ICAgIH1cblx0ICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGNhbmNlbCgpIHtcblx0ICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuXHQgICAgfVxuXHQgICAgbGFzdEludm9rZVRpbWUgPSAwO1xuXHQgICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZmx1c2goKSB7XG5cdCAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG5cdCAgICB2YXIgdGltZSA9IG5vdygpLFxuXHQgICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cblx0ICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuXHQgICAgbGFzdFRoaXMgPSB0aGlzO1xuXHQgICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuXHQgICAgaWYgKGlzSW52b2tpbmcpIHtcblx0ICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChtYXhpbmcpIHtcblx0ICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuXHQgICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG5cdCAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9XG5cdCAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcblx0ICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcblx0ICByZXR1cm4gZGVib3VuY2VkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXJcblx0ICogZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gVGhlIHRocm90dGxlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGBcblx0ICogbWV0aG9kIHRvIGNhbmNlbCBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0b1xuXHQgKiBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS4gUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Bcblx0ICogc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YFxuXHQgKiB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQgd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlXG5cdCAqIHRocm90dGxlZCBmdW5jdGlvbi4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcblx0ICogcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuXHQgKlxuXHQgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG5cdCAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXG5cdCAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cblx0ICpcblx0ICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG5cdCAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cblx0ICpcblx0ICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG5cdCAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8udGhyb3R0bGVgIGFuZCBgXy5kZWJvdW5jZWAuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDAuMS4wXG5cdCAqIEBjYXRlZ29yeSBGdW5jdGlvblxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cblx0ICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdXG5cdCAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cblx0ICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG5cdCAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogLy8gQXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZy5cblx0ICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuXHQgKlxuXHQgKiAvLyBJbnZva2UgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlcy5cblx0ICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7ICd0cmFpbGluZyc6IGZhbHNlIH0pO1xuXHQgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdGhyb3R0bGVkKTtcblx0ICpcblx0ICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyB0aHJvdHRsZWQgaW52b2NhdGlvbi5cblx0ICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhyb3R0bGVkLmNhbmNlbCk7XG5cdCAqL1xuXHRmdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG5cdCAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuXHQgICAgICB0cmFpbGluZyA9IHRydWU7XG5cblx0ICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuXHQgIH1cblx0ICBpZiAoaXNPYmplY3QkMShvcHRpb25zKSkge1xuXHQgICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuXHQgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcblx0ICB9XG5cdCAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIHtcblx0ICAgICdsZWFkaW5nJzogbGVhZGluZyxcblx0ICAgICdtYXhXYWl0Jzogd2FpdCxcblx0ICAgICd0cmFpbGluZyc6IHRyYWlsaW5nXG5cdCAgfSk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG5cdCAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcblx0ICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSAwLjEuMFxuXHQgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8uaXNPYmplY3Qoe30pO1xuXHQgKiAvLyA9PiB0cnVlXG5cdCAqXG5cdCAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcblx0ICogLy8gPT4gdHJ1ZVxuXHQgKlxuXHQgKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG5cdCAqIC8vID0+IHRydWVcblx0ICpcblx0ICogXy5pc09iamVjdChudWxsKTtcblx0ICogLy8gPT4gZmFsc2Vcblx0ICovXG5cdGZ1bmN0aW9uIGlzT2JqZWN0JDEodmFsdWUpIHtcblx0ICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblx0ICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuXHQgKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDQuMC4wXG5cdCAqIEBjYXRlZ29yeSBMYW5nXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG5cdCAqIC8vID0+IHRydWVcblx0ICpcblx0ICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcblx0ICogLy8gPT4gdHJ1ZVxuXHQgKlxuXHQgKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuXHQgKiAvLyA9PiBmYWxzZVxuXHQgKlxuXHQgKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcblx0ICogLy8gPT4gZmFsc2Vcblx0ICovXG5cdGZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuXHQgIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgNC4wLjBcblx0ICogQGNhdGVnb3J5IExhbmdcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcblx0ICogLy8gPT4gdHJ1ZVxuXHQgKlxuXHQgKiBfLmlzU3ltYm9sKCdhYmMnKTtcblx0ICogLy8gPT4gZmFsc2Vcblx0ICovXG5cdGZ1bmN0aW9uIGlzU3ltYm9sJDEodmFsdWUpIHtcblx0ICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG5cdCAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZyQxLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgNC4wLjBcblx0ICogQGNhdGVnb3J5IExhbmdcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cblx0ICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiBfLnRvTnVtYmVyKDMuMik7XG5cdCAqIC8vID0+IDMuMlxuXHQgKlxuXHQgKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuXHQgKiAvLyA9PiA1ZS0zMjRcblx0ICpcblx0ICogXy50b051bWJlcihJbmZpbml0eSk7XG5cdCAqIC8vID0+IEluZmluaXR5XG5cdCAqXG5cdCAqIF8udG9OdW1iZXIoJzMuMicpO1xuXHQgKiAvLyA9PiAzLjJcblx0ICovXG5cdGZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG5cdCAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH1cblx0ICBpZiAoaXNTeW1ib2wkMSh2YWx1ZSkpIHtcblx0ICAgIHJldHVybiBOQU47XG5cdCAgfVxuXHQgIGlmIChpc09iamVjdCQxKHZhbHVlKSkge1xuXHQgICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuXHQgICAgdmFsdWUgPSBpc09iamVjdCQxKG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuXHQgIH1cblx0ICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG5cdCAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcblx0ICB9XG5cdCAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuXHQgIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG5cdCAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG5cdCAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcblx0ICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xuXHR9XG5cblx0dmFyIGxvZGFzaF90aHJvdHRsZSA9IHRocm90dGxlO1xuXG5cdC8qKlxuXHQgKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG5cdCAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuXHQgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cblx0ICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuXHQgKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuXHQgKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcblx0ICovXG5cblx0LyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cblx0dmFyIEZVTkNfRVJST1JfVEVYVCQxID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG5cdC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xuXHR2YXIgTkFOJDEgPSAwIC8gMDtcblxuXHQvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG5cdHZhciBzeW1ib2xUYWckMSA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG5cdC8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG5cdHZhciByZVRyaW0kMSA9IC9eXFxzK3xcXHMrJC9nO1xuXG5cdC8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG5cdHZhciByZUlzQmFkSGV4JDEgPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuXHQvKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG5cdHZhciByZUlzQmluYXJ5JDEgPSAvXjBiWzAxXSskL2k7XG5cblx0LyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG5cdHZhciByZUlzT2N0YWwkMSA9IC9eMG9bMC03XSskL2k7XG5cblx0LyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cblx0dmFyIGZyZWVQYXJzZUludCQxID0gcGFyc2VJbnQ7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cblx0dmFyIGZyZWVHbG9iYWwkMSA9IHR5cGVvZiBjb21tb25qc0dsb2JhbCA9PSAnb2JqZWN0JyAmJiBjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBjb21tb25qc0dsb2JhbDtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xuXHR2YXIgZnJlZVNlbGYkMSA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG5cdC8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xuXHR2YXIgcm9vdCQxID0gZnJlZUdsb2JhbCQxIHx8IGZyZWVTZWxmJDEgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuXHQvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cdHZhciBvYmplY3RQcm90byQxID0gT2JqZWN0LnByb3RvdHlwZTtcblxuXHQvKipcblx0ICogVXNlZCB0byByZXNvbHZlIHRoZVxuXHQgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcblx0ICogb2YgdmFsdWVzLlxuXHQgKi9cblx0dmFyIG9iamVjdFRvU3RyaW5nJDIgPSBvYmplY3RQcm90byQxLnRvU3RyaW5nO1xuXG5cdC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cblx0dmFyIG5hdGl2ZU1heCQxID0gTWF0aC5tYXgsXG5cdCAgICBuYXRpdmVNaW4kMSA9IE1hdGgubWluO1xuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2Vcblx0ICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDIuNC4wXG5cdCAqIEBjYXRlZ29yeSBEYXRlXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuXHQgKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG5cdCAqIH0sIF8ubm93KCkpO1xuXHQgKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuXHQgKi9cblx0dmFyIG5vdyQxID0gZnVuY3Rpb24oKSB7XG5cdCAgcmV0dXJuIHJvb3QkMS5EYXRlLm5vdygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcblx0ICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG5cdCAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcblx0ICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG5cdCAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuXHQgKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG5cdCAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcblx0ICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2Bcblx0ICogaW52b2NhdGlvbi5cblx0ICpcblx0ICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuXHQgKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuXHQgKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG5cdCAqXG5cdCAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuXHQgKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG5cdCAqXG5cdCAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuXHQgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSAwLjEuMFxuXHQgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cblx0ICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG5cdCAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cblx0ICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuXHQgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cblx0ICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuXHQgKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuXHQgKlxuXHQgKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cblx0ICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuXHQgKiAgICdsZWFkaW5nJzogdHJ1ZSxcblx0ICogICAndHJhaWxpbmcnOiBmYWxzZVxuXHQgKiB9KSk7XG5cdCAqXG5cdCAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG5cdCAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuXHQgKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG5cdCAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcblx0ICpcblx0ICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cblx0ICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG5cdCAqL1xuXHRmdW5jdGlvbiBkZWJvdW5jZSQxKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcblx0ICB2YXIgbGFzdEFyZ3MsXG5cdCAgICAgIGxhc3RUaGlzLFxuXHQgICAgICBtYXhXYWl0LFxuXHQgICAgICByZXN1bHQsXG5cdCAgICAgIHRpbWVySWQsXG5cdCAgICAgIGxhc3RDYWxsVGltZSxcblx0ICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuXHQgICAgICBsZWFkaW5nID0gZmFsc2UsXG5cdCAgICAgIG1heGluZyA9IGZhbHNlLFxuXHQgICAgICB0cmFpbGluZyA9IHRydWU7XG5cblx0ICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQkMSk7XG5cdCAgfVxuXHQgIHdhaXQgPSB0b051bWJlciQxKHdhaXQpIHx8IDA7XG5cdCAgaWYgKGlzT2JqZWN0JDIob3B0aW9ucykpIHtcblx0ICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcblx0ICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuXHQgICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCQxKHRvTnVtYmVyJDEob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG5cdCAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuXHQgICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcblx0ICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cblx0ICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG5cdCAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG5cdCAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG5cdCAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuXHQgICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuXHQgICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cblx0ICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG5cdCAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cblx0ICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcblx0ICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG5cdCAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcblx0ICAgICAgICByZXN1bHQgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cblx0ICAgIHJldHVybiBtYXhpbmcgPyBuYXRpdmVNaW4kMShyZXN1bHQsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKSA6IHJlc3VsdDtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuXHQgICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcblx0ICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuXG5cdCAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuXHQgICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcblx0ICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cblx0ICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG5cdCAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuXHQgICAgdmFyIHRpbWUgPSBub3ckMSgpO1xuXHQgICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuXHQgICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuXHQgICAgfVxuXHQgICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG5cdCAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG5cdCAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG5cdCAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG5cdCAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cblx0ICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuXHQgICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcblx0ICAgIH1cblx0ICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGNhbmNlbCgpIHtcblx0ICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuXHQgICAgfVxuXHQgICAgbGFzdEludm9rZVRpbWUgPSAwO1xuXHQgICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZmx1c2goKSB7XG5cdCAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdyQxKCkpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcblx0ICAgIHZhciB0aW1lID0gbm93JDEoKSxcblx0ICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG5cdCAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcblx0ICAgIGxhc3RUaGlzID0gdGhpcztcblx0ICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cblx0ICAgIGlmIChpc0ludm9raW5nKSB7XG5cdCAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAobWF4aW5nKSB7XG5cdCAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cblx0ICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuXHQgICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfVxuXHQgIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG5cdCAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG5cdCAgcmV0dXJuIGRlYm91bmNlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcblx0ICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuXHQgKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDAuMS4wXG5cdCAqIEBjYXRlZ29yeSBMYW5nXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogXy5pc09iamVjdCh7fSk7XG5cdCAqIC8vID0+IHRydWVcblx0ICpcblx0ICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuXHQgKiAvLyA9PiB0cnVlXG5cdCAqXG5cdCAqIF8uaXNPYmplY3QoXy5ub29wKTtcblx0ICogLy8gPT4gdHJ1ZVxuXHQgKlxuXHQgKiBfLmlzT2JqZWN0KG51bGwpO1xuXHQgKiAvLyA9PiBmYWxzZVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNPYmplY3QkMih2YWx1ZSkge1xuXHQgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXHQgIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG5cdCAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgNC4wLjBcblx0ICogQGNhdGVnb3J5IExhbmdcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8uaXNPYmplY3RMaWtlKHt9KTtcblx0ICogLy8gPT4gdHJ1ZVxuXHQgKlxuXHQgKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuXHQgKiAvLyA9PiB0cnVlXG5cdCAqXG5cdCAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG5cdCAqIC8vID0+IGZhbHNlXG5cdCAqXG5cdCAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuXHQgKiAvLyA9PiBmYWxzZVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNPYmplY3RMaWtlJDEodmFsdWUpIHtcblx0ICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDQuMC4wXG5cdCAqIEBjYXRlZ29yeSBMYW5nXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG5cdCAqIC8vID0+IHRydWVcblx0ICpcblx0ICogXy5pc1N5bWJvbCgnYWJjJyk7XG5cdCAqIC8vID0+IGZhbHNlXG5cdCAqL1xuXHRmdW5jdGlvbiBpc1N5bWJvbCQyKHZhbHVlKSB7XG5cdCAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuXHQgICAgKGlzT2JqZWN0TGlrZSQxKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZyQyLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyQxKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSA0LjAuMFxuXHQgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8udG9OdW1iZXIoMy4yKTtcblx0ICogLy8gPT4gMy4yXG5cdCAqXG5cdCAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG5cdCAqIC8vID0+IDVlLTMyNFxuXHQgKlxuXHQgKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcblx0ICogLy8gPT4gSW5maW5pdHlcblx0ICpcblx0ICogXy50b051bWJlcignMy4yJyk7XG5cdCAqIC8vID0+IDMuMlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9OdW1iZXIkMSh2YWx1ZSkge1xuXHQgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9XG5cdCAgaWYgKGlzU3ltYm9sJDIodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gTkFOJDE7XG5cdCAgfVxuXHQgIGlmIChpc09iamVjdCQyKHZhbHVlKSkge1xuXHQgICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuXHQgICAgdmFsdWUgPSBpc09iamVjdCQyKG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuXHQgIH1cblx0ICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG5cdCAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcblx0ICB9XG5cdCAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSQxLCAnJyk7XG5cdCAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeSQxLnRlc3QodmFsdWUpO1xuXHQgIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsJDEudGVzdCh2YWx1ZSkpXG5cdCAgICA/IGZyZWVQYXJzZUludCQxKHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuXHQgICAgOiAocmVJc0JhZEhleCQxLnRlc3QodmFsdWUpID8gTkFOJDEgOiArdmFsdWUpO1xuXHR9XG5cblx0dmFyIGxvZGFzaF9kZWJvdW5jZSA9IGRlYm91bmNlJDE7XG5cblx0LyoqXG5cdCAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cblx0ICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG5cdCAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuXHQgKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG5cdCAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG5cdCAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuXHQgKi9cblxuXHQvKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xuXHR2YXIgRlVOQ19FUlJPUl9URVhUJDIgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cblx0LyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xuXHR2YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cblx0LyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuXHR2YXIgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG5cdCAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xuXG5cdC8qKlxuXHQgKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG5cdCAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuXHQgKi9cblx0dmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuXHQvKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG5cdHZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG5cdHZhciBmcmVlR2xvYmFsJDIgPSB0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgY29tbW9uanNHbG9iYWw7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cblx0dmFyIGZyZWVTZWxmJDIgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuXHQvKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cblx0dmFyIHJvb3QkMiA9IGZyZWVHbG9iYWwkMiB8fCBmcmVlU2VsZiQyIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG5cdCAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG5cdCAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCBpbiBJRSA8IDkuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG5cdCAqL1xuXHRmdW5jdGlvbiBpc0hvc3RPYmplY3QodmFsdWUpIHtcblx0ICAvLyBNYW55IGhvc3Qgb2JqZWN0cyBhcmUgYE9iamVjdGAgb2JqZWN0cyB0aGF0IGNhbiBjb2VyY2UgdG8gc3RyaW5nc1xuXHQgIC8vIGRlc3BpdGUgaGF2aW5nIGltcHJvcGVybHkgZGVmaW5lZCBgdG9TdHJpbmdgIG1ldGhvZHMuXG5cdCAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuXHQgIGlmICh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICByZXN1bHQgPSAhISh2YWx1ZSArICcnKTtcblx0ICAgIH0gY2F0Y2ggKGUpIHt9XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cdHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuXHQgICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuXHQgICAgb2JqZWN0UHJvdG8kMiA9IE9iamVjdC5wcm90b3R5cGU7XG5cblx0LyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xuXHR2YXIgY29yZUpzRGF0YSA9IHJvb3QkMlsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cblx0LyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cblx0dmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcblx0ICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG5cdH0oKSk7XG5cblx0LyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xuXHR2YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG5cdC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuXHR2YXIgaGFzT3duUHJvcGVydHkkMSA9IG9iamVjdFByb3RvJDIuaGFzT3duUHJvcGVydHk7XG5cblx0LyoqXG5cdCAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcblx0ICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG5cdCAqIG9mIHZhbHVlcy5cblx0ICovXG5cdHZhciBvYmplY3RUb1N0cmluZyQzID0gb2JqZWN0UHJvdG8kMi50b1N0cmluZztcblxuXHQvKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xuXHR2YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuXHQgIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5JDEpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcblx0ICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcblx0KTtcblxuXHQvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cblx0dmFyIHNwbGljZSQxID0gYXJyYXlQcm90by5zcGxpY2U7XG5cblx0LyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xuXHR2YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QkMiwgJ01hcCcpLFxuXHQgICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cblx0ICovXG5cdGZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuXHQgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG5cdCAgdGhpcy5jbGVhcigpO1xuXHQgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcblx0ICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIGNsZWFyXG5cdCAqIEBtZW1iZXJPZiBIYXNoXG5cdCAqL1xuXHRmdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG5cdCAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbmFtZSBkZWxldGVcblx0ICogQG1lbWJlck9mIEhhc2hcblx0ICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcblx0ICByZXR1cm4gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbmFtZSBnZXRcblx0ICogQG1lbWJlck9mIEhhc2hcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG5cdCAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG5cdCAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuXHQgIGlmIChuYXRpdmVDcmVhdGUpIHtcblx0ICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG5cdCAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcblx0ICB9XG5cdCAgcmV0dXJuIGhhc093blByb3BlcnR5JDEuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgaGFzXG5cdCAqIEBtZW1iZXJPZiBIYXNoXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG5cdCAqL1xuXHRmdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuXHQgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcblx0ICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gZGF0YVtrZXldICE9PSB1bmRlZmluZWQgOiBoYXNPd25Qcm9wZXJ0eSQxLmNhbGwoZGF0YSwga2V5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIHNldFxuXHQgKiBAbWVtYmVyT2YgSGFzaFxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuXHQgKi9cblx0ZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG5cdCAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuXHQgIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuXHQgIHJldHVybiB0aGlzO1xuXHR9XG5cblx0Ly8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuXHRIYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcblx0SGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcblx0SGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcblx0SGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcblx0SGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuXHQgKi9cblx0ZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcblx0ICB2YXIgaW5kZXggPSAtMSxcblx0ICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuXHQgIHRoaXMuY2xlYXIoKTtcblx0ICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG5cdCAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuXHQgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbmFtZSBjbGVhclxuXHQgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG5cdCAqL1xuXHRmdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcblx0ICB0aGlzLl9fZGF0YV9fID0gW107XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIGRlbGV0ZVxuXHQgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG5cdCAqL1xuXHRmdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG5cdCAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuXHQgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG5cdCAgaWYgKGluZGV4IDwgMCkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0ICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuXHQgIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcblx0ICAgIGRhdGEucG9wKCk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHNwbGljZSQxLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuXHQgIH1cblx0ICByZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgZ2V0XG5cdCAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG5cdCAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcblx0ICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG5cdCAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cblx0ICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbmFtZSBoYXNcblx0ICogQG1lbWJlck9mIExpc3RDYWNoZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuXHQgIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgc2V0XG5cdCAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cblx0ICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cblx0ICovXG5cdGZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG5cdCAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuXHQgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG5cdCAgaWYgKGluZGV4IDwgMCkge1xuXHQgICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiB0aGlzO1xuXHR9XG5cblx0Ly8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5cdExpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcblx0TGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5cdExpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuXHRMaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcblx0TGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuXHQgKi9cblx0ZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuXHQgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG5cdCAgdGhpcy5jbGVhcigpO1xuXHQgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcblx0ICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgY2xlYXJcblx0ICogQG1lbWJlck9mIE1hcENhY2hlXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuXHQgIHRoaXMuX19kYXRhX18gPSB7XG5cdCAgICAnaGFzaCc6IG5ldyBIYXNoLFxuXHQgICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG5cdCAgICAnc3RyaW5nJzogbmV3IEhhc2hcblx0ICB9O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIGRlbGV0ZVxuXHQgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuXHQgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgZ2V0XG5cdCAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cblx0ICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG5cdCAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgaGFzXG5cdCAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG5cdCAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgc2V0XG5cdCAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG5cdCAgZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLnNldChrZXksIHZhbHVlKTtcblx0ICByZXR1cm4gdGhpcztcblx0fVxuXG5cdC8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5cdE1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5cdE1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcblx0TWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuXHRNYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5cdE1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuXHQvKipcblx0ICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cblx0ICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuXHQgKi9cblx0ZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcblx0ICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHQgIHdoaWxlIChsZW5ndGgtLSkge1xuXHQgICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcblx0ICAgICAgcmV0dXJuIGxlbmd0aDtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIC0xO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuXHQgKiAgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG5cdCAgaWYgKCFpc09iamVjdCQzKHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdCAgdmFyIHBhdHRlcm4gPSAoaXNGdW5jdGlvbih2YWx1ZSkgfHwgaXNIb3N0T2JqZWN0KHZhbHVlKSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuXHQgIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuXHQgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG5cdCAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG5cdCAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG5cdCAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuXHQgICAgOiBkYXRhLm1hcDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuXHQgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcblx0ICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG5cdCAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cblx0ICovXG5cdGZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuXHQgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXHQgIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG5cdCAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG5cdCAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuXHQgIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcHJvY2Vzcy5cblx0ICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG5cdCAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuXHQgICAgdHJ5IHtcblx0ICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuXHQgICAgfSBjYXRjaCAoZSkge31cblx0ICAgIHRyeSB7XG5cdCAgICAgIHJldHVybiAoZnVuYyArICcnKTtcblx0ICAgIH0gY2F0Y2ggKGUpIHt9XG5cdCAgfVxuXHQgIHJldHVybiAnJztcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuXHQgKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG5cdCAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuXHQgKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuXHQgKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cblx0ICpcblx0ICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuXHQgKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcblx0ICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcblx0ICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcblx0ICogbWV0aG9kIGludGVyZmFjZSBvZiBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDAuMS4wXG5cdCAqIEBjYXRlZ29yeSBGdW5jdGlvblxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cblx0ICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG5cdCAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcblx0ICpcblx0ICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG5cdCAqIHZhbHVlcyhvYmplY3QpO1xuXHQgKiAvLyA9PiBbMSwgMl1cblx0ICpcblx0ICogdmFsdWVzKG90aGVyKTtcblx0ICogLy8gPT4gWzMsIDRdXG5cdCAqXG5cdCAqIG9iamVjdC5hID0gMjtcblx0ICogdmFsdWVzKG9iamVjdCk7XG5cdCAqIC8vID0+IFsxLCAyXVxuXHQgKlxuXHQgKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cblx0ICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuXHQgKiB2YWx1ZXMob2JqZWN0KTtcblx0ICogLy8gPT4gWydhJywgJ2InXVxuXHQgKlxuXHQgKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuXHQgKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuXHQgKi9cblx0ZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuXHQgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcblx0ICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUJDIpO1xuXHQgIH1cblx0ICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuXHQgICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuXHQgICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cblx0ICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuXHQgICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG5cdCAgICB9XG5cdCAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcblx0ICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KTtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfTtcblx0ICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG5cdCAgcmV0dXJuIG1lbW9pemVkO1xuXHR9XG5cblx0Ly8gQXNzaWduIGNhY2hlIHRvIGBfLm1lbW9pemVgLlxuXHRtZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cblx0LyoqXG5cdCAqIFBlcmZvcm1zIGFcblx0ICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcblx0ICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDQuMC4wXG5cdCAqIEBjYXRlZ29yeSBMYW5nXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG5cdCAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuXHQgKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuXHQgKlxuXHQgKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcblx0ICogLy8gPT4gdHJ1ZVxuXHQgKlxuXHQgKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuXHQgKiAvLyA9PiBmYWxzZVxuXHQgKlxuXHQgKiBfLmVxKCdhJywgJ2EnKTtcblx0ICogLy8gPT4gdHJ1ZVxuXHQgKlxuXHQgKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuXHQgKiAvLyA9PiBmYWxzZVxuXHQgKlxuXHQgKiBfLmVxKE5hTiwgTmFOKTtcblx0ICogLy8gPT4gdHJ1ZVxuXHQgKi9cblx0ZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG5cdCAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSAwLjEuMFxuXHQgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiBfLmlzRnVuY3Rpb24oXyk7XG5cdCAqIC8vID0+IHRydWVcblx0ICpcblx0ICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcblx0ICogLy8gPT4gZmFsc2Vcblx0ICovXG5cdGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcblx0ICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3Jcblx0ICAvLyBpbiBTYWZhcmkgOC05IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG5cdCAgdmFyIHRhZyA9IGlzT2JqZWN0JDModmFsdWUpID8gb2JqZWN0VG9TdHJpbmckMy5jYWxsKHZhbHVlKSA6ICcnO1xuXHQgIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuXHQgKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG5cdCAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgMC4xLjBcblx0ICogQGNhdGVnb3J5IExhbmdcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiBfLmlzT2JqZWN0KHt9KTtcblx0ICogLy8gPT4gdHJ1ZVxuXHQgKlxuXHQgKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG5cdCAqIC8vID0+IHRydWVcblx0ICpcblx0ICogXy5pc09iamVjdChfLm5vb3ApO1xuXHQgKiAvLyA9PiB0cnVlXG5cdCAqXG5cdCAqIF8uaXNPYmplY3QobnVsbCk7XG5cdCAqIC8vID0+IGZhbHNlXG5cdCAqL1xuXHRmdW5jdGlvbiBpc09iamVjdCQzKHZhbHVlKSB7XG5cdCAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cdCAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcblx0fVxuXG5cdHZhciBsb2Rhc2hfbWVtb2l6ZSA9IG1lbW9pemU7XG5cblx0dmFyIHJlc2l6ZU9ic2VydmVycyA9IFtdO1xuXG5cdHZhciBoYXNBY3RpdmVPYnNlcnZhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gcmVzaXplT2JzZXJ2ZXJzLnNvbWUoZnVuY3Rpb24gKHJvKSB7IHJldHVybiByby5hY3RpdmVUYXJnZXRzLmxlbmd0aCA+IDA7IH0pO1xuXHR9O1xuXG5cdHZhciBoYXNTa2lwcGVkT2JzZXJ2YXRpb25zID0gZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHJlc2l6ZU9ic2VydmVycy5zb21lKGZ1bmN0aW9uIChybykgeyByZXR1cm4gcm8uc2tpcHBlZFRhcmdldHMubGVuZ3RoID4gMDsgfSk7XG5cdH07XG5cblx0dmFyIG1zZyA9ICdSZXNpemVPYnNlcnZlciBsb29wIGNvbXBsZXRlZCB3aXRoIHVuZGVsaXZlcmVkIG5vdGlmaWNhdGlvbnMuJztcblx0dmFyIGRlbGl2ZXJSZXNpemVMb29wRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXZlbnQ7XG5cdCAgICBpZiAodHlwZW9mIEVycm9yRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICBldmVudCA9IG5ldyBFcnJvckV2ZW50KCdlcnJvcicsIHtcblx0ICAgICAgICAgICAgbWVzc2FnZTogbXNnXG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICBlbHNlIHtcblx0ICAgICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuXHQgICAgICAgIGV2ZW50LmluaXRFdmVudCgnZXJyb3InLCBmYWxzZSwgZmFsc2UpO1xuXHQgICAgICAgIGV2ZW50Lm1lc3NhZ2UgPSBtc2c7XG5cdCAgICB9XG5cdCAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH07XG5cblx0dmFyIFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucztcblx0KGZ1bmN0aW9uIChSZXNpemVPYnNlcnZlckJveE9wdGlvbnMpIHtcblx0ICAgIFJlc2l6ZU9ic2VydmVyQm94T3B0aW9uc1tcIkJPUkRFUl9CT1hcIl0gPSBcImJvcmRlci1ib3hcIjtcblx0ICAgIFJlc2l6ZU9ic2VydmVyQm94T3B0aW9uc1tcIkNPTlRFTlRfQk9YXCJdID0gXCJjb250ZW50LWJveFwiO1xuXHQgICAgUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zW1wiREVWSUNFX1BJWEVMX0NPTlRFTlRfQk9YXCJdID0gXCJkZXZpY2UtcGl4ZWwtY29udGVudC1ib3hcIjtcblx0fSkoUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zIHx8IChSZXNpemVPYnNlcnZlckJveE9wdGlvbnMgPSB7fSkpO1xuXG5cdHZhciBmcmVlemUgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBPYmplY3QuZnJlZXplKG9iaik7IH07XG5cblx0dmFyIFJlc2l6ZU9ic2VydmVyU2l6ZSA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlclNpemUoaW5saW5lU2l6ZSwgYmxvY2tTaXplKSB7XG5cdCAgICAgICAgdGhpcy5pbmxpbmVTaXplID0gaW5saW5lU2l6ZTtcblx0ICAgICAgICB0aGlzLmJsb2NrU2l6ZSA9IGJsb2NrU2l6ZTtcblx0ICAgICAgICBmcmVlemUodGhpcyk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXJTaXplO1xuXHR9KCkpO1xuXG5cdHZhciBET01SZWN0UmVhZE9ubHkgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gRE9NUmVjdFJlYWRPbmx5KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0ICAgICAgICB0aGlzLnggPSB4O1xuXHQgICAgICAgIHRoaXMueSA9IHk7XG5cdCAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuXHQgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHQgICAgICAgIHRoaXMudG9wID0gdGhpcy55O1xuXHQgICAgICAgIHRoaXMubGVmdCA9IHRoaXMueDtcblx0ICAgICAgICB0aGlzLmJvdHRvbSA9IHRoaXMudG9wICsgdGhpcy5oZWlnaHQ7XG5cdCAgICAgICAgdGhpcy5yaWdodCA9IHRoaXMubGVmdCArIHRoaXMud2lkdGg7XG5cdCAgICAgICAgcmV0dXJuIGZyZWV6ZSh0aGlzKTtcblx0ICAgIH1cblx0ICAgIERPTVJlY3RSZWFkT25seS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBfYSA9IHRoaXMsIHggPSBfYS54LCB5ID0gX2EueSwgdG9wID0gX2EudG9wLCByaWdodCA9IF9hLnJpZ2h0LCBib3R0b20gPSBfYS5ib3R0b20sIGxlZnQgPSBfYS5sZWZ0LCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XG5cdCAgICAgICAgcmV0dXJuIHsgeDogeCwgeTogeSwgdG9wOiB0b3AsIHJpZ2h0OiByaWdodCwgYm90dG9tOiBib3R0b20sIGxlZnQ6IGxlZnQsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcblx0ICAgIH07XG5cdCAgICBET01SZWN0UmVhZE9ubHkuZnJvbVJlY3QgPSBmdW5jdGlvbiAocmVjdGFuZ2xlKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBET01SZWN0UmVhZE9ubHkocmVjdGFuZ2xlLngsIHJlY3RhbmdsZS55LCByZWN0YW5nbGUud2lkdGgsIHJlY3RhbmdsZS5oZWlnaHQpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBET01SZWN0UmVhZE9ubHk7XG5cdH0oKSk7XG5cblx0dmFyIGlzU1ZHID0gZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudCAmJiAnZ2V0QkJveCcgaW4gdGFyZ2V0OyB9O1xuXHR2YXIgaXNIaWRkZW4gPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdCAgICBpZiAoaXNTVkcodGFyZ2V0KSkge1xuXHQgICAgICAgIHZhciBfYSA9IHRhcmdldC5nZXRCQm94KCksIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcblx0ICAgICAgICByZXR1cm4gIXdpZHRoICYmICFoZWlnaHQ7XG5cdCAgICB9XG5cdCAgICB2YXIgX2IgPSB0YXJnZXQsIG9mZnNldFdpZHRoID0gX2Iub2Zmc2V0V2lkdGgsIG9mZnNldEhlaWdodCA9IF9iLm9mZnNldEhlaWdodDtcblx0ICAgIHJldHVybiAhKG9mZnNldFdpZHRoIHx8IG9mZnNldEhlaWdodCB8fCB0YXJnZXQuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGgpO1xuXHR9O1xuXHR2YXIgaXNFbGVtZW50ID0gZnVuY3Rpb24gKG9iaikge1xuXHQgICAgdmFyIF9hLCBfYjtcblx0ICAgIGlmIChvYmogaW5zdGFuY2VvZiBFbGVtZW50KSB7XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgICB2YXIgc2NvcGUgPSAoX2IgPSAoX2EgPSBvYmopID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vd25lckRvY3VtZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGVmYXVsdFZpZXc7XG5cdCAgICByZXR1cm4gISEoc2NvcGUgJiYgb2JqIGluc3RhbmNlb2Ygc2NvcGUuRWxlbWVudCk7XG5cdH07XG5cdHZhciBpc1JlcGxhY2VkRWxlbWVudCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0ICAgIHN3aXRjaCAodGFyZ2V0LnRhZ05hbWUpIHtcblx0ICAgICAgICBjYXNlICdJTlBVVCc6XG5cdCAgICAgICAgICAgIGlmICh0YXJnZXQudHlwZSAhPT0gJ2ltYWdlJykge1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICBjYXNlICdWSURFTyc6XG5cdCAgICAgICAgY2FzZSAnQVVESU8nOlxuXHQgICAgICAgIGNhc2UgJ0VNQkVEJzpcblx0ICAgICAgICBjYXNlICdPQkpFQ1QnOlxuXHQgICAgICAgIGNhc2UgJ0NBTlZBUyc6XG5cdCAgICAgICAgY2FzZSAnSUZSQU1FJzpcblx0ICAgICAgICBjYXNlICdJTUcnOlxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBmYWxzZTtcblx0fTtcblxuXHR2YXIgZ2xvYmFsJDEgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9O1xuXG5cdHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5cdHZhciBzY3JvbGxSZWdleHAgPSAvYXV0b3xzY3JvbGwvO1xuXHR2YXIgdmVydGljYWxSZWdleHAgPSAvXnRifHZlcnRpY2FsLztcblx0dmFyIElFID0gKC9tc2llfHRyaWRlbnQvaSkudGVzdChnbG9iYWwkMS5uYXZpZ2F0b3IgJiYgZ2xvYmFsJDEubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cdHZhciBwYXJzZURpbWVuc2lvbiA9IGZ1bmN0aW9uIChwaXhlbCkgeyByZXR1cm4gcGFyc2VGbG9hdChwaXhlbCB8fCAnMCcpOyB9O1xuXHR2YXIgc2l6ZSA9IGZ1bmN0aW9uIChpbmxpbmVTaXplLCBibG9ja1NpemUsIHN3aXRjaFNpemVzKSB7XG5cdCAgICBpZiAoaW5saW5lU2l6ZSA9PT0gdm9pZCAwKSB7IGlubGluZVNpemUgPSAwOyB9XG5cdCAgICBpZiAoYmxvY2tTaXplID09PSB2b2lkIDApIHsgYmxvY2tTaXplID0gMDsgfVxuXHQgICAgaWYgKHN3aXRjaFNpemVzID09PSB2b2lkIDApIHsgc3dpdGNoU2l6ZXMgPSBmYWxzZTsgfVxuXHQgICAgcmV0dXJuIG5ldyBSZXNpemVPYnNlcnZlclNpemUoKHN3aXRjaFNpemVzID8gYmxvY2tTaXplIDogaW5saW5lU2l6ZSkgfHwgMCwgKHN3aXRjaFNpemVzID8gaW5saW5lU2l6ZSA6IGJsb2NrU2l6ZSkgfHwgMCk7XG5cdH07XG5cdHZhciB6ZXJvQm94ZXMgPSBmcmVlemUoe1xuXHQgICAgZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZTogc2l6ZSgpLFxuXHQgICAgYm9yZGVyQm94U2l6ZTogc2l6ZSgpLFxuXHQgICAgY29udGVudEJveFNpemU6IHNpemUoKSxcblx0ICAgIGNvbnRlbnRSZWN0OiBuZXcgRE9NUmVjdFJlYWRPbmx5KDAsIDAsIDAsIDApXG5cdH0pO1xuXHR2YXIgY2FsY3VsYXRlQm94U2l6ZXMgPSBmdW5jdGlvbiAodGFyZ2V0LCBmb3JjZVJlY2FsY3VsYXRpb24pIHtcblx0ICAgIGlmIChmb3JjZVJlY2FsY3VsYXRpb24gPT09IHZvaWQgMCkgeyBmb3JjZVJlY2FsY3VsYXRpb24gPSBmYWxzZTsgfVxuXHQgICAgaWYgKGNhY2hlLmhhcyh0YXJnZXQpICYmICFmb3JjZVJlY2FsY3VsYXRpb24pIHtcblx0ICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KHRhcmdldCk7XG5cdCAgICB9XG5cdCAgICBpZiAoaXNIaWRkZW4odGFyZ2V0KSkge1xuXHQgICAgICAgIGNhY2hlLnNldCh0YXJnZXQsIHplcm9Cb3hlcyk7XG5cdCAgICAgICAgcmV0dXJuIHplcm9Cb3hlcztcblx0ICAgIH1cblx0ICAgIHZhciBjcyA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KTtcblx0ICAgIHZhciBzdmcgPSBpc1NWRyh0YXJnZXQpICYmIHRhcmdldC5vd25lclNWR0VsZW1lbnQgJiYgdGFyZ2V0LmdldEJCb3goKTtcblx0ICAgIHZhciByZW1vdmVQYWRkaW5nID0gIUlFICYmIGNzLmJveFNpemluZyA9PT0gJ2JvcmRlci1ib3gnO1xuXHQgICAgdmFyIHN3aXRjaFNpemVzID0gdmVydGljYWxSZWdleHAudGVzdChjcy53cml0aW5nTW9kZSB8fCAnJyk7XG5cdCAgICB2YXIgY2FuU2Nyb2xsVmVydGljYWxseSA9ICFzdmcgJiYgc2Nyb2xsUmVnZXhwLnRlc3QoY3Mub3ZlcmZsb3dZIHx8ICcnKTtcblx0ICAgIHZhciBjYW5TY3JvbGxIb3Jpem9udGFsbHkgPSAhc3ZnICYmIHNjcm9sbFJlZ2V4cC50ZXN0KGNzLm92ZXJmbG93WCB8fCAnJyk7XG5cdCAgICB2YXIgcGFkZGluZ1RvcCA9IHN2ZyA/IDAgOiBwYXJzZURpbWVuc2lvbihjcy5wYWRkaW5nVG9wKTtcblx0ICAgIHZhciBwYWRkaW5nUmlnaHQgPSBzdmcgPyAwIDogcGFyc2VEaW1lbnNpb24oY3MucGFkZGluZ1JpZ2h0KTtcblx0ICAgIHZhciBwYWRkaW5nQm90dG9tID0gc3ZnID8gMCA6IHBhcnNlRGltZW5zaW9uKGNzLnBhZGRpbmdCb3R0b20pO1xuXHQgICAgdmFyIHBhZGRpbmdMZWZ0ID0gc3ZnID8gMCA6IHBhcnNlRGltZW5zaW9uKGNzLnBhZGRpbmdMZWZ0KTtcblx0ICAgIHZhciBib3JkZXJUb3AgPSBzdmcgPyAwIDogcGFyc2VEaW1lbnNpb24oY3MuYm9yZGVyVG9wV2lkdGgpO1xuXHQgICAgdmFyIGJvcmRlclJpZ2h0ID0gc3ZnID8gMCA6IHBhcnNlRGltZW5zaW9uKGNzLmJvcmRlclJpZ2h0V2lkdGgpO1xuXHQgICAgdmFyIGJvcmRlckJvdHRvbSA9IHN2ZyA/IDAgOiBwYXJzZURpbWVuc2lvbihjcy5ib3JkZXJCb3R0b21XaWR0aCk7XG5cdCAgICB2YXIgYm9yZGVyTGVmdCA9IHN2ZyA/IDAgOiBwYXJzZURpbWVuc2lvbihjcy5ib3JkZXJMZWZ0V2lkdGgpO1xuXHQgICAgdmFyIGhvcml6b250YWxQYWRkaW5nID0gcGFkZGluZ0xlZnQgKyBwYWRkaW5nUmlnaHQ7XG5cdCAgICB2YXIgdmVydGljYWxQYWRkaW5nID0gcGFkZGluZ1RvcCArIHBhZGRpbmdCb3R0b207XG5cdCAgICB2YXIgaG9yaXpvbnRhbEJvcmRlckFyZWEgPSBib3JkZXJMZWZ0ICsgYm9yZGVyUmlnaHQ7XG5cdCAgICB2YXIgdmVydGljYWxCb3JkZXJBcmVhID0gYm9yZGVyVG9wICsgYm9yZGVyQm90dG9tO1xuXHQgICAgdmFyIGhvcml6b250YWxTY3JvbGxiYXJUaGlja25lc3MgPSAhY2FuU2Nyb2xsSG9yaXpvbnRhbGx5ID8gMCA6IHRhcmdldC5vZmZzZXRIZWlnaHQgLSB2ZXJ0aWNhbEJvcmRlckFyZWEgLSB0YXJnZXQuY2xpZW50SGVpZ2h0O1xuXHQgICAgdmFyIHZlcnRpY2FsU2Nyb2xsYmFyVGhpY2tuZXNzID0gIWNhblNjcm9sbFZlcnRpY2FsbHkgPyAwIDogdGFyZ2V0Lm9mZnNldFdpZHRoIC0gaG9yaXpvbnRhbEJvcmRlckFyZWEgLSB0YXJnZXQuY2xpZW50V2lkdGg7XG5cdCAgICB2YXIgd2lkdGhSZWR1Y3Rpb24gPSByZW1vdmVQYWRkaW5nID8gaG9yaXpvbnRhbFBhZGRpbmcgKyBob3Jpem9udGFsQm9yZGVyQXJlYSA6IDA7XG5cdCAgICB2YXIgaGVpZ2h0UmVkdWN0aW9uID0gcmVtb3ZlUGFkZGluZyA/IHZlcnRpY2FsUGFkZGluZyArIHZlcnRpY2FsQm9yZGVyQXJlYSA6IDA7XG5cdCAgICB2YXIgY29udGVudFdpZHRoID0gc3ZnID8gc3ZnLndpZHRoIDogcGFyc2VEaW1lbnNpb24oY3Mud2lkdGgpIC0gd2lkdGhSZWR1Y3Rpb24gLSB2ZXJ0aWNhbFNjcm9sbGJhclRoaWNrbmVzcztcblx0ICAgIHZhciBjb250ZW50SGVpZ2h0ID0gc3ZnID8gc3ZnLmhlaWdodCA6IHBhcnNlRGltZW5zaW9uKGNzLmhlaWdodCkgLSBoZWlnaHRSZWR1Y3Rpb24gLSBob3Jpem9udGFsU2Nyb2xsYmFyVGhpY2tuZXNzO1xuXHQgICAgdmFyIGJvcmRlckJveFdpZHRoID0gY29udGVudFdpZHRoICsgaG9yaXpvbnRhbFBhZGRpbmcgKyB2ZXJ0aWNhbFNjcm9sbGJhclRoaWNrbmVzcyArIGhvcml6b250YWxCb3JkZXJBcmVhO1xuXHQgICAgdmFyIGJvcmRlckJveEhlaWdodCA9IGNvbnRlbnRIZWlnaHQgKyB2ZXJ0aWNhbFBhZGRpbmcgKyBob3Jpem9udGFsU2Nyb2xsYmFyVGhpY2tuZXNzICsgdmVydGljYWxCb3JkZXJBcmVhO1xuXHQgICAgdmFyIGJveGVzID0gZnJlZXplKHtcblx0ICAgICAgICBkZXZpY2VQaXhlbENvbnRlbnRCb3hTaXplOiBzaXplKE1hdGgucm91bmQoY29udGVudFdpZHRoICogZGV2aWNlUGl4ZWxSYXRpbyksIE1hdGgucm91bmQoY29udGVudEhlaWdodCAqIGRldmljZVBpeGVsUmF0aW8pLCBzd2l0Y2hTaXplcyksXG5cdCAgICAgICAgYm9yZGVyQm94U2l6ZTogc2l6ZShib3JkZXJCb3hXaWR0aCwgYm9yZGVyQm94SGVpZ2h0LCBzd2l0Y2hTaXplcyksXG5cdCAgICAgICAgY29udGVudEJveFNpemU6IHNpemUoY29udGVudFdpZHRoLCBjb250ZW50SGVpZ2h0LCBzd2l0Y2hTaXplcyksXG5cdCAgICAgICAgY29udGVudFJlY3Q6IG5ldyBET01SZWN0UmVhZE9ubHkocGFkZGluZ0xlZnQsIHBhZGRpbmdUb3AsIGNvbnRlbnRXaWR0aCwgY29udGVudEhlaWdodClcblx0ICAgIH0pO1xuXHQgICAgY2FjaGUuc2V0KHRhcmdldCwgYm94ZXMpO1xuXHQgICAgcmV0dXJuIGJveGVzO1xuXHR9O1xuXHR2YXIgY2FsY3VsYXRlQm94U2l6ZSA9IGZ1bmN0aW9uICh0YXJnZXQsIG9ic2VydmVkQm94LCBmb3JjZVJlY2FsY3VsYXRpb24pIHtcblx0ICAgIHZhciBfYSA9IGNhbGN1bGF0ZUJveFNpemVzKHRhcmdldCwgZm9yY2VSZWNhbGN1bGF0aW9uKSwgYm9yZGVyQm94U2l6ZSA9IF9hLmJvcmRlckJveFNpemUsIGNvbnRlbnRCb3hTaXplID0gX2EuY29udGVudEJveFNpemUsIGRldmljZVBpeGVsQ29udGVudEJveFNpemUgPSBfYS5kZXZpY2VQaXhlbENvbnRlbnRCb3hTaXplO1xuXHQgICAgc3dpdGNoIChvYnNlcnZlZEJveCkge1xuXHQgICAgICAgIGNhc2UgUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zLkRFVklDRV9QSVhFTF9DT05URU5UX0JPWDpcblx0ICAgICAgICAgICAgcmV0dXJuIGRldmljZVBpeGVsQ29udGVudEJveFNpemU7XG5cdCAgICAgICAgY2FzZSBSZXNpemVPYnNlcnZlckJveE9wdGlvbnMuQk9SREVSX0JPWDpcblx0ICAgICAgICAgICAgcmV0dXJuIGJvcmRlckJveFNpemU7XG5cdCAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRCb3hTaXplO1xuXHQgICAgfVxuXHR9O1xuXG5cdHZhciBSZXNpemVPYnNlcnZlckVudHJ5ID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyRW50cnkodGFyZ2V0KSB7XG5cdCAgICAgICAgdmFyIGJveGVzID0gY2FsY3VsYXRlQm94U2l6ZXModGFyZ2V0KTtcblx0ICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcblx0ICAgICAgICB0aGlzLmNvbnRlbnRSZWN0ID0gYm94ZXMuY29udGVudFJlY3Q7XG5cdCAgICAgICAgdGhpcy5ib3JkZXJCb3hTaXplID0gZnJlZXplKFtib3hlcy5ib3JkZXJCb3hTaXplXSk7XG5cdCAgICAgICAgdGhpcy5jb250ZW50Qm94U2l6ZSA9IGZyZWV6ZShbYm94ZXMuY29udGVudEJveFNpemVdKTtcblx0ICAgICAgICB0aGlzLmRldmljZVBpeGVsQ29udGVudEJveFNpemUgPSBmcmVlemUoW2JveGVzLmRldmljZVBpeGVsQ29udGVudEJveFNpemVdKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBSZXNpemVPYnNlcnZlckVudHJ5O1xuXHR9KCkpO1xuXG5cdHZhciBjYWxjdWxhdGVEZXB0aEZvck5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgaWYgKGlzSGlkZGVuKG5vZGUpKSB7XG5cdCAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuXHQgICAgfVxuXHQgICAgdmFyIGRlcHRoID0gMDtcblx0ICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG5cdCAgICB3aGlsZSAocGFyZW50KSB7XG5cdCAgICAgICAgZGVwdGggKz0gMTtcblx0ICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBkZXB0aDtcblx0fTtcblxuXHR2YXIgYnJvYWRjYXN0QWN0aXZlT2JzZXJ2YXRpb25zID0gZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHNoYWxsb3dlc3REZXB0aCA9IEluZmluaXR5O1xuXHQgICAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuXHQgICAgcmVzaXplT2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24gcHJvY2Vzc09ic2VydmVyKHJvKSB7XG5cdCAgICAgICAgaWYgKHJvLmFjdGl2ZVRhcmdldHMubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGVudHJpZXMgPSBbXTtcblx0ICAgICAgICByby5hY3RpdmVUYXJnZXRzLmZvckVhY2goZnVuY3Rpb24gcHJvY2Vzc1RhcmdldChvdCkge1xuXHQgICAgICAgICAgICB2YXIgZW50cnkgPSBuZXcgUmVzaXplT2JzZXJ2ZXJFbnRyeShvdC50YXJnZXQpO1xuXHQgICAgICAgICAgICB2YXIgdGFyZ2V0RGVwdGggPSBjYWxjdWxhdGVEZXB0aEZvck5vZGUob3QudGFyZ2V0KTtcblx0ICAgICAgICAgICAgZW50cmllcy5wdXNoKGVudHJ5KTtcblx0ICAgICAgICAgICAgb3QubGFzdFJlcG9ydGVkU2l6ZSA9IGNhbGN1bGF0ZUJveFNpemUob3QudGFyZ2V0LCBvdC5vYnNlcnZlZEJveCk7XG5cdCAgICAgICAgICAgIGlmICh0YXJnZXREZXB0aCA8IHNoYWxsb3dlc3REZXB0aCkge1xuXHQgICAgICAgICAgICAgICAgc2hhbGxvd2VzdERlcHRoID0gdGFyZ2V0RGVwdGg7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiByZXNpemVPYnNlcnZlckNhbGxiYWNrKCkge1xuXHQgICAgICAgICAgICByby5jYWxsYmFjay5jYWxsKHJvLm9ic2VydmVyLCBlbnRyaWVzLCByby5vYnNlcnZlcik7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcm8uYWN0aXZlVGFyZ2V0cy5zcGxpY2UoMCwgcm8uYWN0aXZlVGFyZ2V0cy5sZW5ndGgpO1xuXHQgICAgfSk7XG5cdCAgICBmb3IgKHZhciBfaSA9IDAsIGNhbGxiYWNrc18xID0gY2FsbGJhY2tzOyBfaSA8IGNhbGxiYWNrc18xLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrc18xW19pXTtcblx0ICAgICAgICBjYWxsYmFjaygpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHNoYWxsb3dlc3REZXB0aDtcblx0fTtcblxuXHR2YXIgZ2F0aGVyQWN0aXZlT2JzZXJ2YXRpb25zQXREZXB0aCA9IGZ1bmN0aW9uIChkZXB0aCkge1xuXHQgICAgcmVzaXplT2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24gcHJvY2Vzc09ic2VydmVyKHJvKSB7XG5cdCAgICAgICAgcm8uYWN0aXZlVGFyZ2V0cy5zcGxpY2UoMCwgcm8uYWN0aXZlVGFyZ2V0cy5sZW5ndGgpO1xuXHQgICAgICAgIHJvLnNraXBwZWRUYXJnZXRzLnNwbGljZSgwLCByby5za2lwcGVkVGFyZ2V0cy5sZW5ndGgpO1xuXHQgICAgICAgIHJvLm9ic2VydmF0aW9uVGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uIHByb2Nlc3NUYXJnZXQob3QpIHtcblx0ICAgICAgICAgICAgaWYgKG90LmlzQWN0aXZlKCkpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChjYWxjdWxhdGVEZXB0aEZvck5vZGUob3QudGFyZ2V0KSA+IGRlcHRoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcm8uYWN0aXZlVGFyZ2V0cy5wdXNoKG90KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJvLnNraXBwZWRUYXJnZXRzLnB1c2gob3QpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICB9KTtcblx0fTtcblxuXHR2YXIgcHJvY2VzcyQxID0gZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGRlcHRoID0gMDtcblx0ICAgIGdhdGhlckFjdGl2ZU9ic2VydmF0aW9uc0F0RGVwdGgoZGVwdGgpO1xuXHQgICAgd2hpbGUgKGhhc0FjdGl2ZU9ic2VydmF0aW9ucygpKSB7XG5cdCAgICAgICAgZGVwdGggPSBicm9hZGNhc3RBY3RpdmVPYnNlcnZhdGlvbnMoKTtcblx0ICAgICAgICBnYXRoZXJBY3RpdmVPYnNlcnZhdGlvbnNBdERlcHRoKGRlcHRoKTtcblx0ICAgIH1cblx0ICAgIGlmIChoYXNTa2lwcGVkT2JzZXJ2YXRpb25zKCkpIHtcblx0ICAgICAgICBkZWxpdmVyUmVzaXplTG9vcEVycm9yKCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZGVwdGggPiAwO1xuXHR9O1xuXG5cdHZhciB0cmlnZ2VyO1xuXHR2YXIgY2FsbGJhY2tzID0gW107XG5cdHZhciBub3RpZnkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFja3Muc3BsaWNlKDApLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IHJldHVybiBjYigpOyB9KTsgfTtcblx0dmFyIHF1ZXVlTWljcm9UYXNrID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdCAgICBpZiAoIXRyaWdnZXIpIHtcblx0ICAgICAgICB2YXIgdG9nZ2xlXzEgPSAwO1xuXHQgICAgICAgIHZhciBlbF8xID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuXHQgICAgICAgIHZhciBjb25maWcgPSB7IGNoYXJhY3RlckRhdGE6IHRydWUgfTtcblx0ICAgICAgICBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAoKSB7IHJldHVybiBub3RpZnkoKTsgfSkub2JzZXJ2ZShlbF8xLCBjb25maWcpO1xuXHQgICAgICAgIHRyaWdnZXIgPSBmdW5jdGlvbiAoKSB7IGVsXzEudGV4dENvbnRlbnQgPSBcIlwiICsgKHRvZ2dsZV8xID8gdG9nZ2xlXzEtLSA6IHRvZ2dsZV8xKyspOyB9O1xuXHQgICAgfVxuXHQgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXHQgICAgdHJpZ2dlcigpO1xuXHR9O1xuXG5cdHZhciBxdWV1ZVJlc2l6ZU9ic2VydmVyID0gZnVuY3Rpb24gKGNiKSB7XG5cdCAgICBxdWV1ZU1pY3JvVGFzayhmdW5jdGlvbiBSZXNpemVPYnNlcnZlcigpIHtcblx0ICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpO1xuXHQgICAgfSk7XG5cdH07XG5cblx0dmFyIHdhdGNoaW5nID0gMDtcblx0dmFyIGlzV2F0Y2hpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAhIXdhdGNoaW5nOyB9O1xuXHR2YXIgQ0FUQ0hfUEVSSU9EID0gMjUwO1xuXHR2YXIgb2JzZXJ2ZXJDb25maWcgPSB7IGF0dHJpYnV0ZXM6IHRydWUsIGNoYXJhY3RlckRhdGE6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZSB9O1xuXHR2YXIgZXZlbnRzID0gW1xuXHQgICAgJ3Jlc2l6ZScsXG5cdCAgICAnbG9hZCcsXG5cdCAgICAndHJhbnNpdGlvbmVuZCcsXG5cdCAgICAnYW5pbWF0aW9uZW5kJyxcblx0ICAgICdhbmltYXRpb25zdGFydCcsXG5cdCAgICAnYW5pbWF0aW9uaXRlcmF0aW9uJyxcblx0ICAgICdrZXl1cCcsXG5cdCAgICAna2V5ZG93bicsXG5cdCAgICAnbW91c2V1cCcsXG5cdCAgICAnbW91c2Vkb3duJyxcblx0ICAgICdtb3VzZW92ZXInLFxuXHQgICAgJ21vdXNlb3V0Jyxcblx0ICAgICdibHVyJyxcblx0ICAgICdmb2N1cydcblx0XTtcblx0dmFyIHRpbWUgPSBmdW5jdGlvbiAodGltZW91dCkge1xuXHQgICAgaWYgKHRpbWVvdXQgPT09IHZvaWQgMCkgeyB0aW1lb3V0ID0gMDsgfVxuXHQgICAgcmV0dXJuIERhdGUubm93KCkgKyB0aW1lb3V0O1xuXHR9O1xuXHR2YXIgc2NoZWR1bGVkID0gZmFsc2U7XG5cdHZhciBTY2hlZHVsZXIgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gU2NoZWR1bGVyKCkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcblx0ICAgICAgICB0aGlzLmxpc3RlbmVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2NoZWR1bGUoKTsgfTtcblx0ICAgIH1cblx0ICAgIFNjaGVkdWxlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKHRpbWVvdXQpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGlmICh0aW1lb3V0ID09PSB2b2lkIDApIHsgdGltZW91dCA9IENBVENIX1BFUklPRDsgfVxuXHQgICAgICAgIGlmIChzY2hlZHVsZWQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBzY2hlZHVsZWQgPSB0cnVlO1xuXHQgICAgICAgIHZhciB1bnRpbCA9IHRpbWUodGltZW91dCk7XG5cdCAgICAgICAgcXVldWVSZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBlbGVtZW50c0hhdmVSZXNpemVkID0gZmFsc2U7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBlbGVtZW50c0hhdmVSZXNpemVkID0gcHJvY2VzcyQxKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZmluYWxseSB7XG5cdCAgICAgICAgICAgICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIHRpbWVvdXQgPSB1bnRpbCAtIHRpbWUoKTtcblx0ICAgICAgICAgICAgICAgIGlmICghaXNXYXRjaGluZygpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzSGF2ZVJlc2l6ZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5ydW4oMTAwMCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmICh0aW1lb3V0ID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzLnJ1bih0aW1lb3V0KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzLnN0YXJ0KCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuc3RvcCgpO1xuXHQgICAgICAgIHRoaXMucnVuKCk7XG5cdCAgICB9O1xuXHQgICAgU2NoZWR1bGVyLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIGNiID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub2JzZXJ2ZXIgJiYgX3RoaXMub2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5ib2R5LCBvYnNlcnZlckNvbmZpZyk7IH07XG5cdCAgICAgICAgZG9jdW1lbnQuYm9keSA/IGNiKCkgOiBnbG9iYWwkMS5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgY2IpO1xuXHQgICAgfTtcblx0ICAgIFNjaGVkdWxlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBpZiAodGhpcy5zdG9wcGVkKSB7XG5cdCAgICAgICAgICAgIHRoaXMuc3RvcHBlZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICB0aGlzLm9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5saXN0ZW5lcik7XG5cdCAgICAgICAgICAgIHRoaXMub2JzZXJ2ZSgpO1xuXHQgICAgICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gZ2xvYmFsJDEuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBfdGhpcy5saXN0ZW5lciwgdHJ1ZSk7IH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBTY2hlZHVsZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBpZiAoIXRoaXMuc3RvcHBlZCkge1xuXHQgICAgICAgICAgICB0aGlzLm9ic2VydmVyICYmIHRoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gZ2xvYmFsJDEucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBfdGhpcy5saXN0ZW5lciwgdHJ1ZSk7IH0pO1xuXHQgICAgICAgICAgICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICByZXR1cm4gU2NoZWR1bGVyO1xuXHR9KCkpO1xuXHR2YXIgc2NoZWR1bGVyID0gbmV3IFNjaGVkdWxlcigpO1xuXHR2YXIgdXBkYXRlQ291bnQgPSBmdW5jdGlvbiAobikge1xuXHQgICAgIXdhdGNoaW5nICYmIG4gPiAwICYmIHNjaGVkdWxlci5zdGFydCgpO1xuXHQgICAgd2F0Y2hpbmcgKz0gbjtcblx0ICAgICF3YXRjaGluZyAmJiBzY2hlZHVsZXIuc3RvcCgpO1xuXHR9O1xuXG5cdHZhciBza2lwTm90aWZ5T25FbGVtZW50ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuXHQgICAgcmV0dXJuICFpc1NWRyh0YXJnZXQpXG5cdCAgICAgICAgJiYgIWlzUmVwbGFjZWRFbGVtZW50KHRhcmdldClcblx0ICAgICAgICAmJiBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCkuZGlzcGxheSA9PT0gJ2lubGluZSc7XG5cdH07XG5cdHZhciBSZXNpemVPYnNlcnZhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZhdGlvbih0YXJnZXQsIG9ic2VydmVkQm94KSB7XG5cdCAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG5cdCAgICAgICAgdGhpcy5vYnNlcnZlZEJveCA9IG9ic2VydmVkQm94IHx8IFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucy5DT05URU5UX0JPWDtcblx0ICAgICAgICB0aGlzLmxhc3RSZXBvcnRlZFNpemUgPSB7XG5cdCAgICAgICAgICAgIGlubGluZVNpemU6IDAsXG5cdCAgICAgICAgICAgIGJsb2NrU2l6ZTogMFxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICBSZXNpemVPYnNlcnZhdGlvbi5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIHNpemUgPSBjYWxjdWxhdGVCb3hTaXplKHRoaXMudGFyZ2V0LCB0aGlzLm9ic2VydmVkQm94LCB0cnVlKTtcblx0ICAgICAgICBpZiAoc2tpcE5vdGlmeU9uRWxlbWVudCh0aGlzLnRhcmdldCkpIHtcblx0ICAgICAgICAgICAgdGhpcy5sYXN0UmVwb3J0ZWRTaXplID0gc2l6ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRoaXMubGFzdFJlcG9ydGVkU2l6ZS5pbmxpbmVTaXplICE9PSBzaXplLmlubGluZVNpemVcblx0ICAgICAgICAgICAgfHwgdGhpcy5sYXN0UmVwb3J0ZWRTaXplLmJsb2NrU2l6ZSAhPT0gc2l6ZS5ibG9ja1NpemUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gUmVzaXplT2JzZXJ2YXRpb247XG5cdH0oKSk7XG5cblx0dmFyIFJlc2l6ZU9ic2VydmVyRGV0YWlsID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyRGV0YWlsKHJlc2l6ZU9ic2VydmVyLCBjYWxsYmFjaykge1xuXHQgICAgICAgIHRoaXMuYWN0aXZlVGFyZ2V0cyA9IFtdO1xuXHQgICAgICAgIHRoaXMuc2tpcHBlZFRhcmdldHMgPSBbXTtcblx0ICAgICAgICB0aGlzLm9ic2VydmF0aW9uVGFyZ2V0cyA9IFtdO1xuXHQgICAgICAgIHRoaXMub2JzZXJ2ZXIgPSByZXNpemVPYnNlcnZlcjtcblx0ICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXJEZXRhaWw7XG5cdH0oKSk7XG5cblx0dmFyIG9ic2VydmVyTWFwID0gbmV3IFdlYWtNYXAoKTtcblx0dmFyIGdldE9ic2VydmF0aW9uSW5kZXggPSBmdW5jdGlvbiAob2JzZXJ2YXRpb25UYXJnZXRzLCB0YXJnZXQpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JzZXJ2YXRpb25UYXJnZXRzLmxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgaWYgKG9ic2VydmF0aW9uVGFyZ2V0c1tpXS50YXJnZXQgPT09IHRhcmdldCkge1xuXHQgICAgICAgICAgICByZXR1cm4gaTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gLTE7XG5cdH07XG5cdHZhciBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyKCkge1xuXHQgICAgfVxuXHQgICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmNvbm5lY3QgPSBmdW5jdGlvbiAocmVzaXplT2JzZXJ2ZXIsIGNhbGxiYWNrKSB7XG5cdCAgICAgICAgdmFyIGRldGFpbCA9IG5ldyBSZXNpemVPYnNlcnZlckRldGFpbChyZXNpemVPYnNlcnZlciwgY2FsbGJhY2spO1xuXHQgICAgICAgIG9ic2VydmVyTWFwLnNldChyZXNpemVPYnNlcnZlciwgZGV0YWlsKTtcblx0ICAgIH07XG5cdCAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIub2JzZXJ2ZSA9IGZ1bmN0aW9uIChyZXNpemVPYnNlcnZlciwgdGFyZ2V0LCBvcHRpb25zKSB7XG5cdCAgICAgICAgdmFyIGRldGFpbCA9IG9ic2VydmVyTWFwLmdldChyZXNpemVPYnNlcnZlcik7XG5cdCAgICAgICAgdmFyIGZpcnN0T2JzZXJ2YXRpb24gPSBkZXRhaWwub2JzZXJ2YXRpb25UYXJnZXRzLmxlbmd0aCA9PT0gMDtcblx0ICAgICAgICBpZiAoZ2V0T2JzZXJ2YXRpb25JbmRleChkZXRhaWwub2JzZXJ2YXRpb25UYXJnZXRzLCB0YXJnZXQpIDwgMCkge1xuXHQgICAgICAgICAgICBmaXJzdE9ic2VydmF0aW9uICYmIHJlc2l6ZU9ic2VydmVycy5wdXNoKGRldGFpbCk7XG5cdCAgICAgICAgICAgIGRldGFpbC5vYnNlcnZhdGlvblRhcmdldHMucHVzaChuZXcgUmVzaXplT2JzZXJ2YXRpb24odGFyZ2V0LCBvcHRpb25zICYmIG9wdGlvbnMuYm94KSk7XG5cdCAgICAgICAgICAgIHVwZGF0ZUNvdW50KDEpO1xuXHQgICAgICAgICAgICBzY2hlZHVsZXIuc2NoZWR1bGUoKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnVub2JzZXJ2ZSA9IGZ1bmN0aW9uIChyZXNpemVPYnNlcnZlciwgdGFyZ2V0KSB7XG5cdCAgICAgICAgdmFyIGRldGFpbCA9IG9ic2VydmVyTWFwLmdldChyZXNpemVPYnNlcnZlcik7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gZ2V0T2JzZXJ2YXRpb25JbmRleChkZXRhaWwub2JzZXJ2YXRpb25UYXJnZXRzLCB0YXJnZXQpO1xuXHQgICAgICAgIHZhciBsYXN0T2JzZXJ2YXRpb24gPSBkZXRhaWwub2JzZXJ2YXRpb25UYXJnZXRzLmxlbmd0aCA9PT0gMTtcblx0ICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuXHQgICAgICAgICAgICBsYXN0T2JzZXJ2YXRpb24gJiYgcmVzaXplT2JzZXJ2ZXJzLnNwbGljZShyZXNpemVPYnNlcnZlcnMuaW5kZXhPZihkZXRhaWwpLCAxKTtcblx0ICAgICAgICAgICAgZGV0YWlsLm9ic2VydmF0aW9uVGFyZ2V0cy5zcGxpY2UoaW5kZXgsIDEpO1xuXHQgICAgICAgICAgICB1cGRhdGVDb3VudCgtMSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKHJlc2l6ZU9ic2VydmVyKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgZGV0YWlsID0gb2JzZXJ2ZXJNYXAuZ2V0KHJlc2l6ZU9ic2VydmVyKTtcblx0ICAgICAgICBkZXRhaWwub2JzZXJ2YXRpb25UYXJnZXRzLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAob3QpIHsgcmV0dXJuIF90aGlzLnVub2JzZXJ2ZShyZXNpemVPYnNlcnZlciwgb3QudGFyZ2V0KTsgfSk7XG5cdCAgICAgICAgZGV0YWlsLmFjdGl2ZVRhcmdldHMuc3BsaWNlKDAsIGRldGFpbC5hY3RpdmVUYXJnZXRzLmxlbmd0aCk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcjtcblx0fSgpKTtcblxuXHR2YXIgUmVzaXplT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXIoY2FsbGJhY2spIHtcblx0ICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUmVzaXplT2JzZXJ2ZXInOiAxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdSZXNpemVPYnNlcnZlcic6IFRoZSBjYWxsYmFjayBwcm92aWRlZCBhcyBwYXJhbWV0ZXIgMSBpcyBub3QgYSBmdW5jdGlvbi5cIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5jb25uZWN0KHRoaXMsIGNhbGxiYWNrKTtcblx0ICAgIH1cblx0ICAgIFJlc2l6ZU9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuXHQgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gZXhlY3V0ZSAnb2JzZXJ2ZScgb24gJ1Jlc2l6ZU9ic2VydmVyJzogMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LlwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCFpc0VsZW1lbnQodGFyZ2V0KSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ29ic2VydmUnIG9uICdSZXNpemVPYnNlcnZlcic6IHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdFbGVtZW50XCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIub2JzZXJ2ZSh0aGlzLCB0YXJnZXQsIG9wdGlvbnMpO1xuXHQgICAgfTtcblx0ICAgIFJlc2l6ZU9ic2VydmVyLnByb3RvdHlwZS51bm9ic2VydmUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdCAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBleGVjdXRlICd1bm9ic2VydmUnIG9uICdSZXNpemVPYnNlcnZlcic6IDEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC5cIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghaXNFbGVtZW50KHRhcmdldCkpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBleGVjdXRlICd1bm9ic2VydmUnIG9uICdSZXNpemVPYnNlcnZlcic6IHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdFbGVtZW50XCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIudW5vYnNlcnZlKHRoaXMsIHRhcmdldCk7XG5cdCAgICB9O1xuXHQgICAgUmVzaXplT2JzZXJ2ZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmRpc2Nvbm5lY3QodGhpcyk7XG5cdCAgICB9O1xuXHQgICAgUmVzaXplT2JzZXJ2ZXIudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuICdmdW5jdGlvbiBSZXNpemVPYnNlcnZlciAoKSB7IFtwb2x5ZmlsbCBjb2RlXSB9Jztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXI7XG5cdH0oKSk7XG5cblx0dmFyIFR5cGVFcnJvciRjID0gZ2xvYmFsXzEuVHlwZUVycm9yO1xuXG5cdC8vIGBBcnJheS5wcm90b3R5cGUueyByZWR1Y2UsIHJlZHVjZVJpZ2h0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cblx0dmFyIGNyZWF0ZU1ldGhvZCQ0ID0gZnVuY3Rpb24gKElTX1JJR0hUKSB7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBjYWxsYmFja2ZuLCBhcmd1bWVudHNMZW5ndGgsIG1lbW8pIHtcblx0ICAgIGFDYWxsYWJsZShjYWxsYmFja2ZuKTtcblx0ICAgIHZhciBPID0gdG9PYmplY3QodGhhdCk7XG5cdCAgICB2YXIgc2VsZiA9IGluZGV4ZWRPYmplY3QoTyk7XG5cdCAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UoTyk7XG5cdCAgICB2YXIgaW5kZXggPSBJU19SSUdIVCA/IGxlbmd0aCAtIDEgOiAwO1xuXHQgICAgdmFyIGkgPSBJU19SSUdIVCA/IC0xIDogMTtcblx0ICAgIGlmIChhcmd1bWVudHNMZW5ndGggPCAyKSB3aGlsZSAodHJ1ZSkge1xuXHQgICAgICBpZiAoaW5kZXggaW4gc2VsZikge1xuXHQgICAgICAgIG1lbW8gPSBzZWxmW2luZGV4XTtcblx0ICAgICAgICBpbmRleCArPSBpO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cdCAgICAgIGluZGV4ICs9IGk7XG5cdCAgICAgIGlmIChJU19SSUdIVCA/IGluZGV4IDwgMCA6IGxlbmd0aCA8PSBpbmRleCkge1xuXHQgICAgICAgIHRocm93IFR5cGVFcnJvciRjKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGZvciAoO0lTX1JJR0hUID8gaW5kZXggPj0gMCA6IGxlbmd0aCA+IGluZGV4OyBpbmRleCArPSBpKSBpZiAoaW5kZXggaW4gc2VsZikge1xuXHQgICAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG1lbW87XG5cdCAgfTtcblx0fTtcblxuXHR2YXIgYXJyYXlSZWR1Y2UgPSB7XG5cdCAgLy8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgIG1ldGhvZFxuXHQgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZVxuXHQgIGxlZnQ6IGNyZWF0ZU1ldGhvZCQ0KGZhbHNlKSxcblx0ICAvLyBgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0YCBtZXRob2Rcblx0ICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VyaWdodFxuXHQgIHJpZ2h0OiBjcmVhdGVNZXRob2QkNCh0cnVlKVxuXHR9O1xuXG5cdHZhciBlbmdpbmVJc05vZGUgPSBjbGFzc29mUmF3KGdsb2JhbF8xLnByb2Nlc3MpID09ICdwcm9jZXNzJztcblxuXHR2YXIgJHJlZHVjZSA9IGFycmF5UmVkdWNlLmxlZnQ7XG5cblxuXG5cblx0dmFyIFNUUklDVF9NRVRIT0QkMSA9IGFycmF5TWV0aG9kSXNTdHJpY3QoJ3JlZHVjZScpO1xuXHQvLyBDaHJvbWUgODAtODIgaGFzIGEgY3JpdGljYWwgYnVnXG5cdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEwNDk5ODJcblx0dmFyIENIUk9NRV9CVUcgPSAhZW5naW5lSXNOb2RlICYmIGVuZ2luZVY4VmVyc2lvbiA+IDc5ICYmIGVuZ2luZVY4VmVyc2lvbiA8IDgzO1xuXG5cdC8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmVkdWNlXG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFTVFJJQ1RfTUVUSE9EJDEgfHwgQ0hST01FX0JVRyB9LCB7XG5cdCAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykge1xuXHQgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdCAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBsZW5ndGgsIGxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuXHQgIH1cblx0fSk7XG5cblx0Ly8gYFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NgIGdldHRlciBpbXBsZW1lbnRhdGlvblxuXHQvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldC1yZWdleHAucHJvdG90eXBlLmZsYWdzXG5cdHZhciByZWdleHBGbGFncyA9IGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgdGhhdCA9IGFuT2JqZWN0KHRoaXMpO1xuXHQgIHZhciByZXN1bHQgPSAnJztcblx0ICBpZiAodGhhdC5oYXNJbmRpY2VzKSByZXN1bHQgKz0gJ2QnO1xuXHQgIGlmICh0aGF0Lmdsb2JhbCkgcmVzdWx0ICs9ICdnJztcblx0ICBpZiAodGhhdC5pZ25vcmVDYXNlKSByZXN1bHQgKz0gJ2knO1xuXHQgIGlmICh0aGF0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcblx0ICBpZiAodGhhdC5kb3RBbGwpIHJlc3VsdCArPSAncyc7XG5cdCAgaWYgKHRoYXQudW5pY29kZSkgcmVzdWx0ICs9ICd1Jztcblx0ICBpZiAodGhhdC5zdGlja3kpIHJlc3VsdCArPSAneSc7XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHQvLyBiYWJlbC1taW5pZnkgYW5kIENsb3N1cmUgQ29tcGlsZXIgdHJhbnNwaWxlcyBSZWdFeHAoJ2EnLCAneScpIC0+IC9hL3kgYW5kIGl0IGNhdXNlcyBTeW50YXhFcnJvclxuXHR2YXIgJFJlZ0V4cCA9IGdsb2JhbF8xLlJlZ0V4cDtcblxuXHR2YXIgVU5TVVBQT1JURURfWSA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgcmUgPSAkUmVnRXhwKCdhJywgJ3knKTtcblx0ICByZS5sYXN0SW5kZXggPSAyO1xuXHQgIHJldHVybiByZS5leGVjKCdhYmNkJykgIT0gbnVsbDtcblx0fSk7XG5cblx0Ly8gVUMgQnJvd3NlciBidWdcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzEwMDhcblx0dmFyIE1JU1NFRF9TVElDS1kgPSBVTlNVUFBPUlRFRF9ZIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICByZXR1cm4gISRSZWdFeHAoJ2EnLCAneScpLnN0aWNreTtcblx0fSk7XG5cblx0dmFyIEJST0tFTl9DQVJFVCA9IFVOU1VQUE9SVEVEX1kgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuXHQgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTc3MzY4N1xuXHQgIHZhciByZSA9ICRSZWdFeHAoJ15yJywgJ2d5Jyk7XG5cdCAgcmUubGFzdEluZGV4ID0gMjtcblx0ICByZXR1cm4gcmUuZXhlYygnc3RyJykgIT0gbnVsbDtcblx0fSk7XG5cblx0dmFyIHJlZ2V4cFN0aWNreUhlbHBlcnMgPSB7XG5cdCAgQlJPS0VOX0NBUkVUOiBCUk9LRU5fQ0FSRVQsXG5cdCAgTUlTU0VEX1NUSUNLWTogTUlTU0VEX1NUSUNLWSxcblx0ICBVTlNVUFBPUlRFRF9ZOiBVTlNVUFBPUlRFRF9ZXG5cdH07XG5cblx0Ly8gYmFiZWwtbWluaWZ5IGFuZCBDbG9zdXJlIENvbXBpbGVyIHRyYW5zcGlsZXMgUmVnRXhwKCcuJywgJ3MnKSAtPiAvLi9zIGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3Jcblx0dmFyICRSZWdFeHAkMSA9IGdsb2JhbF8xLlJlZ0V4cDtcblxuXHR2YXIgcmVnZXhwVW5zdXBwb3J0ZWREb3RBbGwgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIHJlID0gJFJlZ0V4cCQxKCcuJywgJ3MnKTtcblx0ICByZXR1cm4gIShyZS5kb3RBbGwgJiYgcmUuZXhlYygnXFxuJykgJiYgcmUuZmxhZ3MgPT09ICdzJyk7XG5cdH0pO1xuXG5cdC8vIGJhYmVsLW1pbmlmeSBhbmQgQ2xvc3VyZSBDb21waWxlciB0cmFuc3BpbGVzIFJlZ0V4cCgnKD88YT5iKScsICdnJykgLT4gLyg/PGE+YikvZyBhbmQgaXQgY2F1c2VzIFN5bnRheEVycm9yXG5cdHZhciAkUmVnRXhwJDIgPSBnbG9iYWxfMS5SZWdFeHA7XG5cblx0dmFyIHJlZ2V4cFVuc3VwcG9ydGVkTmNnID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuXHQgIHZhciByZSA9ICRSZWdFeHAkMignKD88YT5iKScsICdnJyk7XG5cdCAgcmV0dXJuIHJlLmV4ZWMoJ2InKS5ncm91cHMuYSAhPT0gJ2InIHx8XG5cdCAgICAnYicucmVwbGFjZShyZSwgJyQ8YT5jJykgIT09ICdiYyc7XG5cdH0pO1xuXG5cdC8qIGVzbGludC1kaXNhYmxlIHJlZ2V4cC9uby1lbXB0eS1jYXB0dXJpbmctZ3JvdXAsIHJlZ2V4cC9uby1lbXB0eS1ncm91cCwgcmVnZXhwL25vLWxhenktZW5kcyAtLSB0ZXN0aW5nICovXG5cdC8qIGVzbGludC1kaXNhYmxlIHJlZ2V4cC9uby11c2VsZXNzLXF1YW50aWZpZXIgLS0gdGVzdGluZyAqL1xuXG5cblxuXG5cblxuXG5cdHZhciBnZXRJbnRlcm5hbFN0YXRlJDIgPSBpbnRlcm5hbFN0YXRlLmdldDtcblxuXG5cblx0dmFyIG5hdGl2ZVJlcGxhY2UgPSBzaGFyZWQoJ25hdGl2ZS1zdHJpbmctcmVwbGFjZScsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG5cdHZhciBuYXRpdmVFeGVjID0gUmVnRXhwLnByb3RvdHlwZS5leGVjO1xuXHR2YXIgcGF0Y2hlZEV4ZWMgPSBuYXRpdmVFeGVjO1xuXHR2YXIgY2hhckF0JDIgPSBmdW5jdGlvblVuY3VycnlUaGlzKCcnLmNoYXJBdCk7XG5cdHZhciBpbmRleE9mJDEgPSBmdW5jdGlvblVuY3VycnlUaGlzKCcnLmluZGV4T2YpO1xuXHR2YXIgcmVwbGFjZSQxID0gZnVuY3Rpb25VbmN1cnJ5VGhpcygnJy5yZXBsYWNlKTtcblx0dmFyIHN0cmluZ1NsaWNlJDIgPSBmdW5jdGlvblVuY3VycnlUaGlzKCcnLnNsaWNlKTtcblxuXHR2YXIgVVBEQVRFU19MQVNUX0lOREVYX1dST05HID0gKGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgcmUxID0gL2EvO1xuXHQgIHZhciByZTIgPSAvYiovZztcblx0ICBmdW5jdGlvbkNhbGwobmF0aXZlRXhlYywgcmUxLCAnYScpO1xuXHQgIGZ1bmN0aW9uQ2FsbChuYXRpdmVFeGVjLCByZTIsICdhJyk7XG5cdCAgcmV0dXJuIHJlMS5sYXN0SW5kZXggIT09IDAgfHwgcmUyLmxhc3RJbmRleCAhPT0gMDtcblx0fSkoKTtcblxuXHR2YXIgVU5TVVBQT1JURURfWSQxID0gcmVnZXhwU3RpY2t5SGVscGVycy5CUk9LRU5fQ0FSRVQ7XG5cblx0Ly8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXAsIGNvcGllZCBmcm9tIGVzNS1zaGltJ3MgU3RyaW5nI3NwbGl0IHBhdGNoLlxuXHR2YXIgTlBDR19JTkNMVURFRCA9IC8oKT8/Ly5leGVjKCcnKVsxXSAhPT0gdW5kZWZpbmVkO1xuXG5cdHZhciBQQVRDSCA9IFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyB8fCBOUENHX0lOQ0xVREVEIHx8IFVOU1VQUE9SVEVEX1kkMSB8fCByZWdleHBVbnN1cHBvcnRlZERvdEFsbCB8fCByZWdleHBVbnN1cHBvcnRlZE5jZztcblxuXHRpZiAoUEFUQ0gpIHtcblx0ICBwYXRjaGVkRXhlYyA9IGZ1bmN0aW9uIGV4ZWMoc3RyaW5nKSB7XG5cdCAgICB2YXIgcmUgPSB0aGlzO1xuXHQgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSQyKHJlKTtcblx0ICAgIHZhciBzdHIgPSB0b1N0cmluZ18xKHN0cmluZyk7XG5cdCAgICB2YXIgcmF3ID0gc3RhdGUucmF3O1xuXHQgICAgdmFyIHJlc3VsdCwgcmVDb3B5LCBsYXN0SW5kZXgsIG1hdGNoLCBpLCBvYmplY3QsIGdyb3VwO1xuXG5cdCAgICBpZiAocmF3KSB7XG5cdCAgICAgIHJhdy5sYXN0SW5kZXggPSByZS5sYXN0SW5kZXg7XG5cdCAgICAgIHJlc3VsdCA9IGZ1bmN0aW9uQ2FsbChwYXRjaGVkRXhlYywgcmF3LCBzdHIpO1xuXHQgICAgICByZS5sYXN0SW5kZXggPSByYXcubGFzdEluZGV4O1xuXHQgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXG5cdCAgICB2YXIgZ3JvdXBzID0gc3RhdGUuZ3JvdXBzO1xuXHQgICAgdmFyIHN0aWNreSA9IFVOU1VQUE9SVEVEX1kkMSAmJiByZS5zdGlja3k7XG5cdCAgICB2YXIgZmxhZ3MgPSBmdW5jdGlvbkNhbGwocmVnZXhwRmxhZ3MsIHJlKTtcblx0ICAgIHZhciBzb3VyY2UgPSByZS5zb3VyY2U7XG5cdCAgICB2YXIgY2hhcnNBZGRlZCA9IDA7XG5cdCAgICB2YXIgc3RyQ29weSA9IHN0cjtcblxuXHQgICAgaWYgKHN0aWNreSkge1xuXHQgICAgICBmbGFncyA9IHJlcGxhY2UkMShmbGFncywgJ3knLCAnJyk7XG5cdCAgICAgIGlmIChpbmRleE9mJDEoZmxhZ3MsICdnJykgPT09IC0xKSB7XG5cdCAgICAgICAgZmxhZ3MgKz0gJ2cnO1xuXHQgICAgICB9XG5cblx0ICAgICAgc3RyQ29weSA9IHN0cmluZ1NsaWNlJDIoc3RyLCByZS5sYXN0SW5kZXgpO1xuXHQgICAgICAvLyBTdXBwb3J0IGFuY2hvcmVkIHN0aWNreSBiZWhhdmlvci5cblx0ICAgICAgaWYgKHJlLmxhc3RJbmRleCA+IDAgJiYgKCFyZS5tdWx0aWxpbmUgfHwgcmUubXVsdGlsaW5lICYmIGNoYXJBdCQyKHN0ciwgcmUubGFzdEluZGV4IC0gMSkgIT09ICdcXG4nKSkge1xuXHQgICAgICAgIHNvdXJjZSA9ICcoPzogJyArIHNvdXJjZSArICcpJztcblx0ICAgICAgICBzdHJDb3B5ID0gJyAnICsgc3RyQ29weTtcblx0ICAgICAgICBjaGFyc0FkZGVkKys7XG5cdCAgICAgIH1cblx0ICAgICAgLy8gXig/ICsgcnggKyApIGlzIG5lZWRlZCwgaW4gY29tYmluYXRpb24gd2l0aCBzb21lIHN0ciBzbGljaW5nLCB0b1xuXHQgICAgICAvLyBzaW11bGF0ZSB0aGUgJ3knIGZsYWcuXG5cdCAgICAgIHJlQ29weSA9IG5ldyBSZWdFeHAoJ14oPzonICsgc291cmNlICsgJyknLCBmbGFncyk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChOUENHX0lOQ0xVREVEKSB7XG5cdCAgICAgIHJlQ29weSA9IG5ldyBSZWdFeHAoJ14nICsgc291cmNlICsgJyQoPyFcXFxccyknLCBmbGFncyk7XG5cdCAgICB9XG5cdCAgICBpZiAoVVBEQVRFU19MQVNUX0lOREVYX1dST05HKSBsYXN0SW5kZXggPSByZS5sYXN0SW5kZXg7XG5cblx0ICAgIG1hdGNoID0gZnVuY3Rpb25DYWxsKG5hdGl2ZUV4ZWMsIHN0aWNreSA/IHJlQ29weSA6IHJlLCBzdHJDb3B5KTtcblxuXHQgICAgaWYgKHN0aWNreSkge1xuXHQgICAgICBpZiAobWF0Y2gpIHtcblx0ICAgICAgICBtYXRjaC5pbnB1dCA9IHN0cmluZ1NsaWNlJDIobWF0Y2guaW5wdXQsIGNoYXJzQWRkZWQpO1xuXHQgICAgICAgIG1hdGNoWzBdID0gc3RyaW5nU2xpY2UkMihtYXRjaFswXSwgY2hhcnNBZGRlZCk7XG5cdCAgICAgICAgbWF0Y2guaW5kZXggPSByZS5sYXN0SW5kZXg7XG5cdCAgICAgICAgcmUubGFzdEluZGV4ICs9IG1hdGNoWzBdLmxlbmd0aDtcblx0ICAgICAgfSBlbHNlIHJlLmxhc3RJbmRleCA9IDA7XG5cdCAgICB9IGVsc2UgaWYgKFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyAmJiBtYXRjaCkge1xuXHQgICAgICByZS5sYXN0SW5kZXggPSByZS5nbG9iYWwgPyBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCA6IGxhc3RJbmRleDtcblx0ICAgIH1cblx0ICAgIGlmIChOUENHX0lOQ0xVREVEICYmIG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcblx0ICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGBcblx0ICAgICAgLy8gZm9yIE5QQ0csIGxpa2UgSUU4LiBOT1RFOiBUaGlzIGRvZXNuJyB3b3JrIGZvciAvKC4/KT8vXG5cdCAgICAgIGZ1bmN0aW9uQ2FsbChuYXRpdmVSZXBsYWNlLCBtYXRjaFswXSwgcmVDb3B5LCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZm9yIChpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAyOyBpKyspIHtcblx0ICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCkgbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgaWYgKG1hdGNoICYmIGdyb3Vwcykge1xuXHQgICAgICBtYXRjaC5ncm91cHMgPSBvYmplY3QgPSBvYmplY3RDcmVhdGUobnVsbCk7XG5cdCAgICAgIGZvciAoaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBncm91cCA9IGdyb3Vwc1tpXTtcblx0ICAgICAgICBvYmplY3RbZ3JvdXBbMF1dID0gbWF0Y2hbZ3JvdXBbMV1dO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBtYXRjaDtcblx0ICB9O1xuXHR9XG5cblx0dmFyIHJlZ2V4cEV4ZWMgPSBwYXRjaGVkRXhlYztcblxuXHQvLyBgUmVnRXhwLnByb3RvdHlwZS5leGVjYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLmV4ZWNcblx0X2V4cG9ydCh7IHRhcmdldDogJ1JlZ0V4cCcsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IC8uLy5leGVjICE9PSByZWdleHBFeGVjIH0sIHtcblx0ICBleGVjOiByZWdleHBFeGVjXG5cdH0pO1xuXG5cdC8vIFRPRE86IFJlbW92ZSBmcm9tIGBjb3JlLWpzQDRgIHNpbmNlIGl0J3MgbW92ZWQgdG8gZW50cnkgcG9pbnRzXG5cblxuXG5cblxuXG5cblxuXHR2YXIgU1BFQ0lFUyQyID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cdHZhciBSZWdFeHBQcm90b3R5cGUgPSBSZWdFeHAucHJvdG90eXBlO1xuXG5cdHZhciBmaXhSZWdleHBXZWxsS25vd25TeW1ib2xMb2dpYyA9IGZ1bmN0aW9uIChLRVksIGV4ZWMsIEZPUkNFRCwgU0hBTSkge1xuXHQgIHZhciBTWU1CT0wgPSB3ZWxsS25vd25TeW1ib2woS0VZKTtcblxuXHQgIHZhciBERUxFR0FURVNfVE9fU1lNQk9MID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFN0cmluZyBtZXRob2RzIGNhbGwgc3ltYm9sLW5hbWVkIFJlZ0VwIG1ldGhvZHNcblx0ICAgIHZhciBPID0ge307XG5cdCAgICBPW1NZTUJPTF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9O1xuXHQgICAgcmV0dXJuICcnW0tFWV0oTykgIT0gNztcblx0ICB9KTtcblxuXHQgIHZhciBERUxFR0FURVNfVE9fRVhFQyA9IERFTEVHQVRFU19UT19TWU1CT0wgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFN5bWJvbC1uYW1lZCBSZWdFeHAgbWV0aG9kcyBjYWxsIC5leGVjXG5cdCAgICB2YXIgZXhlY0NhbGxlZCA9IGZhbHNlO1xuXHQgICAgdmFyIHJlID0gL2EvO1xuXG5cdCAgICBpZiAoS0VZID09PSAnc3BsaXQnKSB7XG5cdCAgICAgIC8vIFdlIGNhbid0IHVzZSByZWFsIHJlZ2V4IGhlcmUgc2luY2UgaXQgY2F1c2VzIGRlb3B0aW1pemF0aW9uXG5cdCAgICAgIC8vIGFuZCBzZXJpb3VzIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uIGluIFY4XG5cdCAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8zMDZcblx0ICAgICAgcmUgPSB7fTtcblx0ICAgICAgLy8gUmVnRXhwW0BAc3BsaXRdIGRvZXNuJ3QgY2FsbCB0aGUgcmVnZXgncyBleGVjIG1ldGhvZCwgYnV0IGZpcnN0IGNyZWF0ZXNcblx0ICAgICAgLy8gYSBuZXcgb25lLiBXZSBuZWVkIHRvIHJldHVybiB0aGUgcGF0Y2hlZCByZWdleCB3aGVuIGNyZWF0aW5nIHRoZSBuZXcgb25lLlxuXHQgICAgICByZS5jb25zdHJ1Y3RvciA9IHt9O1xuXHQgICAgICByZS5jb25zdHJ1Y3RvcltTUEVDSUVTJDJdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmU7IH07XG5cdCAgICAgIHJlLmZsYWdzID0gJyc7XG5cdCAgICAgIHJlW1NZTUJPTF0gPSAvLi9bU1lNQk9MXTtcblx0ICAgIH1cblxuXHQgICAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHsgZXhlY0NhbGxlZCA9IHRydWU7IHJldHVybiBudWxsOyB9O1xuXG5cdCAgICByZVtTWU1CT0xdKCcnKTtcblx0ICAgIHJldHVybiAhZXhlY0NhbGxlZDtcblx0ICB9KTtcblxuXHQgIGlmIChcblx0ICAgICFERUxFR0FURVNfVE9fU1lNQk9MIHx8XG5cdCAgICAhREVMRUdBVEVTX1RPX0VYRUMgfHxcblx0ICAgIEZPUkNFRFxuXHQgICkge1xuXHQgICAgdmFyIHVuY3VycmllZE5hdGl2ZVJlZ0V4cE1ldGhvZCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXMoLy4vW1NZTUJPTF0pO1xuXHQgICAgdmFyIG1ldGhvZHMgPSBleGVjKFNZTUJPTCwgJydbS0VZXSwgZnVuY3Rpb24gKG5hdGl2ZU1ldGhvZCwgcmVnZXhwLCBzdHIsIGFyZzIsIGZvcmNlU3RyaW5nTWV0aG9kKSB7XG5cdCAgICAgIHZhciB1bmN1cnJpZWROYXRpdmVNZXRob2QgPSBmdW5jdGlvblVuY3VycnlUaGlzKG5hdGl2ZU1ldGhvZCk7XG5cdCAgICAgIHZhciAkZXhlYyA9IHJlZ2V4cC5leGVjO1xuXHQgICAgICBpZiAoJGV4ZWMgPT09IHJlZ2V4cEV4ZWMgfHwgJGV4ZWMgPT09IFJlZ0V4cFByb3RvdHlwZS5leGVjKSB7XG5cdCAgICAgICAgaWYgKERFTEVHQVRFU19UT19TWU1CT0wgJiYgIWZvcmNlU3RyaW5nTWV0aG9kKSB7XG5cdCAgICAgICAgICAvLyBUaGUgbmF0aXZlIFN0cmluZyBtZXRob2QgYWxyZWFkeSBkZWxlZ2F0ZXMgdG8gQEBtZXRob2QgKHRoaXNcblx0ICAgICAgICAgIC8vIHBvbHlmaWxsZWQgZnVuY3Rpb24pLCBsZWFzaW5nIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cblx0ICAgICAgICAgIC8vIFdlIGF2b2lkIGl0IGJ5IGRpcmVjdGx5IGNhbGxpbmcgdGhlIG5hdGl2ZSBAQG1ldGhvZCBtZXRob2QuXG5cdCAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5jdXJyaWVkTmF0aXZlUmVnRXhwTWV0aG9kKHJlZ2V4cCwgc3RyLCBhcmcyKSB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5jdXJyaWVkTmF0aXZlTWV0aG9kKHN0ciwgcmVnZXhwLCBhcmcyKSB9O1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlIH07XG5cdCAgICB9KTtcblxuXHQgICAgZGVmaW5lQnVpbHRJbihTdHJpbmcucHJvdG90eXBlLCBLRVksIG1ldGhvZHNbMF0pO1xuXHQgICAgZGVmaW5lQnVpbHRJbihSZWdFeHBQcm90b3R5cGUsIFNZTUJPTCwgbWV0aG9kc1sxXSk7XG5cdCAgfVxuXG5cdCAgaWYgKFNIQU0pIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShSZWdFeHBQcm90b3R5cGVbU1lNQk9MXSwgJ3NoYW0nLCB0cnVlKTtcblx0fTtcblxuXHR2YXIgY2hhckF0JDMgPSBzdHJpbmdNdWx0aWJ5dGUuY2hhckF0O1xuXG5cdC8vIGBBZHZhbmNlU3RyaW5nSW5kZXhgIGFic3RyYWN0IG9wZXJhdGlvblxuXHQvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFkdmFuY2VzdHJpbmdpbmRleFxuXHR2YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gZnVuY3Rpb24gKFMsIGluZGV4LCB1bmljb2RlKSB7XG5cdCAgcmV0dXJuIGluZGV4ICsgKHVuaWNvZGUgPyBjaGFyQXQkMyhTLCBpbmRleCkubGVuZ3RoIDogMSk7XG5cdH07XG5cblx0dmFyIFR5cGVFcnJvciRkID0gZ2xvYmFsXzEuVHlwZUVycm9yO1xuXG5cdC8vIGBSZWdFeHBFeGVjYCBhYnN0cmFjdCBvcGVyYXRpb25cblx0Ly8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWdleHBleGVjXG5cdHZhciByZWdleHBFeGVjQWJzdHJhY3QgPSBmdW5jdGlvbiAoUiwgUykge1xuXHQgIHZhciBleGVjID0gUi5leGVjO1xuXHQgIGlmIChpc0NhbGxhYmxlKGV4ZWMpKSB7XG5cdCAgICB2YXIgcmVzdWx0ID0gZnVuY3Rpb25DYWxsKGV4ZWMsIFIsIFMpO1xuXHQgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkgYW5PYmplY3QocmVzdWx0KTtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfVxuXHQgIGlmIChjbGFzc29mUmF3KFIpID09PSAnUmVnRXhwJykgcmV0dXJuIGZ1bmN0aW9uQ2FsbChyZWdleHBFeGVjLCBSLCBTKTtcblx0ICB0aHJvdyBUeXBlRXJyb3IkZCgnUmVnRXhwI2V4ZWMgY2FsbGVkIG9uIGluY29tcGF0aWJsZSByZWNlaXZlcicpO1xuXHR9O1xuXG5cdC8vIEBAbWF0Y2ggbG9naWNcblx0Zml4UmVnZXhwV2VsbEtub3duU3ltYm9sTG9naWMoJ21hdGNoJywgZnVuY3Rpb24gKE1BVENILCBuYXRpdmVNYXRjaCwgbWF5YmVDYWxsTmF0aXZlKSB7XG5cdCAgcmV0dXJuIFtcblx0ICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLm1hdGNoYCBtZXRob2Rcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5tYXRjaFxuXHQgICAgZnVuY3Rpb24gbWF0Y2gocmVnZXhwKSB7XG5cdCAgICAgIHZhciBPID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKTtcblx0ICAgICAgdmFyIG1hdGNoZXIgPSByZWdleHAgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogZ2V0TWV0aG9kKHJlZ2V4cCwgTUFUQ0gpO1xuXHQgICAgICByZXR1cm4gbWF0Y2hlciA/IGZ1bmN0aW9uQ2FsbChtYXRjaGVyLCByZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW01BVENIXSh0b1N0cmluZ18xKE8pKTtcblx0ICAgIH0sXG5cdCAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXWAgbWV0aG9kXG5cdCAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEBtYXRjaFxuXHQgICAgZnVuY3Rpb24gKHN0cmluZykge1xuXHQgICAgICB2YXIgcnggPSBhbk9iamVjdCh0aGlzKTtcblx0ICAgICAgdmFyIFMgPSB0b1N0cmluZ18xKHN0cmluZyk7XG5cdCAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUobmF0aXZlTWF0Y2gsIHJ4LCBTKTtcblxuXHQgICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG5cblx0ICAgICAgaWYgKCFyeC5nbG9iYWwpIHJldHVybiByZWdleHBFeGVjQWJzdHJhY3QocngsIFMpO1xuXG5cdCAgICAgIHZhciBmdWxsVW5pY29kZSA9IHJ4LnVuaWNvZGU7XG5cdCAgICAgIHJ4Lmxhc3RJbmRleCA9IDA7XG5cdCAgICAgIHZhciBBID0gW107XG5cdCAgICAgIHZhciBuID0gMDtcblx0ICAgICAgdmFyIHJlc3VsdDtcblx0ICAgICAgd2hpbGUgKChyZXN1bHQgPSByZWdleHBFeGVjQWJzdHJhY3QocngsIFMpKSAhPT0gbnVsbCkge1xuXHQgICAgICAgIHZhciBtYXRjaFN0ciA9IHRvU3RyaW5nXzEocmVzdWx0WzBdKTtcblx0ICAgICAgICBBW25dID0gbWF0Y2hTdHI7XG5cdCAgICAgICAgaWYgKG1hdGNoU3RyID09PSAnJykgcngubGFzdEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHRvTGVuZ3RoKHJ4Lmxhc3RJbmRleCksIGZ1bGxVbmljb2RlKTtcblx0ICAgICAgICBuKys7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG4gPT09IDAgPyBudWxsIDogQTtcblx0ICAgIH1cblx0ICBdO1xuXHR9KTtcblxuXHR2YXIgRlVOQ1RJT05fTkFNRV9FWElTVFMgPSBmdW5jdGlvbk5hbWUuRVhJU1RTO1xuXG5cdHZhciBkZWZpbmVQcm9wZXJ0eSQ1ID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcblxuXHR2YXIgRnVuY3Rpb25Qcm90b3R5cGUkMiA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblx0dmFyIGZ1bmN0aW9uVG9TdHJpbmckMSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXMoRnVuY3Rpb25Qcm90b3R5cGUkMi50b1N0cmluZyk7XG5cdHZhciBuYW1lUkUgPSAvZnVuY3Rpb25cXGIoPzpcXHN8XFwvXFwqW1xcU1xcc10qP1xcKlxcL3xcXC9cXC9bXlxcblxccl0qW1xcblxccl0rKSooW15cXHMoL10qKS87XG5cdHZhciByZWdFeHBFeGVjID0gZnVuY3Rpb25VbmN1cnJ5VGhpcyhuYW1lUkUuZXhlYyk7XG5cdHZhciBOQU1FID0gJ25hbWUnO1xuXG5cdC8vIEZ1bmN0aW9uIGluc3RhbmNlcyBgLm5hbWVgIHByb3BlcnR5XG5cdC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZnVuY3Rpb24taW5zdGFuY2VzLW5hbWVcblx0aWYgKGRlc2NyaXB0b3JzICYmICFGVU5DVElPTl9OQU1FX0VYSVNUUykge1xuXHQgIGRlZmluZVByb3BlcnR5JDUoRnVuY3Rpb25Qcm90b3R5cGUkMiwgTkFNRSwge1xuXHQgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXHQgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgcmV0dXJuIHJlZ0V4cEV4ZWMobmFtZVJFLCBmdW5jdGlvblRvU3RyaW5nJDEodGhpcykpWzFdO1xuXHQgICAgICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgIHJldHVybiAnJztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0pO1xuXHR9XG5cblx0dmFyIEZ1bmN0aW9uUHJvdG90eXBlJDMgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cdHZhciBhcHBseSA9IEZ1bmN0aW9uUHJvdG90eXBlJDMuYXBwbHk7XG5cdHZhciBjYWxsJDIgPSBGdW5jdGlvblByb3RvdHlwZSQzLmNhbGw7XG5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tcmVmbGVjdCAtLSBzYWZlXG5cdHZhciBmdW5jdGlvbkFwcGx5ID0gdHlwZW9mIFJlZmxlY3QgPT0gJ29iamVjdCcgJiYgUmVmbGVjdC5hcHBseSB8fCAoZnVuY3Rpb25CaW5kTmF0aXZlID8gY2FsbCQyLmJpbmQoYXBwbHkpIDogZnVuY3Rpb24gKCkge1xuXHQgIHJldHVybiBjYWxsJDIuYXBwbHkoYXBwbHksIGFyZ3VtZW50cyk7XG5cdH0pO1xuXG5cdHZhciBmbG9vciQxID0gTWF0aC5mbG9vcjtcblx0dmFyIGNoYXJBdCQ0ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcygnJy5jaGFyQXQpO1xuXHR2YXIgcmVwbGFjZSQyID0gZnVuY3Rpb25VbmN1cnJ5VGhpcygnJy5yZXBsYWNlKTtcblx0dmFyIHN0cmluZ1NsaWNlJDMgPSBmdW5jdGlvblVuY3VycnlUaGlzKCcnLnNsaWNlKTtcblx0dmFyIFNVQlNUSVRVVElPTl9TWU1CT0xTID0gL1xcJChbJCYnYF18XFxkezEsMn18PFtePl0qPikvZztcblx0dmFyIFNVQlNUSVRVVElPTl9TWU1CT0xTX05PX05BTUVEID0gL1xcJChbJCYnYF18XFxkezEsMn0pL2c7XG5cblx0Ly8gYEdldFN1YnN0aXR1dGlvbmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG5cdC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0c3Vic3RpdHV0aW9uXG5cdHZhciBnZXRTdWJzdGl0dXRpb24gPSBmdW5jdGlvbiAobWF0Y2hlZCwgc3RyLCBwb3NpdGlvbiwgY2FwdHVyZXMsIG5hbWVkQ2FwdHVyZXMsIHJlcGxhY2VtZW50KSB7XG5cdCAgdmFyIHRhaWxQb3MgPSBwb3NpdGlvbiArIG1hdGNoZWQubGVuZ3RoO1xuXHQgIHZhciBtID0gY2FwdHVyZXMubGVuZ3RoO1xuXHQgIHZhciBzeW1ib2xzID0gU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQ7XG5cdCAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgbmFtZWRDYXB0dXJlcyA9IHRvT2JqZWN0KG5hbWVkQ2FwdHVyZXMpO1xuXHQgICAgc3ltYm9scyA9IFNVQlNUSVRVVElPTl9TWU1CT0xTO1xuXHQgIH1cblx0ICByZXR1cm4gcmVwbGFjZSQyKHJlcGxhY2VtZW50LCBzeW1ib2xzLCBmdW5jdGlvbiAobWF0Y2gsIGNoKSB7XG5cdCAgICB2YXIgY2FwdHVyZTtcblx0ICAgIHN3aXRjaCAoY2hhckF0JDQoY2gsIDApKSB7XG5cdCAgICAgIGNhc2UgJyQnOiByZXR1cm4gJyQnO1xuXHQgICAgICBjYXNlICcmJzogcmV0dXJuIG1hdGNoZWQ7XG5cdCAgICAgIGNhc2UgJ2AnOiByZXR1cm4gc3RyaW5nU2xpY2UkMyhzdHIsIDAsIHBvc2l0aW9uKTtcblx0ICAgICAgY2FzZSBcIidcIjogcmV0dXJuIHN0cmluZ1NsaWNlJDMoc3RyLCB0YWlsUG9zKTtcblx0ICAgICAgY2FzZSAnPCc6XG5cdCAgICAgICAgY2FwdHVyZSA9IG5hbWVkQ2FwdHVyZXNbc3RyaW5nU2xpY2UkMyhjaCwgMSwgLTEpXTtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgZGVmYXVsdDogLy8gXFxkXFxkP1xuXHQgICAgICAgIHZhciBuID0gK2NoO1xuXHQgICAgICAgIGlmIChuID09PSAwKSByZXR1cm4gbWF0Y2g7XG5cdCAgICAgICAgaWYgKG4gPiBtKSB7XG5cdCAgICAgICAgICB2YXIgZiA9IGZsb29yJDEobiAvIDEwKTtcblx0ICAgICAgICAgIGlmIChmID09PSAwKSByZXR1cm4gbWF0Y2g7XG5cdCAgICAgICAgICBpZiAoZiA8PSBtKSByZXR1cm4gY2FwdHVyZXNbZiAtIDFdID09PSB1bmRlZmluZWQgPyBjaGFyQXQkNChjaCwgMSkgOiBjYXB0dXJlc1tmIC0gMV0gKyBjaGFyQXQkNChjaCwgMSk7XG5cdCAgICAgICAgICByZXR1cm4gbWF0Y2g7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNhcHR1cmUgPSBjYXB0dXJlc1tuIC0gMV07XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY2FwdHVyZSA9PT0gdW5kZWZpbmVkID8gJycgOiBjYXB0dXJlO1xuXHQgIH0pO1xuXHR9O1xuXG5cdHZhciBSRVBMQUNFID0gd2VsbEtub3duU3ltYm9sKCdyZXBsYWNlJyk7XG5cdHZhciBtYXgkMiA9IE1hdGgubWF4O1xuXHR2YXIgbWluJDIgPSBNYXRoLm1pbjtcblx0dmFyIGNvbmNhdCQyID0gZnVuY3Rpb25VbmN1cnJ5VGhpcyhbXS5jb25jYXQpO1xuXHR2YXIgcHVzaCQyID0gZnVuY3Rpb25VbmN1cnJ5VGhpcyhbXS5wdXNoKTtcblx0dmFyIHN0cmluZ0luZGV4T2YgPSBmdW5jdGlvblVuY3VycnlUaGlzKCcnLmluZGV4T2YpO1xuXHR2YXIgc3RyaW5nU2xpY2UkNCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXMoJycuc2xpY2UpO1xuXG5cdHZhciBtYXliZVRvU3RyaW5nID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyBpdCA6IFN0cmluZyhpdCk7XG5cdH07XG5cblx0Ly8gSUUgPD0gMTEgcmVwbGFjZXMgJDAgd2l0aCB0aGUgd2hvbGUgbWF0Y2gsIGFzIGlmIGl0IHdhcyAkJlxuXHQvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82MDI0NjY2L2dldHRpbmctaWUtdG8tcmVwbGFjZS1hLXJlZ2V4LXdpdGgtdGhlLWxpdGVyYWwtc3RyaW5nLTBcblx0dmFyIFJFUExBQ0VfS0VFUFNfJDAgPSAoZnVuY3Rpb24gKCkge1xuXHQgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvcHJlZmVyLWVzY2FwZS1yZXBsYWNlbWVudC1kb2xsYXItY2hhciAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuXHQgIHJldHVybiAnYScucmVwbGFjZSgvLi8sICckMCcpID09PSAnJDAnO1xuXHR9KSgpO1xuXG5cdC8vIFNhZmFyaSA8PSAxMy4wLjMoPykgc3Vic3RpdHV0ZXMgbnRoIGNhcHR1cmUgd2hlcmUgbj5tIHdpdGggYW4gZW1wdHkgc3RyaW5nXG5cdHZhciBSRUdFWFBfUkVQTEFDRV9TVUJTVElUVVRFU19VTkRFRklORURfQ0FQVFVSRSA9IChmdW5jdGlvbiAoKSB7XG5cdCAgaWYgKC8uL1tSRVBMQUNFXSkge1xuXHQgICAgcmV0dXJuIC8uL1tSRVBMQUNFXSgnYScsICckMCcpID09PSAnJztcblx0ICB9XG5cdCAgcmV0dXJuIGZhbHNlO1xuXHR9KSgpO1xuXG5cdHZhciBSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIHJlID0gLy4vO1xuXHQgIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICByZXN1bHQuZ3JvdXBzID0geyBhOiAnNycgfTtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfTtcblx0ICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVnZXhwL25vLXVzZWxlc3MtZG9sbGFyLXJlcGxhY2VtZW50cyAtLSBmYWxzZSBwb3NpdGl2ZVxuXHQgIHJldHVybiAnJy5yZXBsYWNlKHJlLCAnJDxhPicpICE9PSAnNyc7XG5cdH0pO1xuXG5cdC8vIEBAcmVwbGFjZSBsb2dpY1xuXHRmaXhSZWdleHBXZWxsS25vd25TeW1ib2xMb2dpYygncmVwbGFjZScsIGZ1bmN0aW9uIChfLCBuYXRpdmVSZXBsYWNlLCBtYXliZUNhbGxOYXRpdmUpIHtcblx0ICB2YXIgVU5TQUZFX1NVQlNUSVRVVEUgPSBSRUdFWFBfUkVQTEFDRV9TVUJTVElUVVRFU19VTkRFRklORURfQ0FQVFVSRSA/ICckJyA6ICckMCc7XG5cblx0ICByZXR1cm4gW1xuXHQgICAgLy8gYFN0cmluZy5wcm90b3R5cGUucmVwbGFjZWAgbWV0aG9kXG5cdCAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUucmVwbGFjZVxuXHQgICAgZnVuY3Rpb24gcmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKSB7XG5cdCAgICAgIHZhciBPID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKTtcblx0ICAgICAgdmFyIHJlcGxhY2VyID0gc2VhcmNoVmFsdWUgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogZ2V0TWV0aG9kKHNlYXJjaFZhbHVlLCBSRVBMQUNFKTtcblx0ICAgICAgcmV0dXJuIHJlcGxhY2VyXG5cdCAgICAgICAgPyBmdW5jdGlvbkNhbGwocmVwbGFjZXIsIHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpXG5cdCAgICAgICAgOiBmdW5jdGlvbkNhbGwobmF0aXZlUmVwbGFjZSwgdG9TdHJpbmdfMShPKSwgc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSk7XG5cdCAgICB9LFxuXHQgICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXWAgbWV0aG9kXG5cdCAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEByZXBsYWNlXG5cdCAgICBmdW5jdGlvbiAoc3RyaW5nLCByZXBsYWNlVmFsdWUpIHtcblx0ICAgICAgdmFyIHJ4ID0gYW5PYmplY3QodGhpcyk7XG5cdCAgICAgIHZhciBTID0gdG9TdHJpbmdfMShzdHJpbmcpO1xuXG5cdCAgICAgIGlmIChcblx0ICAgICAgICB0eXBlb2YgcmVwbGFjZVZhbHVlID09ICdzdHJpbmcnICYmXG5cdCAgICAgICAgc3RyaW5nSW5kZXhPZihyZXBsYWNlVmFsdWUsIFVOU0FGRV9TVUJTVElUVVRFKSA9PT0gLTEgJiZcblx0ICAgICAgICBzdHJpbmdJbmRleE9mKHJlcGxhY2VWYWx1ZSwgJyQ8JykgPT09IC0xXG5cdCAgICAgICkge1xuXHQgICAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUobmF0aXZlUmVwbGFjZSwgcngsIFMsIHJlcGxhY2VWYWx1ZSk7XG5cdCAgICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIGZ1bmN0aW9uYWxSZXBsYWNlID0gaXNDYWxsYWJsZShyZXBsYWNlVmFsdWUpO1xuXHQgICAgICBpZiAoIWZ1bmN0aW9uYWxSZXBsYWNlKSByZXBsYWNlVmFsdWUgPSB0b1N0cmluZ18xKHJlcGxhY2VWYWx1ZSk7XG5cblx0ICAgICAgdmFyIGdsb2JhbCA9IHJ4Lmdsb2JhbDtcblx0ICAgICAgaWYgKGdsb2JhbCkge1xuXHQgICAgICAgIHZhciBmdWxsVW5pY29kZSA9IHJ4LnVuaWNvZGU7XG5cdCAgICAgICAgcngubGFzdEluZGV4ID0gMDtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXHQgICAgICB3aGlsZSAodHJ1ZSkge1xuXHQgICAgICAgIHZhciByZXN1bHQgPSByZWdleHBFeGVjQWJzdHJhY3QocngsIFMpO1xuXHQgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIGJyZWFrO1xuXG5cdCAgICAgICAgcHVzaCQyKHJlc3VsdHMsIHJlc3VsdCk7XG5cdCAgICAgICAgaWYgKCFnbG9iYWwpIGJyZWFrO1xuXG5cdCAgICAgICAgdmFyIG1hdGNoU3RyID0gdG9TdHJpbmdfMShyZXN1bHRbMF0pO1xuXHQgICAgICAgIGlmIChtYXRjaFN0ciA9PT0gJycpIHJ4Lmxhc3RJbmRleCA9IGFkdmFuY2VTdHJpbmdJbmRleChTLCB0b0xlbmd0aChyeC5sYXN0SW5kZXgpLCBmdWxsVW5pY29kZSk7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgYWNjdW11bGF0ZWRSZXN1bHQgPSAnJztcblx0ICAgICAgdmFyIG5leHRTb3VyY2VQb3NpdGlvbiA9IDA7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHJlc3VsdCA9IHJlc3VsdHNbaV07XG5cblx0ICAgICAgICB2YXIgbWF0Y2hlZCA9IHRvU3RyaW5nXzEocmVzdWx0WzBdKTtcblx0ICAgICAgICB2YXIgcG9zaXRpb24gPSBtYXgkMihtaW4kMih0b0ludGVnZXJPckluZmluaXR5KHJlc3VsdC5pbmRleCksIFMubGVuZ3RoKSwgMCk7XG5cdCAgICAgICAgdmFyIGNhcHR1cmVzID0gW107XG5cdCAgICAgICAgLy8gTk9URTogVGhpcyBpcyBlcXVpdmFsZW50IHRvXG5cdCAgICAgICAgLy8gICBjYXB0dXJlcyA9IHJlc3VsdC5zbGljZSgxKS5tYXAobWF5YmVUb1N0cmluZylcblx0ICAgICAgICAvLyBidXQgZm9yIHNvbWUgcmVhc29uIGBuYXRpdmVTbGljZS5jYWxsKHJlc3VsdCwgMSwgcmVzdWx0Lmxlbmd0aClgIChjYWxsZWQgaW5cblx0ICAgICAgICAvLyB0aGUgc2xpY2UgcG9seWZpbGwgd2hlbiBzbGljaW5nIG5hdGl2ZSBhcnJheXMpIFwiZG9lc24ndCB3b3JrXCIgaW4gc2FmYXJpIDkgYW5kXG5cdCAgICAgICAgLy8gY2F1c2VzIGEgY3Jhc2ggKGh0dHBzOi8vcGFzdGViaW4uY29tL04yMVF6ZVFBKSB3aGVuIHRyeWluZyB0byBkZWJ1ZyBpdC5cblx0ICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHJlc3VsdC5sZW5ndGg7IGorKykgcHVzaCQyKGNhcHR1cmVzLCBtYXliZVRvU3RyaW5nKHJlc3VsdFtqXSkpO1xuXHQgICAgICAgIHZhciBuYW1lZENhcHR1cmVzID0gcmVzdWx0Lmdyb3Vwcztcblx0ICAgICAgICBpZiAoZnVuY3Rpb25hbFJlcGxhY2UpIHtcblx0ICAgICAgICAgIHZhciByZXBsYWNlckFyZ3MgPSBjb25jYXQkMihbbWF0Y2hlZF0sIGNhcHR1cmVzLCBwb3NpdGlvbiwgUyk7XG5cdCAgICAgICAgICBpZiAobmFtZWRDYXB0dXJlcyAhPT0gdW5kZWZpbmVkKSBwdXNoJDIocmVwbGFjZXJBcmdzLCBuYW1lZENhcHR1cmVzKTtcblx0ICAgICAgICAgIHZhciByZXBsYWNlbWVudCA9IHRvU3RyaW5nXzEoZnVuY3Rpb25BcHBseShyZXBsYWNlVmFsdWUsIHVuZGVmaW5lZCwgcmVwbGFjZXJBcmdzKSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHJlcGxhY2VtZW50ID0gZ2V0U3Vic3RpdHV0aW9uKG1hdGNoZWQsIFMsIHBvc2l0aW9uLCBjYXB0dXJlcywgbmFtZWRDYXB0dXJlcywgcmVwbGFjZVZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHBvc2l0aW9uID49IG5leHRTb3VyY2VQb3NpdGlvbikge1xuXHQgICAgICAgICAgYWNjdW11bGF0ZWRSZXN1bHQgKz0gc3RyaW5nU2xpY2UkNChTLCBuZXh0U291cmNlUG9zaXRpb24sIHBvc2l0aW9uKSArIHJlcGxhY2VtZW50O1xuXHQgICAgICAgICAgbmV4dFNvdXJjZVBvc2l0aW9uID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGFjY3VtdWxhdGVkUmVzdWx0ICsgc3RyaW5nU2xpY2UkNChTLCBuZXh0U291cmNlUG9zaXRpb24pO1xuXHQgICAgfVxuXHQgIF07XG5cdH0sICFSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUyB8fCAhUkVQTEFDRV9LRUVQU18kMCB8fCBSRUdFWFBfUkVQTEFDRV9TVUJTVElUVVRFU19VTkRFRklORURfQ0FQVFVSRSk7XG5cblx0Ly8gSGVscGVyIGZ1bmN0aW9uIHRvIHJldHJpZXZlIG9wdGlvbnMgZnJvbSBlbGVtZW50IGF0dHJpYnV0ZXNcblx0dmFyIGdldE9wdGlvbnMgPSBmdW5jdGlvbiBnZXRPcHRpb25zKG9iaikge1xuXHQgIHZhciBvcHRpb25zID0gQXJyYXkucHJvdG90eXBlLnJlZHVjZS5jYWxsKG9iaiwgZnVuY3Rpb24gKGFjYywgYXR0cmlidXRlKSB7XG5cdCAgICB2YXIgb3B0aW9uID0gYXR0cmlidXRlLm5hbWUubWF0Y2goL2RhdGEtc2ltcGxlYmFyLSguKykvKTtcblxuXHQgICAgaWYgKG9wdGlvbikge1xuXHQgICAgICB2YXIga2V5ID0gb3B0aW9uWzFdLnJlcGxhY2UoL1xcVysoLikvZywgZnVuY3Rpb24gKHgsIGNocikge1xuXHQgICAgICAgIHJldHVybiBjaHIudG9VcHBlckNhc2UoKTtcblx0ICAgICAgfSk7XG5cblx0ICAgICAgc3dpdGNoIChhdHRyaWJ1dGUudmFsdWUpIHtcblx0ICAgICAgICBjYXNlICd0cnVlJzpcblx0ICAgICAgICAgIGFjY1trZXldID0gdHJ1ZTtcblx0ICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgY2FzZSAnZmFsc2UnOlxuXHQgICAgICAgICAgYWNjW2tleV0gPSBmYWxzZTtcblx0ICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG5cdCAgICAgICAgICBhY2Nba2V5XSA9IHRydWU7XG5cdCAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICBhY2Nba2V5XSA9IGF0dHJpYnV0ZS52YWx1ZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gYWNjO1xuXHQgIH0sIHt9KTtcblx0ICByZXR1cm4gb3B0aW9ucztcblx0fTtcblx0ZnVuY3Rpb24gZ2V0RWxlbWVudFdpbmRvdyhlbGVtZW50KSB7XG5cdCAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgIWVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldykge1xuXHQgICAgcmV0dXJuIHdpbmRvdztcblx0ICB9XG5cblx0ICByZXR1cm4gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXHR9XG5cdGZ1bmN0aW9uIGdldEVsZW1lbnREb2N1bWVudChlbGVtZW50KSB7XG5cdCAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50Lm93bmVyRG9jdW1lbnQpIHtcblx0ICAgIHJldHVybiBkb2N1bWVudDtcblx0ICB9XG5cblx0ICByZXR1cm4gZWxlbWVudC5vd25lckRvY3VtZW50O1xuXHR9XG5cblx0dmFyIGNhY2hlZFNjcm9sbGJhcldpZHRoID0gbnVsbDtcblx0dmFyIGNhY2hlZERldmljZVBpeGVsUmF0aW8gPSBudWxsO1xuXG5cdGlmIChjYW5Vc2VEb20pIHtcblx0ICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKGNhY2hlZERldmljZVBpeGVsUmF0aW8gIT09IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSB7XG5cdCAgICAgIGNhY2hlZERldmljZVBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcblx0ICAgICAgY2FjaGVkU2Nyb2xsYmFyV2lkdGggPSBudWxsO1xuXHQgICAgfVxuXHQgIH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2Nyb2xsYmFyV2lkdGgoZWwpIHtcblx0ICBpZiAoY2FjaGVkU2Nyb2xsYmFyV2lkdGggPT09IG51bGwpIHtcblx0ICAgIHZhciBkb2N1bWVudCA9IGdldEVsZW1lbnREb2N1bWVudChlbCk7XG5cblx0ICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgIGNhY2hlZFNjcm9sbGJhcldpZHRoID0gMDtcblx0ICAgICAgcmV0dXJuIGNhY2hlZFNjcm9sbGJhcldpZHRoO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG5cdCAgICB2YXIgYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdCAgICBib3guY2xhc3NMaXN0LmFkZCgnc2ltcGxlYmFyLWhpZGUtc2Nyb2xsYmFyJyk7XG5cdCAgICBib2R5LmFwcGVuZENoaWxkKGJveCk7XG5cdCAgICB2YXIgd2lkdGggPSBib3guZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQ7XG5cdCAgICBib2R5LnJlbW92ZUNoaWxkKGJveCk7XG5cdCAgICBjYWNoZWRTY3JvbGxiYXJXaWR0aCA9IHdpZHRoO1xuXHQgIH1cblxuXHQgIHJldHVybiBjYWNoZWRTY3JvbGxiYXJXaWR0aDtcblx0fVxuXG5cdHZhciBTaW1wbGVCYXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuXHQgIGZ1bmN0aW9uIFNpbXBsZUJhcihlbGVtZW50LCBvcHRpb25zKSB7XG5cdCAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdCAgICB0aGlzLm9uU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICB2YXIgZWxXaW5kb3cgPSBnZXRFbGVtZW50V2luZG93KF90aGlzLmVsKTtcblxuXHQgICAgICBpZiAoIV90aGlzLnNjcm9sbFhUaWNraW5nKSB7XG5cdCAgICAgICAgZWxXaW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKF90aGlzLnNjcm9sbFgpO1xuXHQgICAgICAgIF90aGlzLnNjcm9sbFhUaWNraW5nID0gdHJ1ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICghX3RoaXMuc2Nyb2xsWVRpY2tpbmcpIHtcblx0ICAgICAgICBlbFdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3RoaXMuc2Nyb2xsWSk7XG5cdCAgICAgICAgX3RoaXMuc2Nyb2xsWVRpY2tpbmcgPSB0cnVlO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICB0aGlzLnNjcm9sbFggPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmIChfdGhpcy5heGlzLnguaXNPdmVyZmxvd2luZykge1xuXHQgICAgICAgIF90aGlzLnNob3dTY3JvbGxiYXIoJ3gnKTtcblxuXHQgICAgICAgIF90aGlzLnBvc2l0aW9uU2Nyb2xsYmFyKCd4Jyk7XG5cdCAgICAgIH1cblxuXHQgICAgICBfdGhpcy5zY3JvbGxYVGlja2luZyA9IGZhbHNlO1xuXHQgICAgfTtcblxuXHQgICAgdGhpcy5zY3JvbGxZID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICBpZiAoX3RoaXMuYXhpcy55LmlzT3ZlcmZsb3dpbmcpIHtcblx0ICAgICAgICBfdGhpcy5zaG93U2Nyb2xsYmFyKCd5Jyk7XG5cblx0ICAgICAgICBfdGhpcy5wb3NpdGlvblNjcm9sbGJhcigneScpO1xuXHQgICAgICB9XG5cblx0ICAgICAgX3RoaXMuc2Nyb2xsWVRpY2tpbmcgPSBmYWxzZTtcblx0ICAgIH07XG5cblx0ICAgIHRoaXMub25Nb3VzZUVudGVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICBfdGhpcy5zaG93U2Nyb2xsYmFyKCd4Jyk7XG5cblx0ICAgICAgX3RoaXMuc2hvd1Njcm9sbGJhcigneScpO1xuXHQgICAgfTtcblxuXHQgICAgdGhpcy5vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIF90aGlzLm1vdXNlWCA9IGUuY2xpZW50WDtcblx0ICAgICAgX3RoaXMubW91c2VZID0gZS5jbGllbnRZO1xuXG5cdCAgICAgIGlmIChfdGhpcy5heGlzLnguaXNPdmVyZmxvd2luZyB8fCBfdGhpcy5heGlzLnguZm9yY2VWaXNpYmxlKSB7XG5cdCAgICAgICAgX3RoaXMub25Nb3VzZU1vdmVGb3JBeGlzKCd4Jyk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoX3RoaXMuYXhpcy55LmlzT3ZlcmZsb3dpbmcgfHwgX3RoaXMuYXhpcy55LmZvcmNlVmlzaWJsZSkge1xuXHQgICAgICAgIF90aGlzLm9uTW91c2VNb3ZlRm9yQXhpcygneScpO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICB0aGlzLm9uTW91c2VMZWF2ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgX3RoaXMub25Nb3VzZU1vdmUuY2FuY2VsKCk7XG5cblx0ICAgICAgaWYgKF90aGlzLmF4aXMueC5pc092ZXJmbG93aW5nIHx8IF90aGlzLmF4aXMueC5mb3JjZVZpc2libGUpIHtcblx0ICAgICAgICBfdGhpcy5vbk1vdXNlTGVhdmVGb3JBeGlzKCd4Jyk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoX3RoaXMuYXhpcy55LmlzT3ZlcmZsb3dpbmcgfHwgX3RoaXMuYXhpcy55LmZvcmNlVmlzaWJsZSkge1xuXHQgICAgICAgIF90aGlzLm9uTW91c2VMZWF2ZUZvckF4aXMoJ3knKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIF90aGlzLm1vdXNlWCA9IC0xO1xuXHQgICAgICBfdGhpcy5tb3VzZVkgPSAtMTtcblx0ICAgIH07XG5cblx0ICAgIHRoaXMub25XaW5kb3dSZXNpemUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIC8vIFJlY2FsY3VsYXRlIHNjcm9sbGJhcldpZHRoIGluIGNhc2UgaXQncyBhIHpvb21cblx0ICAgICAgX3RoaXMuc2Nyb2xsYmFyV2lkdGggPSBfdGhpcy5nZXRTY3JvbGxiYXJXaWR0aCgpO1xuXG5cdCAgICAgIF90aGlzLmhpZGVOYXRpdmVTY3JvbGxiYXIoKTtcblx0ICAgIH07XG5cblx0ICAgIHRoaXMuaGlkZVNjcm9sbGJhcnMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIF90aGlzLmF4aXMueC50cmFjay5yZWN0ID0gX3RoaXMuYXhpcy54LnRyYWNrLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHQgICAgICBfdGhpcy5heGlzLnkudHJhY2sucmVjdCA9IF90aGlzLmF4aXMueS50cmFjay5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHQgICAgICBpZiAoIV90aGlzLmlzV2l0aGluQm91bmRzKF90aGlzLmF4aXMueS50cmFjay5yZWN0KSkge1xuXHQgICAgICAgIF90aGlzLmF4aXMueS5zY3JvbGxiYXIuZWwuY2xhc3NMaXN0LnJlbW92ZShfdGhpcy5jbGFzc05hbWVzLnZpc2libGUpO1xuXG5cdCAgICAgICAgX3RoaXMuYXhpcy55LmlzVmlzaWJsZSA9IGZhbHNlO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKCFfdGhpcy5pc1dpdGhpbkJvdW5kcyhfdGhpcy5heGlzLngudHJhY2sucmVjdCkpIHtcblx0ICAgICAgICBfdGhpcy5heGlzLnguc2Nyb2xsYmFyLmVsLmNsYXNzTGlzdC5yZW1vdmUoX3RoaXMuY2xhc3NOYW1lcy52aXNpYmxlKTtcblxuXHQgICAgICAgIF90aGlzLmF4aXMueC5pc1Zpc2libGUgPSBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgdGhpcy5vblBvaW50ZXJFdmVudCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHZhciBpc1dpdGhpblRyYWNrWEJvdW5kcywgaXNXaXRoaW5UcmFja1lCb3VuZHM7XG5cdCAgICAgIF90aGlzLmF4aXMueC50cmFjay5yZWN0ID0gX3RoaXMuYXhpcy54LnRyYWNrLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHQgICAgICBfdGhpcy5heGlzLnkudHJhY2sucmVjdCA9IF90aGlzLmF4aXMueS50cmFjay5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHQgICAgICBpZiAoX3RoaXMuYXhpcy54LmlzT3ZlcmZsb3dpbmcgfHwgX3RoaXMuYXhpcy54LmZvcmNlVmlzaWJsZSkge1xuXHQgICAgICAgIGlzV2l0aGluVHJhY2tYQm91bmRzID0gX3RoaXMuaXNXaXRoaW5Cb3VuZHMoX3RoaXMuYXhpcy54LnRyYWNrLnJlY3QpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKF90aGlzLmF4aXMueS5pc092ZXJmbG93aW5nIHx8IF90aGlzLmF4aXMueS5mb3JjZVZpc2libGUpIHtcblx0ICAgICAgICBpc1dpdGhpblRyYWNrWUJvdW5kcyA9IF90aGlzLmlzV2l0aGluQm91bmRzKF90aGlzLmF4aXMueS50cmFjay5yZWN0KTtcblx0ICAgICAgfSAvLyBJZiBhbnkgcG9pbnRlciBldmVudCBpcyBjYWxsZWQgb24gdGhlIHNjcm9sbGJhclxuXG5cblx0ICAgICAgaWYgKGlzV2l0aGluVHJhY2tYQm91bmRzIHx8IGlzV2l0aGluVHJhY2tZQm91bmRzKSB7XG5cdCAgICAgICAgLy8gUHJldmVudGluZyB0aGUgZXZlbnQncyBkZWZhdWx0IGFjdGlvbiBzdG9wcyB0ZXh0IGJlaW5nXG5cdCAgICAgICAgLy8gc2VsZWN0YWJsZSBkdXJpbmcgdGhlIGRyYWcuXG5cdCAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBQcmV2ZW50IGV2ZW50IGxlYWtpbmdcblxuXHQgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cblx0ICAgICAgICBpZiAoZS50eXBlID09PSAnbW91c2Vkb3duJykge1xuXHQgICAgICAgICAgaWYgKGlzV2l0aGluVHJhY2tYQm91bmRzKSB7XG5cdCAgICAgICAgICAgIF90aGlzLmF4aXMueC5zY3JvbGxiYXIucmVjdCA9IF90aGlzLmF4aXMueC5zY3JvbGxiYXIuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0ICAgICAgICAgICAgaWYgKF90aGlzLmlzV2l0aGluQm91bmRzKF90aGlzLmF4aXMueC5zY3JvbGxiYXIucmVjdCkpIHtcblx0ICAgICAgICAgICAgICBfdGhpcy5vbkRyYWdTdGFydChlLCAneCcpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgIF90aGlzLm9uVHJhY2tDbGljayhlLCAneCcpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGlmIChpc1dpdGhpblRyYWNrWUJvdW5kcykge1xuXHQgICAgICAgICAgICBfdGhpcy5heGlzLnkuc2Nyb2xsYmFyLnJlY3QgPSBfdGhpcy5heGlzLnkuc2Nyb2xsYmFyLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdCAgICAgICAgICAgIGlmIChfdGhpcy5pc1dpdGhpbkJvdW5kcyhfdGhpcy5heGlzLnkuc2Nyb2xsYmFyLnJlY3QpKSB7XG5cdCAgICAgICAgICAgICAgX3RoaXMub25EcmFnU3RhcnQoZSwgJ3knKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICBfdGhpcy5vblRyYWNrQ2xpY2soZSwgJ3knKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgdGhpcy5kcmFnID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgdmFyIGV2ZW50T2Zmc2V0O1xuXHQgICAgICB2YXIgdHJhY2sgPSBfdGhpcy5heGlzW190aGlzLmRyYWdnZWRBeGlzXS50cmFjaztcblx0ICAgICAgdmFyIHRyYWNrU2l6ZSA9IHRyYWNrLnJlY3RbX3RoaXMuYXhpc1tfdGhpcy5kcmFnZ2VkQXhpc10uc2l6ZUF0dHJdO1xuXHQgICAgICB2YXIgc2Nyb2xsYmFyID0gX3RoaXMuYXhpc1tfdGhpcy5kcmFnZ2VkQXhpc10uc2Nyb2xsYmFyO1xuXHQgICAgICB2YXIgY29udGVudFNpemUgPSBfdGhpcy5jb250ZW50V3JhcHBlckVsW190aGlzLmF4aXNbX3RoaXMuZHJhZ2dlZEF4aXNdLnNjcm9sbFNpemVBdHRyXTtcblx0ICAgICAgdmFyIGhvc3RTaXplID0gcGFyc2VJbnQoX3RoaXMuZWxTdHlsZXNbX3RoaXMuYXhpc1tfdGhpcy5kcmFnZ2VkQXhpc10uc2l6ZUF0dHJdLCAxMCk7XG5cdCAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblx0ICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHQgICAgICBpZiAoX3RoaXMuZHJhZ2dlZEF4aXMgPT09ICd5Jykge1xuXHQgICAgICAgIGV2ZW50T2Zmc2V0ID0gZS5wYWdlWTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBldmVudE9mZnNldCA9IGUucGFnZVg7XG5cdCAgICAgIH0gLy8gQ2FsY3VsYXRlIGhvdyBmYXIgdGhlIHVzZXIncyBtb3VzZSBpcyBmcm9tIHRoZSB0b3AvbGVmdCBvZiB0aGUgc2Nyb2xsYmFyIChtaW51cyB0aGUgZHJhZ09mZnNldCkuXG5cblxuXHQgICAgICB2YXIgZHJhZ1BvcyA9IGV2ZW50T2Zmc2V0IC0gdHJhY2sucmVjdFtfdGhpcy5heGlzW190aGlzLmRyYWdnZWRBeGlzXS5vZmZzZXRBdHRyXSAtIF90aGlzLmF4aXNbX3RoaXMuZHJhZ2dlZEF4aXNdLmRyYWdPZmZzZXQ7IC8vIENvbnZlcnQgdGhlIG1vdXNlIHBvc2l0aW9uIGludG8gYSBwZXJjZW50YWdlIG9mIHRoZSBzY3JvbGxiYXIgaGVpZ2h0L3dpZHRoLlxuXG5cdCAgICAgIHZhciBkcmFnUGVyYyA9IGRyYWdQb3MgLyAodHJhY2tTaXplIC0gc2Nyb2xsYmFyLnNpemUpOyAvLyBTY3JvbGwgdGhlIGNvbnRlbnQgYnkgdGhlIHNhbWUgcGVyY2VudGFnZS5cblxuXHQgICAgICB2YXIgc2Nyb2xsUG9zID0gZHJhZ1BlcmMgKiAoY29udGVudFNpemUgLSBob3N0U2l6ZSk7IC8vIEZpeCBicm93c2VycyBpbmNvbnNpc3RlbmN5IG9uIFJUTFxuXG5cdCAgICAgIGlmIChfdGhpcy5kcmFnZ2VkQXhpcyA9PT0gJ3gnKSB7XG5cdCAgICAgICAgc2Nyb2xsUG9zID0gX3RoaXMuaXNSdGwgJiYgU2ltcGxlQmFyLmdldFJ0bEhlbHBlcnMoKS5pc1J0bFNjcm9sbGJhckludmVydGVkID8gc2Nyb2xsUG9zIC0gKHRyYWNrU2l6ZSArIHNjcm9sbGJhci5zaXplKSA6IHNjcm9sbFBvcztcblx0ICAgICAgICBzY3JvbGxQb3MgPSBfdGhpcy5pc1J0bCAmJiBTaW1wbGVCYXIuZ2V0UnRsSGVscGVycygpLmlzUnRsU2Nyb2xsaW5nSW52ZXJ0ZWQgPyAtc2Nyb2xsUG9zIDogc2Nyb2xsUG9zO1xuXHQgICAgICB9XG5cblx0ICAgICAgX3RoaXMuY29udGVudFdyYXBwZXJFbFtfdGhpcy5heGlzW190aGlzLmRyYWdnZWRBeGlzXS5zY3JvbGxPZmZzZXRBdHRyXSA9IHNjcm9sbFBvcztcblx0ICAgIH07XG5cblx0ICAgIHRoaXMub25FbmREcmFnID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgdmFyIGVsRG9jdW1lbnQgPSBnZXRFbGVtZW50RG9jdW1lbnQoX3RoaXMuZWwpO1xuXHQgICAgICB2YXIgZWxXaW5kb3cgPSBnZXRFbGVtZW50V2luZG93KF90aGlzLmVsKTtcblx0ICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHQgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdCAgICAgIF90aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoX3RoaXMuY2xhc3NOYW1lcy5kcmFnZ2luZyk7XG5cblx0ICAgICAgZWxEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfdGhpcy5kcmFnLCB0cnVlKTtcblx0ICAgICAgZWxEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgX3RoaXMub25FbmREcmFnLCB0cnVlKTtcblx0ICAgICAgX3RoaXMucmVtb3ZlUHJldmVudENsaWNrSWQgPSBlbFdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvLyBSZW1vdmUgdGhlc2UgYXN5bmNocm9ub3VzbHkgc28gd2Ugc3RpbGwgc3VwcHJlc3MgY2xpY2sgZXZlbnRzXG5cdCAgICAgICAgLy8gZ2VuZXJhdGVkIHNpbXVsdGFuZW91c2x5IHdpdGggbW91c2V1cC5cblx0ICAgICAgICBlbERvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX3RoaXMucHJldmVudENsaWNrLCB0cnVlKTtcblx0ICAgICAgICBlbERvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgX3RoaXMucHJldmVudENsaWNrLCB0cnVlKTtcblx0ICAgICAgICBfdGhpcy5yZW1vdmVQcmV2ZW50Q2xpY2tJZCA9IG51bGw7XG5cdCAgICAgIH0pO1xuXHQgICAgfTtcblxuXHQgICAgdGhpcy5wcmV2ZW50Q2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cdCAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdCAgICB9O1xuXG5cdCAgICB0aGlzLmVsID0gZWxlbWVudDtcblx0ICAgIHRoaXMubWluU2Nyb2xsYmFyV2lkdGggPSAyMDtcblx0ICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIFNpbXBsZUJhci5kZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG5cdCAgICB0aGlzLmNsYXNzTmFtZXMgPSBPYmplY3QuYXNzaWduKHt9LCBTaW1wbGVCYXIuZGVmYXVsdE9wdGlvbnMuY2xhc3NOYW1lcywgdGhpcy5vcHRpb25zLmNsYXNzTmFtZXMpO1xuXHQgICAgdGhpcy5heGlzID0ge1xuXHQgICAgICB4OiB7XG5cdCAgICAgICAgc2Nyb2xsT2Zmc2V0QXR0cjogJ3Njcm9sbExlZnQnLFxuXHQgICAgICAgIHNpemVBdHRyOiAnd2lkdGgnLFxuXHQgICAgICAgIHNjcm9sbFNpemVBdHRyOiAnc2Nyb2xsV2lkdGgnLFxuXHQgICAgICAgIG9mZnNldFNpemVBdHRyOiAnb2Zmc2V0V2lkdGgnLFxuXHQgICAgICAgIG9mZnNldEF0dHI6ICdsZWZ0Jyxcblx0ICAgICAgICBvdmVyZmxvd0F0dHI6ICdvdmVyZmxvd1gnLFxuXHQgICAgICAgIGRyYWdPZmZzZXQ6IDAsXG5cdCAgICAgICAgaXNPdmVyZmxvd2luZzogdHJ1ZSxcblx0ICAgICAgICBpc1Zpc2libGU6IGZhbHNlLFxuXHQgICAgICAgIGZvcmNlVmlzaWJsZTogZmFsc2UsXG5cdCAgICAgICAgdHJhY2s6IHt9LFxuXHQgICAgICAgIHNjcm9sbGJhcjoge31cblx0ICAgICAgfSxcblx0ICAgICAgeToge1xuXHQgICAgICAgIHNjcm9sbE9mZnNldEF0dHI6ICdzY3JvbGxUb3AnLFxuXHQgICAgICAgIHNpemVBdHRyOiAnaGVpZ2h0Jyxcblx0ICAgICAgICBzY3JvbGxTaXplQXR0cjogJ3Njcm9sbEhlaWdodCcsXG5cdCAgICAgICAgb2Zmc2V0U2l6ZUF0dHI6ICdvZmZzZXRIZWlnaHQnLFxuXHQgICAgICAgIG9mZnNldEF0dHI6ICd0b3AnLFxuXHQgICAgICAgIG92ZXJmbG93QXR0cjogJ292ZXJmbG93WScsXG5cdCAgICAgICAgZHJhZ09mZnNldDogMCxcblx0ICAgICAgICBpc092ZXJmbG93aW5nOiB0cnVlLFxuXHQgICAgICAgIGlzVmlzaWJsZTogZmFsc2UsXG5cdCAgICAgICAgZm9yY2VWaXNpYmxlOiBmYWxzZSxcblx0ICAgICAgICB0cmFjazoge30sXG5cdCAgICAgICAgc2Nyb2xsYmFyOiB7fVxuXHQgICAgICB9XG5cdCAgICB9O1xuXHQgICAgdGhpcy5yZW1vdmVQcmV2ZW50Q2xpY2tJZCA9IG51bGw7IC8vIERvbid0IHJlLWluc3RhbnRpYXRlIG92ZXIgYW4gZXhpc3Rpbmcgb25lXG5cblx0ICAgIGlmIChTaW1wbGVCYXIuaW5zdGFuY2VzLmhhcyh0aGlzLmVsKSkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIHRoaXMucmVjYWxjdWxhdGUgPSBsb2Rhc2hfdGhyb3R0bGUodGhpcy5yZWNhbGN1bGF0ZS5iaW5kKHRoaXMpLCA2NCk7XG5cdCAgICB0aGlzLm9uTW91c2VNb3ZlID0gbG9kYXNoX3Rocm90dGxlKHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKSwgNjQpO1xuXHQgICAgdGhpcy5oaWRlU2Nyb2xsYmFycyA9IGxvZGFzaF9kZWJvdW5jZSh0aGlzLmhpZGVTY3JvbGxiYXJzLmJpbmQodGhpcyksIHRoaXMub3B0aW9ucy50aW1lb3V0KTtcblx0ICAgIHRoaXMub25XaW5kb3dSZXNpemUgPSBsb2Rhc2hfZGVib3VuY2UodGhpcy5vbldpbmRvd1Jlc2l6ZS5iaW5kKHRoaXMpLCA2NCwge1xuXHQgICAgICBsZWFkaW5nOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIFNpbXBsZUJhci5nZXRSdGxIZWxwZXJzID0gbG9kYXNoX21lbW9pemUoU2ltcGxlQmFyLmdldFJ0bEhlbHBlcnMpO1xuXHQgICAgdGhpcy5pbml0KCk7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFN0YXRpYyBwcm9wZXJ0aWVzXG5cdCAgICovXG5cblx0ICAvKipcblx0ICAgKiBIZWxwZXIgdG8gZml4IGJyb3dzZXJzIGluY29uc2lzdGVuY3kgb24gUlRMOlxuXHQgICAqICAtIEZpcmVmb3ggaW52ZXJ0cyB0aGUgc2Nyb2xsYmFyIGluaXRpYWwgcG9zaXRpb25cblx0ICAgKiAgLSBJRTExIGludmVydHMgYm90aCBzY3JvbGxiYXIgcG9zaXRpb24gYW5kIHNjcm9sbGluZyBvZmZzZXRcblx0ICAgKiBEaXJlY3RseSBpbnNwaXJlZCBieSBAS2luZ1NvcmEncyBPdmVybGF5U2Nyb2xsYmFycyBodHRwczovL2dpdGh1Yi5jb20vS2luZ1NvcmEvT3ZlcmxheVNjcm9sbGJhcnMvYmxvYi9tYXN0ZXIvanMvT3ZlcmxheVNjcm9sbGJhcnMuanMjTDE2MzRcblx0ICAgKi9cblxuXG5cdCAgU2ltcGxlQmFyLmdldFJ0bEhlbHBlcnMgPSBmdW5jdGlvbiBnZXRSdGxIZWxwZXJzKCkge1xuXHQgICAgdmFyIGR1bW15RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdCAgICBkdW1teURpdi5pbm5lckhUTUwgPSAnPGRpdiBjbGFzcz1cImhzLWR1bW15LXNjcm9sbGJhci1zaXplXCI+PGRpdiBzdHlsZT1cImhlaWdodDogMjAwJTsgd2lkdGg6IDIwMCU7IG1hcmdpbjogMTBweCAwO1wiPjwvZGl2PjwvZGl2Pic7XG5cdCAgICB2YXIgc2Nyb2xsYmFyRHVtbXlFbCA9IGR1bW15RGl2LmZpcnN0RWxlbWVudENoaWxkO1xuXHQgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JvbGxiYXJEdW1teUVsKTtcblx0ICAgIHZhciBkdW1teUNvbnRhaW5lckNoaWxkID0gc2Nyb2xsYmFyRHVtbXlFbC5maXJzdEVsZW1lbnRDaGlsZDtcblx0ICAgIHNjcm9sbGJhckR1bW15RWwuc2Nyb2xsTGVmdCA9IDA7XG5cdCAgICB2YXIgZHVtbXlDb250YWluZXJPZmZzZXQgPSBTaW1wbGVCYXIuZ2V0T2Zmc2V0KHNjcm9sbGJhckR1bW15RWwpO1xuXHQgICAgdmFyIGR1bW15Q29udGFpbmVyQ2hpbGRPZmZzZXQgPSBTaW1wbGVCYXIuZ2V0T2Zmc2V0KGR1bW15Q29udGFpbmVyQ2hpbGQpO1xuXHQgICAgc2Nyb2xsYmFyRHVtbXlFbC5zY3JvbGxMZWZ0ID0gOTk5O1xuXHQgICAgdmFyIGR1bW15Q29udGFpbmVyU2Nyb2xsT2Zmc2V0QWZ0ZXJTY3JvbGwgPSBTaW1wbGVCYXIuZ2V0T2Zmc2V0KGR1bW15Q29udGFpbmVyQ2hpbGQpO1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgLy8gZGV0ZXJtaW5lcyBpZiB0aGUgc2Nyb2xsaW5nIGlzIHJlc3BvbmRpbmcgd2l0aCBuZWdhdGl2ZSB2YWx1ZXNcblx0ICAgICAgaXNSdGxTY3JvbGxpbmdJbnZlcnRlZDogZHVtbXlDb250YWluZXJPZmZzZXQubGVmdCAhPT0gZHVtbXlDb250YWluZXJDaGlsZE9mZnNldC5sZWZ0ICYmIGR1bW15Q29udGFpbmVyQ2hpbGRPZmZzZXQubGVmdCAtIGR1bW15Q29udGFpbmVyU2Nyb2xsT2Zmc2V0QWZ0ZXJTY3JvbGwubGVmdCAhPT0gMCxcblx0ICAgICAgLy8gZGV0ZXJtaW5lcyBpZiB0aGUgb3JpZ2luIHNjcm9sbGJhciBwb3NpdGlvbiBpcyBpbnZlcnRlZCBvciBub3QgKHBvc2l0aW9uZWQgb24gbGVmdCBvciByaWdodClcblx0ICAgICAgaXNSdGxTY3JvbGxiYXJJbnZlcnRlZDogZHVtbXlDb250YWluZXJPZmZzZXQubGVmdCAhPT0gZHVtbXlDb250YWluZXJDaGlsZE9mZnNldC5sZWZ0XG5cdCAgICB9O1xuXHQgIH07XG5cblx0ICBTaW1wbGVCYXIuZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gZ2V0T2Zmc2V0KGVsKSB7XG5cdCAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHQgICAgdmFyIGVsRG9jdW1lbnQgPSBnZXRFbGVtZW50RG9jdW1lbnQoZWwpO1xuXHQgICAgdmFyIGVsV2luZG93ID0gZ2V0RWxlbWVudFdpbmRvdyhlbCk7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICB0b3A6IHJlY3QudG9wICsgKGVsV2luZG93LnBhZ2VZT2Zmc2V0IHx8IGVsRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCksXG5cdCAgICAgIGxlZnQ6IHJlY3QubGVmdCArIChlbFdpbmRvdy5wYWdlWE9mZnNldCB8fCBlbERvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0KVxuXHQgICAgfTtcblx0ICB9O1xuXG5cdCAgdmFyIF9wcm90byA9IFNpbXBsZUJhci5wcm90b3R5cGU7XG5cblx0ICBfcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIGluaXQoKSB7XG5cdCAgICAvLyBTYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBpbnN0YW5jZSwgc28gd2Uga25vdyB0aGlzIERPTSBub2RlIGhhcyBhbHJlYWR5IGJlZW4gaW5zdGFuY2llZFxuXHQgICAgU2ltcGxlQmFyLmluc3RhbmNlcy5zZXQodGhpcy5lbCwgdGhpcyk7IC8vIFdlIHN0b3AgaGVyZSBvbiBzZXJ2ZXItc2lkZVxuXG5cdCAgICBpZiAoY2FuVXNlRG9tKSB7XG5cdCAgICAgIHRoaXMuaW5pdERPTSgpO1xuXHQgICAgICB0aGlzLnNldEFjY2Vzc2liaWxpdHlBdHRyaWJ1dGVzKCk7XG5cdCAgICAgIHRoaXMuc2Nyb2xsYmFyV2lkdGggPSB0aGlzLmdldFNjcm9sbGJhcldpZHRoKCk7XG5cdCAgICAgIHRoaXMucmVjYWxjdWxhdGUoKTtcblx0ICAgICAgdGhpcy5pbml0TGlzdGVuZXJzKCk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIF9wcm90by5pbml0RE9NID0gZnVuY3Rpb24gaW5pdERPTSgpIHtcblx0ICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG5cdCAgICAvLyBtYWtlIHN1cmUgdGhpcyBlbGVtZW50IGRvZXNuJ3QgaGF2ZSB0aGUgZWxlbWVudHMgeWV0XG5cdCAgICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKHRoaXMuZWwuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuXHQgICAgICByZXR1cm4gY2hpbGQuY2xhc3NMaXN0LmNvbnRhaW5zKF90aGlzMi5jbGFzc05hbWVzLndyYXBwZXIpO1xuXHQgICAgfSkubGVuZ3RoKSB7XG5cdCAgICAgIC8vIGFzc3VtZSB0aGF0IGVsZW1lbnQgaGFzIGhpcyBET00gYWxyZWFkeSBpbml0aWF0ZWRcblx0ICAgICAgdGhpcy53cmFwcGVyRWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyB0aGlzLmNsYXNzTmFtZXMud3JhcHBlcik7XG5cdCAgICAgIHRoaXMuY29udGVudFdyYXBwZXJFbCA9IHRoaXMub3B0aW9ucy5zY3JvbGxhYmxlTm9kZSB8fCB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyB0aGlzLmNsYXNzTmFtZXMuY29udGVudFdyYXBwZXIpO1xuXHQgICAgICB0aGlzLmNvbnRlbnRFbCA9IHRoaXMub3B0aW9ucy5jb250ZW50Tm9kZSB8fCB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyB0aGlzLmNsYXNzTmFtZXMuY29udGVudEVsKTtcblx0ICAgICAgdGhpcy5vZmZzZXRFbCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcihcIi5cIiArIHRoaXMuY2xhc3NOYW1lcy5vZmZzZXQpO1xuXHQgICAgICB0aGlzLm1hc2tFbCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcihcIi5cIiArIHRoaXMuY2xhc3NOYW1lcy5tYXNrKTtcblx0ICAgICAgdGhpcy5wbGFjZWhvbGRlckVsID0gdGhpcy5maW5kQ2hpbGQodGhpcy53cmFwcGVyRWwsIFwiLlwiICsgdGhpcy5jbGFzc05hbWVzLnBsYWNlaG9sZGVyKTtcblx0ICAgICAgdGhpcy5oZWlnaHRBdXRvT2JzZXJ2ZXJXcmFwcGVyRWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyB0aGlzLmNsYXNzTmFtZXMuaGVpZ2h0QXV0b09ic2VydmVyV3JhcHBlckVsKTtcblx0ICAgICAgdGhpcy5oZWlnaHRBdXRvT2JzZXJ2ZXJFbCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcihcIi5cIiArIHRoaXMuY2xhc3NOYW1lcy5oZWlnaHRBdXRvT2JzZXJ2ZXJFbCk7XG5cdCAgICAgIHRoaXMuYXhpcy54LnRyYWNrLmVsID0gdGhpcy5maW5kQ2hpbGQodGhpcy5lbCwgXCIuXCIgKyB0aGlzLmNsYXNzTmFtZXMudHJhY2sgKyBcIi5cIiArIHRoaXMuY2xhc3NOYW1lcy5ob3Jpem9udGFsKTtcblx0ICAgICAgdGhpcy5heGlzLnkudHJhY2suZWwgPSB0aGlzLmZpbmRDaGlsZCh0aGlzLmVsLCBcIi5cIiArIHRoaXMuY2xhc3NOYW1lcy50cmFjayArIFwiLlwiICsgdGhpcy5jbGFzc05hbWVzLnZlcnRpY2FsKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIFByZXBhcmUgRE9NXG5cdCAgICAgIHRoaXMud3JhcHBlckVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdCAgICAgIHRoaXMuY29udGVudFdyYXBwZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHQgICAgICB0aGlzLm9mZnNldEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdCAgICAgIHRoaXMubWFza0VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdCAgICAgIHRoaXMuY29udGVudEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdCAgICAgIHRoaXMucGxhY2Vob2xkZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHQgICAgICB0aGlzLmhlaWdodEF1dG9PYnNlcnZlcldyYXBwZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHQgICAgICB0aGlzLmhlaWdodEF1dG9PYnNlcnZlckVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdCAgICAgIHRoaXMud3JhcHBlckVsLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLndyYXBwZXIpO1xuXHQgICAgICB0aGlzLmNvbnRlbnRXcmFwcGVyRWwuY2xhc3NMaXN0LmFkZCh0aGlzLmNsYXNzTmFtZXMuY29udGVudFdyYXBwZXIpO1xuXHQgICAgICB0aGlzLm9mZnNldEVsLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLm9mZnNldCk7XG5cdCAgICAgIHRoaXMubWFza0VsLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLm1hc2spO1xuXHQgICAgICB0aGlzLmNvbnRlbnRFbC5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lcy5jb250ZW50RWwpO1xuXHQgICAgICB0aGlzLnBsYWNlaG9sZGVyRWwuY2xhc3NMaXN0LmFkZCh0aGlzLmNsYXNzTmFtZXMucGxhY2Vob2xkZXIpO1xuXHQgICAgICB0aGlzLmhlaWdodEF1dG9PYnNlcnZlcldyYXBwZXJFbC5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lcy5oZWlnaHRBdXRvT2JzZXJ2ZXJXcmFwcGVyRWwpO1xuXHQgICAgICB0aGlzLmhlaWdodEF1dG9PYnNlcnZlckVsLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLmhlaWdodEF1dG9PYnNlcnZlckVsKTtcblxuXHQgICAgICB3aGlsZSAodGhpcy5lbC5maXJzdENoaWxkKSB7XG5cdCAgICAgICAgdGhpcy5jb250ZW50RWwuYXBwZW5kQ2hpbGQodGhpcy5lbC5maXJzdENoaWxkKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMuY29udGVudFdyYXBwZXJFbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRFbCk7XG5cdCAgICAgIHRoaXMub2Zmc2V0RWwuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50V3JhcHBlckVsKTtcblx0ICAgICAgdGhpcy5tYXNrRWwuYXBwZW5kQ2hpbGQodGhpcy5vZmZzZXRFbCk7XG5cdCAgICAgIHRoaXMuaGVpZ2h0QXV0b09ic2VydmVyV3JhcHBlckVsLmFwcGVuZENoaWxkKHRoaXMuaGVpZ2h0QXV0b09ic2VydmVyRWwpO1xuXHQgICAgICB0aGlzLndyYXBwZXJFbC5hcHBlbmRDaGlsZCh0aGlzLmhlaWdodEF1dG9PYnNlcnZlcldyYXBwZXJFbCk7XG5cdCAgICAgIHRoaXMud3JhcHBlckVsLmFwcGVuZENoaWxkKHRoaXMubWFza0VsKTtcblx0ICAgICAgdGhpcy53cmFwcGVyRWwuYXBwZW5kQ2hpbGQodGhpcy5wbGFjZWhvbGRlckVsKTtcblx0ICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZCh0aGlzLndyYXBwZXJFbCk7XG5cdCAgICB9XG5cblx0ICAgIGlmICghdGhpcy5heGlzLngudHJhY2suZWwgfHwgIXRoaXMuYXhpcy55LnRyYWNrLmVsKSB7XG5cdCAgICAgIHZhciB0cmFjayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHQgICAgICB2YXIgc2Nyb2xsYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdCAgICAgIHRyYWNrLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLnRyYWNrKTtcblx0ICAgICAgc2Nyb2xsYmFyLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLnNjcm9sbGJhcik7XG5cdCAgICAgIHRyYWNrLmFwcGVuZENoaWxkKHNjcm9sbGJhcik7XG5cdCAgICAgIHRoaXMuYXhpcy54LnRyYWNrLmVsID0gdHJhY2suY2xvbmVOb2RlKHRydWUpO1xuXHQgICAgICB0aGlzLmF4aXMueC50cmFjay5lbC5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lcy5ob3Jpem9udGFsKTtcblx0ICAgICAgdGhpcy5heGlzLnkudHJhY2suZWwgPSB0cmFjay5jbG9uZU5vZGUodHJ1ZSk7XG5cdCAgICAgIHRoaXMuYXhpcy55LnRyYWNrLmVsLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLnZlcnRpY2FsKTtcblx0ICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZCh0aGlzLmF4aXMueC50cmFjay5lbCk7XG5cdCAgICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQodGhpcy5heGlzLnkudHJhY2suZWwpO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLmF4aXMueC5zY3JvbGxiYXIuZWwgPSB0aGlzLmF4aXMueC50cmFjay5lbC5xdWVyeVNlbGVjdG9yKFwiLlwiICsgdGhpcy5jbGFzc05hbWVzLnNjcm9sbGJhcik7XG5cdCAgICB0aGlzLmF4aXMueS5zY3JvbGxiYXIuZWwgPSB0aGlzLmF4aXMueS50cmFjay5lbC5xdWVyeVNlbGVjdG9yKFwiLlwiICsgdGhpcy5jbGFzc05hbWVzLnNjcm9sbGJhcik7XG5cblx0ICAgIGlmICghdGhpcy5vcHRpb25zLmF1dG9IaWRlKSB7XG5cdCAgICAgIHRoaXMuYXhpcy54LnNjcm9sbGJhci5lbC5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lcy52aXNpYmxlKTtcblx0ICAgICAgdGhpcy5heGlzLnkuc2Nyb2xsYmFyLmVsLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLnZpc2libGUpO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLmVsLnNldEF0dHJpYnV0ZSgnZGF0YS1zaW1wbGViYXInLCAnaW5pdCcpO1xuXHQgIH07XG5cblx0ICBfcHJvdG8uc2V0QWNjZXNzaWJpbGl0eUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiBzZXRBY2Nlc3NpYmlsaXR5QXR0cmlidXRlcygpIHtcblx0ICAgIHZhciBhcmlhTGFiZWwgPSB0aGlzLm9wdGlvbnMuYXJpYUxhYmVsIHx8ICdzY3JvbGxhYmxlIGNvbnRlbnQnO1xuXHQgICAgdGhpcy5jb250ZW50V3JhcHBlckVsLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnMCcpO1xuXHQgICAgdGhpcy5jb250ZW50V3JhcHBlckVsLnNldEF0dHJpYnV0ZSgncm9sZScsICdyZWdpb24nKTtcblx0ICAgIHRoaXMuY29udGVudFdyYXBwZXJFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBhcmlhTGFiZWwpO1xuXHQgIH07XG5cblx0ICBfcHJvdG8uaW5pdExpc3RlbmVycyA9IGZ1bmN0aW9uIGluaXRMaXN0ZW5lcnMoKSB7XG5cdCAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuXHQgICAgdmFyIGVsV2luZG93ID0gZ2V0RWxlbWVudFdpbmRvdyh0aGlzLmVsKTsgLy8gRXZlbnQgbGlzdGVuZXJzXG5cblx0ICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b0hpZGUpIHtcblx0ICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5vbk1vdXNlRW50ZXIpO1xuXHQgICAgfVxuXG5cdCAgICBbJ21vdXNlZG93bicsICdjbGljaycsICdkYmxjbGljayddLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgX3RoaXMzLmVsLmFkZEV2ZW50TGlzdGVuZXIoZSwgX3RoaXMzLm9uUG9pbnRlckV2ZW50LCB0cnVlKTtcblx0ICAgIH0pO1xuXHQgICAgWyd0b3VjaHN0YXJ0JywgJ3RvdWNoZW5kJywgJ3RvdWNobW92ZSddLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgX3RoaXMzLmVsLmFkZEV2ZW50TGlzdGVuZXIoZSwgX3RoaXMzLm9uUG9pbnRlckV2ZW50LCB7XG5cdCAgICAgICAgY2FwdHVyZTogdHJ1ZSxcblx0ICAgICAgICBwYXNzaXZlOiB0cnVlXG5cdCAgICAgIH0pO1xuXHQgICAgfSk7XG5cdCAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUpO1xuXHQgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5vbk1vdXNlTGVhdmUpO1xuXHQgICAgdGhpcy5jb250ZW50V3JhcHBlckVsLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMub25TY3JvbGwpOyAvLyBCcm93c2VyIHpvb20gdHJpZ2dlcnMgYSB3aW5kb3cgcmVzaXplXG5cblx0ICAgIGVsV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMub25XaW5kb3dSZXNpemUpOyAvLyBIYWNrIGZvciBodHRwczovL2dpdGh1Yi5jb20vV0lDRy9SZXNpemVPYnNlcnZlci9pc3N1ZXMvMzhcblxuXHQgICAgdmFyIHJlc2l6ZU9ic2VydmVyU3RhcnRlZCA9IGZhbHNlO1xuXHQgICAgdmFyIHJlc2l6ZUFuaW1hdGlvbkZyYW1lSWQgPSBudWxsO1xuXHQgICAgdmFyIHJlc2l6ZU9ic2VydmVyID0gZWxXaW5kb3cuUmVzaXplT2JzZXJ2ZXIgfHwgUmVzaXplT2JzZXJ2ZXI7XG5cdCAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IHJlc2l6ZU9ic2VydmVyKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKCFyZXNpemVPYnNlcnZlclN0YXJ0ZWQgfHwgcmVzaXplQW5pbWF0aW9uRnJhbWVJZCAhPT0gbnVsbCkgcmV0dXJuO1xuXHQgICAgICByZXNpemVBbmltYXRpb25GcmFtZUlkID0gZWxXaW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBfdGhpczMucmVjYWxjdWxhdGUoKTtcblxuXHQgICAgICAgIHJlc2l6ZUFuaW1hdGlvbkZyYW1lSWQgPSBudWxsO1xuXHQgICAgICB9KTtcblx0ICAgIH0pO1xuXHQgICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuZWwpO1xuXHQgICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuY29udGVudEVsKTtcblx0ICAgIGVsV2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJlc2l6ZU9ic2VydmVyU3RhcnRlZCA9IHRydWU7XG5cdCAgICB9KTsgLy8gVGhpcyBpcyByZXF1aXJlZCB0byBkZXRlY3QgaG9yaXpvbnRhbCBzY3JvbGwuIFZlcnRpY2FsIHNjcm9sbCBvbmx5IG5lZWRzIHRoZSByZXNpemVPYnNlcnZlci5cblxuXHQgICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyID0gbmV3IGVsV2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIodGhpcy5yZWNhbGN1bGF0ZSk7XG5cdCAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmNvbnRlbnRFbCwge1xuXHQgICAgICBjaGlsZExpc3Q6IHRydWUsXG5cdCAgICAgIHN1YnRyZWU6IHRydWUsXG5cdCAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcblx0ICAgIH0pO1xuXHQgIH07XG5cblx0ICBfcHJvdG8ucmVjYWxjdWxhdGUgPSBmdW5jdGlvbiByZWNhbGN1bGF0ZSgpIHtcblx0ICAgIHZhciBlbFdpbmRvdyA9IGdldEVsZW1lbnRXaW5kb3codGhpcy5lbCk7XG5cdCAgICB0aGlzLmVsU3R5bGVzID0gZWxXaW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsKTtcblx0ICAgIHRoaXMuaXNSdGwgPSB0aGlzLmVsU3R5bGVzLmRpcmVjdGlvbiA9PT0gJ3J0bCc7XG5cdCAgICB2YXIgaXNIZWlnaHRBdXRvID0gdGhpcy5oZWlnaHRBdXRvT2JzZXJ2ZXJFbC5vZmZzZXRIZWlnaHQgPD0gMTtcblx0ICAgIHZhciBpc1dpZHRoQXV0byA9IHRoaXMuaGVpZ2h0QXV0b09ic2VydmVyRWwub2Zmc2V0V2lkdGggPD0gMTtcblx0ICAgIHZhciBjb250ZW50RWxPZmZzZXRXaWR0aCA9IHRoaXMuY29udGVudEVsLm9mZnNldFdpZHRoO1xuXHQgICAgdmFyIGNvbnRlbnRXcmFwcGVyRWxPZmZzZXRXaWR0aCA9IHRoaXMuY29udGVudFdyYXBwZXJFbC5vZmZzZXRXaWR0aDtcblx0ICAgIHZhciBlbE92ZXJmbG93WCA9IHRoaXMuZWxTdHlsZXMub3ZlcmZsb3dYO1xuXHQgICAgdmFyIGVsT3ZlcmZsb3dZID0gdGhpcy5lbFN0eWxlcy5vdmVyZmxvd1k7XG5cdCAgICB0aGlzLmNvbnRlbnRFbC5zdHlsZS5wYWRkaW5nID0gdGhpcy5lbFN0eWxlcy5wYWRkaW5nVG9wICsgXCIgXCIgKyB0aGlzLmVsU3R5bGVzLnBhZGRpbmdSaWdodCArIFwiIFwiICsgdGhpcy5lbFN0eWxlcy5wYWRkaW5nQm90dG9tICsgXCIgXCIgKyB0aGlzLmVsU3R5bGVzLnBhZGRpbmdMZWZ0O1xuXHQgICAgdGhpcy53cmFwcGVyRWwuc3R5bGUubWFyZ2luID0gXCItXCIgKyB0aGlzLmVsU3R5bGVzLnBhZGRpbmdUb3AgKyBcIiAtXCIgKyB0aGlzLmVsU3R5bGVzLnBhZGRpbmdSaWdodCArIFwiIC1cIiArIHRoaXMuZWxTdHlsZXMucGFkZGluZ0JvdHRvbSArIFwiIC1cIiArIHRoaXMuZWxTdHlsZXMucGFkZGluZ0xlZnQ7XG5cdCAgICB2YXIgY29udGVudEVsU2Nyb2xsSGVpZ2h0ID0gdGhpcy5jb250ZW50RWwuc2Nyb2xsSGVpZ2h0O1xuXHQgICAgdmFyIGNvbnRlbnRFbFNjcm9sbFdpZHRoID0gdGhpcy5jb250ZW50RWwuc2Nyb2xsV2lkdGg7XG5cdCAgICB0aGlzLmNvbnRlbnRXcmFwcGVyRWwuc3R5bGUuaGVpZ2h0ID0gaXNIZWlnaHRBdXRvID8gJ2F1dG8nIDogJzEwMCUnOyAvLyBEZXRlcm1pbmUgcGxhY2Vob2xkZXIgc2l6ZVxuXG5cdCAgICB0aGlzLnBsYWNlaG9sZGVyRWwuc3R5bGUud2lkdGggPSBpc1dpZHRoQXV0byA/IGNvbnRlbnRFbE9mZnNldFdpZHRoICsgXCJweFwiIDogJ2F1dG8nO1xuXHQgICAgdGhpcy5wbGFjZWhvbGRlckVsLnN0eWxlLmhlaWdodCA9IGNvbnRlbnRFbFNjcm9sbEhlaWdodCArIFwicHhcIjtcblx0ICAgIHZhciBjb250ZW50V3JhcHBlckVsT2Zmc2V0SGVpZ2h0ID0gdGhpcy5jb250ZW50V3JhcHBlckVsLm9mZnNldEhlaWdodDtcblx0ICAgIHRoaXMuYXhpcy54LmlzT3ZlcmZsb3dpbmcgPSBjb250ZW50RWxTY3JvbGxXaWR0aCA+IGNvbnRlbnRFbE9mZnNldFdpZHRoO1xuXHQgICAgdGhpcy5heGlzLnkuaXNPdmVyZmxvd2luZyA9IGNvbnRlbnRFbFNjcm9sbEhlaWdodCA+IGNvbnRlbnRXcmFwcGVyRWxPZmZzZXRIZWlnaHQ7IC8vIFNldCBpc092ZXJmbG93aW5nIHRvIGZhbHNlIGlmIHVzZXIgZXhwbGljaXRlbHkgc2V0IGhpZGRlbiBvdmVyZmxvd1xuXG5cdCAgICB0aGlzLmF4aXMueC5pc092ZXJmbG93aW5nID0gZWxPdmVyZmxvd1ggPT09ICdoaWRkZW4nID8gZmFsc2UgOiB0aGlzLmF4aXMueC5pc092ZXJmbG93aW5nO1xuXHQgICAgdGhpcy5heGlzLnkuaXNPdmVyZmxvd2luZyA9IGVsT3ZlcmZsb3dZID09PSAnaGlkZGVuJyA/IGZhbHNlIDogdGhpcy5heGlzLnkuaXNPdmVyZmxvd2luZztcblx0ICAgIHRoaXMuYXhpcy54LmZvcmNlVmlzaWJsZSA9IHRoaXMub3B0aW9ucy5mb3JjZVZpc2libGUgPT09ICd4JyB8fCB0aGlzLm9wdGlvbnMuZm9yY2VWaXNpYmxlID09PSB0cnVlO1xuXHQgICAgdGhpcy5heGlzLnkuZm9yY2VWaXNpYmxlID0gdGhpcy5vcHRpb25zLmZvcmNlVmlzaWJsZSA9PT0gJ3knIHx8IHRoaXMub3B0aW9ucy5mb3JjZVZpc2libGUgPT09IHRydWU7XG5cdCAgICB0aGlzLmhpZGVOYXRpdmVTY3JvbGxiYXIoKTsgLy8gU2V0IGlzT3ZlcmZsb3dpbmcgdG8gZmFsc2UgaWYgc2Nyb2xsYmFyIGlzIG5vdCBuZWNlc3NhcnkgKGNvbnRlbnQgaXMgc2hvcnRlciB0aGFuIG9mZnNldClcblxuXHQgICAgdmFyIG9mZnNldEZvclhTY3JvbGxiYXIgPSB0aGlzLmF4aXMueC5pc092ZXJmbG93aW5nID8gdGhpcy5zY3JvbGxiYXJXaWR0aCA6IDA7XG5cdCAgICB2YXIgb2Zmc2V0Rm9yWVNjcm9sbGJhciA9IHRoaXMuYXhpcy55LmlzT3ZlcmZsb3dpbmcgPyB0aGlzLnNjcm9sbGJhcldpZHRoIDogMDtcblx0ICAgIHRoaXMuYXhpcy54LmlzT3ZlcmZsb3dpbmcgPSB0aGlzLmF4aXMueC5pc092ZXJmbG93aW5nICYmIGNvbnRlbnRFbFNjcm9sbFdpZHRoID4gY29udGVudFdyYXBwZXJFbE9mZnNldFdpZHRoIC0gb2Zmc2V0Rm9yWVNjcm9sbGJhcjtcblx0ICAgIHRoaXMuYXhpcy55LmlzT3ZlcmZsb3dpbmcgPSB0aGlzLmF4aXMueS5pc092ZXJmbG93aW5nICYmIGNvbnRlbnRFbFNjcm9sbEhlaWdodCA+IGNvbnRlbnRXcmFwcGVyRWxPZmZzZXRIZWlnaHQgLSBvZmZzZXRGb3JYU2Nyb2xsYmFyO1xuXHQgICAgdGhpcy5heGlzLnguc2Nyb2xsYmFyLnNpemUgPSB0aGlzLmdldFNjcm9sbGJhclNpemUoJ3gnKTtcblx0ICAgIHRoaXMuYXhpcy55LnNjcm9sbGJhci5zaXplID0gdGhpcy5nZXRTY3JvbGxiYXJTaXplKCd5Jyk7XG5cdCAgICB0aGlzLmF4aXMueC5zY3JvbGxiYXIuZWwuc3R5bGUud2lkdGggPSB0aGlzLmF4aXMueC5zY3JvbGxiYXIuc2l6ZSArIFwicHhcIjtcblx0ICAgIHRoaXMuYXhpcy55LnNjcm9sbGJhci5lbC5zdHlsZS5oZWlnaHQgPSB0aGlzLmF4aXMueS5zY3JvbGxiYXIuc2l6ZSArIFwicHhcIjtcblx0ICAgIHRoaXMucG9zaXRpb25TY3JvbGxiYXIoJ3gnKTtcblx0ICAgIHRoaXMucG9zaXRpb25TY3JvbGxiYXIoJ3knKTtcblx0ICAgIHRoaXMudG9nZ2xlVHJhY2tWaXNpYmlsaXR5KCd4Jyk7XG5cdCAgICB0aGlzLnRvZ2dsZVRyYWNrVmlzaWJpbGl0eSgneScpO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBDYWxjdWxhdGUgc2Nyb2xsYmFyIHNpemVcblx0ICAgKi9cblx0ICA7XG5cblx0ICBfcHJvdG8uZ2V0U2Nyb2xsYmFyU2l6ZSA9IGZ1bmN0aW9uIGdldFNjcm9sbGJhclNpemUoYXhpcykge1xuXHQgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkge1xuXHQgICAgICBheGlzID0gJ3knO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoIXRoaXMuYXhpc1theGlzXS5pc092ZXJmbG93aW5nKSB7XG5cdCAgICAgIHJldHVybiAwO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgY29udGVudFNpemUgPSB0aGlzLmNvbnRlbnRFbFt0aGlzLmF4aXNbYXhpc10uc2Nyb2xsU2l6ZUF0dHJdO1xuXHQgICAgdmFyIHRyYWNrU2l6ZSA9IHRoaXMuYXhpc1theGlzXS50cmFjay5lbFt0aGlzLmF4aXNbYXhpc10ub2Zmc2V0U2l6ZUF0dHJdO1xuXHQgICAgdmFyIHNjcm9sbGJhclNpemU7XG5cdCAgICB2YXIgc2Nyb2xsYmFyUmF0aW8gPSB0cmFja1NpemUgLyBjb250ZW50U2l6ZTsgLy8gQ2FsY3VsYXRlIG5ldyBoZWlnaHQvcG9zaXRpb24gb2YgZHJhZyBoYW5kbGUuXG5cblx0ICAgIHNjcm9sbGJhclNpemUgPSBNYXRoLm1heCh+fihzY3JvbGxiYXJSYXRpbyAqIHRyYWNrU2l6ZSksIHRoaXMub3B0aW9ucy5zY3JvbGxiYXJNaW5TaXplKTtcblxuXHQgICAgaWYgKHRoaXMub3B0aW9ucy5zY3JvbGxiYXJNYXhTaXplKSB7XG5cdCAgICAgIHNjcm9sbGJhclNpemUgPSBNYXRoLm1pbihzY3JvbGxiYXJTaXplLCB0aGlzLm9wdGlvbnMuc2Nyb2xsYmFyTWF4U2l6ZSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBzY3JvbGxiYXJTaXplO1xuXHQgIH07XG5cblx0ICBfcHJvdG8ucG9zaXRpb25TY3JvbGxiYXIgPSBmdW5jdGlvbiBwb3NpdGlvblNjcm9sbGJhcihheGlzKSB7XG5cdCAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIGF4aXMgPSAneSc7XG5cdCAgICB9XG5cblx0ICAgIGlmICghdGhpcy5heGlzW2F4aXNdLmlzT3ZlcmZsb3dpbmcpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgY29udGVudFNpemUgPSB0aGlzLmNvbnRlbnRXcmFwcGVyRWxbdGhpcy5heGlzW2F4aXNdLnNjcm9sbFNpemVBdHRyXTtcblx0ICAgIHZhciB0cmFja1NpemUgPSB0aGlzLmF4aXNbYXhpc10udHJhY2suZWxbdGhpcy5heGlzW2F4aXNdLm9mZnNldFNpemVBdHRyXTtcblx0ICAgIHZhciBob3N0U2l6ZSA9IHBhcnNlSW50KHRoaXMuZWxTdHlsZXNbdGhpcy5heGlzW2F4aXNdLnNpemVBdHRyXSwgMTApO1xuXHQgICAgdmFyIHNjcm9sbGJhciA9IHRoaXMuYXhpc1theGlzXS5zY3JvbGxiYXI7XG5cdCAgICB2YXIgc2Nyb2xsT2Zmc2V0ID0gdGhpcy5jb250ZW50V3JhcHBlckVsW3RoaXMuYXhpc1theGlzXS5zY3JvbGxPZmZzZXRBdHRyXTtcblx0ICAgIHNjcm9sbE9mZnNldCA9IGF4aXMgPT09ICd4JyAmJiB0aGlzLmlzUnRsICYmIFNpbXBsZUJhci5nZXRSdGxIZWxwZXJzKCkuaXNSdGxTY3JvbGxpbmdJbnZlcnRlZCA/IC1zY3JvbGxPZmZzZXQgOiBzY3JvbGxPZmZzZXQ7XG5cdCAgICB2YXIgc2Nyb2xsUG91cmNlbnQgPSBzY3JvbGxPZmZzZXQgLyAoY29udGVudFNpemUgLSBob3N0U2l6ZSk7XG5cdCAgICB2YXIgaGFuZGxlT2Zmc2V0ID0gfn4oKHRyYWNrU2l6ZSAtIHNjcm9sbGJhci5zaXplKSAqIHNjcm9sbFBvdXJjZW50KTtcblx0ICAgIGhhbmRsZU9mZnNldCA9IGF4aXMgPT09ICd4JyAmJiB0aGlzLmlzUnRsICYmIFNpbXBsZUJhci5nZXRSdGxIZWxwZXJzKCkuaXNSdGxTY3JvbGxiYXJJbnZlcnRlZCA/IGhhbmRsZU9mZnNldCArICh0cmFja1NpemUgLSBzY3JvbGxiYXIuc2l6ZSkgOiBoYW5kbGVPZmZzZXQ7XG5cdCAgICBzY3JvbGxiYXIuZWwuc3R5bGUudHJhbnNmb3JtID0gYXhpcyA9PT0gJ3gnID8gXCJ0cmFuc2xhdGUzZChcIiArIGhhbmRsZU9mZnNldCArIFwicHgsIDAsIDApXCIgOiBcInRyYW5zbGF0ZTNkKDAsIFwiICsgaGFuZGxlT2Zmc2V0ICsgXCJweCwgMClcIjtcblx0ICB9O1xuXG5cdCAgX3Byb3RvLnRvZ2dsZVRyYWNrVmlzaWJpbGl0eSA9IGZ1bmN0aW9uIHRvZ2dsZVRyYWNrVmlzaWJpbGl0eShheGlzKSB7XG5cdCAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIGF4aXMgPSAneSc7XG5cdCAgICB9XG5cblx0ICAgIHZhciB0cmFjayA9IHRoaXMuYXhpc1theGlzXS50cmFjay5lbDtcblx0ICAgIHZhciBzY3JvbGxiYXIgPSB0aGlzLmF4aXNbYXhpc10uc2Nyb2xsYmFyLmVsO1xuXG5cdCAgICBpZiAodGhpcy5heGlzW2F4aXNdLmlzT3ZlcmZsb3dpbmcgfHwgdGhpcy5heGlzW2F4aXNdLmZvcmNlVmlzaWJsZSkge1xuXHQgICAgICB0cmFjay5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuXHQgICAgICB0aGlzLmNvbnRlbnRXcmFwcGVyRWwuc3R5bGVbdGhpcy5heGlzW2F4aXNdLm92ZXJmbG93QXR0cl0gPSAnc2Nyb2xsJztcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRyYWNrLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcblx0ICAgICAgdGhpcy5jb250ZW50V3JhcHBlckVsLnN0eWxlW3RoaXMuYXhpc1theGlzXS5vdmVyZmxvd0F0dHJdID0gJ2hpZGRlbic7XG5cdCAgICB9IC8vIEV2ZW4gaWYgZm9yY2VWaXNpYmxlIGlzIGVuYWJsZWQsIHNjcm9sbGJhciBpdHNlbGYgc2hvdWxkIGJlIGhpZGRlblxuXG5cblx0ICAgIGlmICh0aGlzLmF4aXNbYXhpc10uaXNPdmVyZmxvd2luZykge1xuXHQgICAgICBzY3JvbGxiYXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBzY3JvbGxiYXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgX3Byb3RvLmhpZGVOYXRpdmVTY3JvbGxiYXIgPSBmdW5jdGlvbiBoaWRlTmF0aXZlU2Nyb2xsYmFyKCkge1xuXHQgICAgdGhpcy5vZmZzZXRFbC5zdHlsZVt0aGlzLmlzUnRsID8gJ2xlZnQnIDogJ3JpZ2h0J10gPSB0aGlzLmF4aXMueS5pc092ZXJmbG93aW5nIHx8IHRoaXMuYXhpcy55LmZvcmNlVmlzaWJsZSA/IFwiLVwiICsgdGhpcy5zY3JvbGxiYXJXaWR0aCArIFwicHhcIiA6IDA7XG5cdCAgICB0aGlzLm9mZnNldEVsLnN0eWxlLmJvdHRvbSA9IHRoaXMuYXhpcy54LmlzT3ZlcmZsb3dpbmcgfHwgdGhpcy5heGlzLnguZm9yY2VWaXNpYmxlID8gXCItXCIgKyB0aGlzLnNjcm9sbGJhcldpZHRoICsgXCJweFwiIDogMDtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogT24gc2Nyb2xsIGV2ZW50IGhhbmRsaW5nXG5cdCAgICovXG5cdCAgO1xuXG5cdCAgX3Byb3RvLm9uTW91c2VNb3ZlRm9yQXhpcyA9IGZ1bmN0aW9uIG9uTW91c2VNb3ZlRm9yQXhpcyhheGlzKSB7XG5cdCAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIGF4aXMgPSAneSc7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuYXhpc1theGlzXS50cmFjay5yZWN0ID0gdGhpcy5heGlzW2F4aXNdLnRyYWNrLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHQgICAgdGhpcy5heGlzW2F4aXNdLnNjcm9sbGJhci5yZWN0ID0gdGhpcy5heGlzW2F4aXNdLnNjcm9sbGJhci5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0ICAgIHZhciBpc1dpdGhpblNjcm9sbGJhckJvdW5kc1ggPSB0aGlzLmlzV2l0aGluQm91bmRzKHRoaXMuYXhpc1theGlzXS5zY3JvbGxiYXIucmVjdCk7XG5cblx0ICAgIGlmIChpc1dpdGhpblNjcm9sbGJhckJvdW5kc1gpIHtcblx0ICAgICAgdGhpcy5heGlzW2F4aXNdLnNjcm9sbGJhci5lbC5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lcy5ob3Zlcik7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLmF4aXNbYXhpc10uc2Nyb2xsYmFyLmVsLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5jbGFzc05hbWVzLmhvdmVyKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMuaXNXaXRoaW5Cb3VuZHModGhpcy5heGlzW2F4aXNdLnRyYWNrLnJlY3QpKSB7XG5cdCAgICAgIHRoaXMuc2hvd1Njcm9sbGJhcihheGlzKTtcblx0ICAgICAgdGhpcy5heGlzW2F4aXNdLnRyYWNrLmVsLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLmhvdmVyKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMuYXhpc1theGlzXS50cmFjay5lbC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuY2xhc3NOYW1lcy5ob3Zlcik7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIF9wcm90by5vbk1vdXNlTGVhdmVGb3JBeGlzID0gZnVuY3Rpb24gb25Nb3VzZUxlYXZlRm9yQXhpcyhheGlzKSB7XG5cdCAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIGF4aXMgPSAneSc7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuYXhpc1theGlzXS50cmFjay5lbC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuY2xhc3NOYW1lcy5ob3Zlcik7XG5cdCAgICB0aGlzLmF4aXNbYXhpc10uc2Nyb2xsYmFyLmVsLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5jbGFzc05hbWVzLmhvdmVyKTtcblx0ICB9O1xuXG5cdCAgLyoqXG5cdCAgICogU2hvdyBzY3JvbGxiYXJcblx0ICAgKi9cblx0ICBfcHJvdG8uc2hvd1Njcm9sbGJhciA9IGZ1bmN0aW9uIHNob3dTY3JvbGxiYXIoYXhpcykge1xuXHQgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkge1xuXHQgICAgICBheGlzID0gJ3knO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgc2Nyb2xsYmFyID0gdGhpcy5heGlzW2F4aXNdLnNjcm9sbGJhci5lbDtcblxuXHQgICAgaWYgKCF0aGlzLmF4aXNbYXhpc10uaXNWaXNpYmxlKSB7XG5cdCAgICAgIHNjcm9sbGJhci5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lcy52aXNpYmxlKTtcblx0ICAgICAgdGhpcy5heGlzW2F4aXNdLmlzVmlzaWJsZSA9IHRydWU7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b0hpZGUpIHtcblx0ICAgICAgdGhpcy5oaWRlU2Nyb2xsYmFycygpO1xuXHQgICAgfVxuXHQgIH1cblx0ICAvKipcblx0ICAgKiBIaWRlIFNjcm9sbGJhclxuXHQgICAqL1xuXHQgIDtcblxuXHQgIC8qKlxuXHQgICAqIG9uIHNjcm9sbGJhciBoYW5kbGUgZHJhZyBtb3ZlbWVudCBzdGFydHNcblx0ICAgKi9cblx0ICBfcHJvdG8ub25EcmFnU3RhcnQgPSBmdW5jdGlvbiBvbkRyYWdTdGFydChlLCBheGlzKSB7XG5cdCAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIGF4aXMgPSAneSc7XG5cdCAgICB9XG5cblx0ICAgIHZhciBlbERvY3VtZW50ID0gZ2V0RWxlbWVudERvY3VtZW50KHRoaXMuZWwpO1xuXHQgICAgdmFyIGVsV2luZG93ID0gZ2V0RWxlbWVudFdpbmRvdyh0aGlzLmVsKTtcblx0ICAgIHZhciBzY3JvbGxiYXIgPSB0aGlzLmF4aXNbYXhpc10uc2Nyb2xsYmFyOyAvLyBNZWFzdXJlIGhvdyBmYXIgdGhlIHVzZXIncyBtb3VzZSBpcyBmcm9tIHRoZSB0b3Agb2YgdGhlIHNjcm9sbGJhciBkcmFnIGhhbmRsZS5cblxuXHQgICAgdmFyIGV2ZW50T2Zmc2V0ID0gYXhpcyA9PT0gJ3knID8gZS5wYWdlWSA6IGUucGFnZVg7XG5cdCAgICB0aGlzLmF4aXNbYXhpc10uZHJhZ09mZnNldCA9IGV2ZW50T2Zmc2V0IC0gc2Nyb2xsYmFyLnJlY3RbdGhpcy5heGlzW2F4aXNdLm9mZnNldEF0dHJdO1xuXHQgICAgdGhpcy5kcmFnZ2VkQXhpcyA9IGF4aXM7XG5cdCAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLmRyYWdnaW5nKTtcblx0ICAgIGVsRG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5kcmFnLCB0cnVlKTtcblx0ICAgIGVsRG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25FbmREcmFnLCB0cnVlKTtcblxuXHQgICAgaWYgKHRoaXMucmVtb3ZlUHJldmVudENsaWNrSWQgPT09IG51bGwpIHtcblx0ICAgICAgZWxEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMucHJldmVudENsaWNrLCB0cnVlKTtcblx0ICAgICAgZWxEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIHRoaXMucHJldmVudENsaWNrLCB0cnVlKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGVsV2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJlbW92ZVByZXZlbnRDbGlja0lkKTtcblx0ICAgICAgdGhpcy5yZW1vdmVQcmV2ZW50Q2xpY2tJZCA9IG51bGw7XG5cdCAgICB9XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIERyYWcgc2Nyb2xsYmFyIGhhbmRsZVxuXHQgICAqL1xuXHQgIDtcblxuXHQgIF9wcm90by5vblRyYWNrQ2xpY2sgPSBmdW5jdGlvbiBvblRyYWNrQ2xpY2soZSwgYXhpcykge1xuXHQgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cblx0ICAgIGlmIChheGlzID09PSB2b2lkIDApIHtcblx0ICAgICAgYXhpcyA9ICd5Jztcblx0ICAgIH1cblxuXHQgICAgaWYgKCF0aGlzLm9wdGlvbnMuY2xpY2tPblRyYWNrKSByZXR1cm47XG5cdCAgICB2YXIgZWxXaW5kb3cgPSBnZXRFbGVtZW50V2luZG93KHRoaXMuZWwpO1xuXHQgICAgdGhpcy5heGlzW2F4aXNdLnNjcm9sbGJhci5yZWN0ID0gdGhpcy5heGlzW2F4aXNdLnNjcm9sbGJhci5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0ICAgIHZhciBzY3JvbGxiYXIgPSB0aGlzLmF4aXNbYXhpc10uc2Nyb2xsYmFyO1xuXHQgICAgdmFyIHNjcm9sbGJhck9mZnNldCA9IHNjcm9sbGJhci5yZWN0W3RoaXMuYXhpc1theGlzXS5vZmZzZXRBdHRyXTtcblx0ICAgIHZhciBob3N0U2l6ZSA9IHBhcnNlSW50KHRoaXMuZWxTdHlsZXNbdGhpcy5heGlzW2F4aXNdLnNpemVBdHRyXSwgMTApO1xuXHQgICAgdmFyIHNjcm9sbGVkID0gdGhpcy5jb250ZW50V3JhcHBlckVsW3RoaXMuYXhpc1theGlzXS5zY3JvbGxPZmZzZXRBdHRyXTtcblx0ICAgIHZhciB0ID0gYXhpcyA9PT0gJ3knID8gdGhpcy5tb3VzZVkgLSBzY3JvbGxiYXJPZmZzZXQgOiB0aGlzLm1vdXNlWCAtIHNjcm9sbGJhck9mZnNldDtcblx0ICAgIHZhciBkaXIgPSB0IDwgMCA/IC0xIDogMTtcblx0ICAgIHZhciBzY3JvbGxTaXplID0gZGlyID09PSAtMSA/IHNjcm9sbGVkIC0gaG9zdFNpemUgOiBzY3JvbGxlZCArIGhvc3RTaXplO1xuXG5cdCAgICB2YXIgc2Nyb2xsVG8gPSBmdW5jdGlvbiBzY3JvbGxUbygpIHtcblx0ICAgICAgaWYgKGRpciA9PT0gLTEpIHtcblx0ICAgICAgICBpZiAoc2Nyb2xsZWQgPiBzY3JvbGxTaXplKSB7XG5cdCAgICAgICAgICB2YXIgX3RoaXM0JGNvbnRlbnRXcmFwcGVyO1xuXG5cdCAgICAgICAgICBzY3JvbGxlZCAtPSBfdGhpczQub3B0aW9ucy5jbGlja09uVHJhY2tTcGVlZDtcblxuXHQgICAgICAgICAgX3RoaXM0LmNvbnRlbnRXcmFwcGVyRWwuc2Nyb2xsVG8oKF90aGlzNCRjb250ZW50V3JhcHBlciA9IHt9LCBfdGhpczQkY29udGVudFdyYXBwZXJbX3RoaXM0LmF4aXNbYXhpc10ub2Zmc2V0QXR0cl0gPSBzY3JvbGxlZCwgX3RoaXM0JGNvbnRlbnRXcmFwcGVyKSk7XG5cblx0ICAgICAgICAgIGVsV2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShzY3JvbGxUbyk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGlmIChzY3JvbGxlZCA8IHNjcm9sbFNpemUpIHtcblx0ICAgICAgICAgIHZhciBfdGhpczQkY29udGVudFdyYXBwZXIyO1xuXG5cdCAgICAgICAgICBzY3JvbGxlZCArPSBfdGhpczQub3B0aW9ucy5jbGlja09uVHJhY2tTcGVlZDtcblxuXHQgICAgICAgICAgX3RoaXM0LmNvbnRlbnRXcmFwcGVyRWwuc2Nyb2xsVG8oKF90aGlzNCRjb250ZW50V3JhcHBlcjIgPSB7fSwgX3RoaXM0JGNvbnRlbnRXcmFwcGVyMltfdGhpczQuYXhpc1theGlzXS5vZmZzZXRBdHRyXSA9IHNjcm9sbGVkLCBfdGhpczQkY29udGVudFdyYXBwZXIyKSk7XG5cblx0ICAgICAgICAgIGVsV2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShzY3JvbGxUbyk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICBzY3JvbGxUbygpO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBHZXR0ZXIgZm9yIGNvbnRlbnQgZWxlbWVudFxuXHQgICAqL1xuXHQgIDtcblxuXHQgIF9wcm90by5nZXRDb250ZW50RWxlbWVudCA9IGZ1bmN0aW9uIGdldENvbnRlbnRFbGVtZW50KCkge1xuXHQgICAgcmV0dXJuIHRoaXMuY29udGVudEVsO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBHZXR0ZXIgZm9yIG9yaWdpbmFsIHNjcm9sbGluZyBlbGVtZW50XG5cdCAgICovXG5cdCAgO1xuXG5cdCAgX3Byb3RvLmdldFNjcm9sbEVsZW1lbnQgPSBmdW5jdGlvbiBnZXRTY3JvbGxFbGVtZW50KCkge1xuXHQgICAgcmV0dXJuIHRoaXMuY29udGVudFdyYXBwZXJFbDtcblx0ICB9O1xuXG5cdCAgX3Byb3RvLmdldFNjcm9sbGJhcldpZHRoID0gZnVuY3Rpb24gZ2V0U2Nyb2xsYmFyV2lkdGgoKSB7XG5cdCAgICAvLyBUcnkvY2F0Y2ggZm9yIEZGIDU2IHRocm93aW5nIG9uIHVuZGVmaW5lZCBjb21wdXRlZFN0eWxlc1xuXHQgICAgdHJ5IHtcblx0ICAgICAgLy8gRGV0ZWN0IGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHNjcm9sbGJhciBzdHlsaW5nIGFuZCBkbyBub3QgY2FsY3VsYXRlXG5cdCAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKHRoaXMuY29udGVudFdyYXBwZXJFbCwgJzo6LXdlYmtpdC1zY3JvbGxiYXInKS5kaXNwbGF5ID09PSAnbm9uZScgfHwgJ3Njcm9sbGJhcldpZHRoJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgfHwgJy1tcy1vdmVyZmxvdy1zdHlsZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKSB7XG5cdCAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIHNjcm9sbGJhcldpZHRoKHRoaXMuZWwpO1xuXHQgICAgICB9XG5cdCAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgIHJldHVybiBzY3JvbGxiYXJXaWR0aCh0aGlzLmVsKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgX3Byb3RvLnJlbW92ZUxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycygpIHtcblx0ICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG5cdCAgICB2YXIgZWxXaW5kb3cgPSBnZXRFbGVtZW50V2luZG93KHRoaXMuZWwpOyAvLyBFdmVudCBsaXN0ZW5lcnNcblxuXHQgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvSGlkZSkge1xuXHQgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLm9uTW91c2VFbnRlcik7XG5cdCAgICB9XG5cblx0ICAgIFsnbW91c2Vkb3duJywgJ2NsaWNrJywgJ2RibGNsaWNrJ10uZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuXHQgICAgICBfdGhpczUuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLCBfdGhpczUub25Qb2ludGVyRXZlbnQsIHRydWUpO1xuXHQgICAgfSk7XG5cdCAgICBbJ3RvdWNoc3RhcnQnLCAndG91Y2hlbmQnLCAndG91Y2htb3ZlJ10uZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuXHQgICAgICBfdGhpczUuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLCBfdGhpczUub25Qb2ludGVyRXZlbnQsIHtcblx0ICAgICAgICBjYXB0dXJlOiB0cnVlLFxuXHQgICAgICAgIHBhc3NpdmU6IHRydWVcblx0ICAgICAgfSk7XG5cdCAgICB9KTtcblx0ICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZSk7XG5cdCAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uTW91c2VMZWF2ZSk7XG5cblx0ICAgIGlmICh0aGlzLmNvbnRlbnRXcmFwcGVyRWwpIHtcblx0ICAgICAgdGhpcy5jb250ZW50V3JhcHBlckVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMub25TY3JvbGwpO1xuXHQgICAgfVxuXG5cdCAgICBlbFdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLm9uV2luZG93UmVzaXplKTtcblxuXHQgICAgaWYgKHRoaXMubXV0YXRpb25PYnNlcnZlcikge1xuXHQgICAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5yZXNpemVPYnNlcnZlcikge1xuXHQgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcblx0ICAgIH0gLy8gQ2FuY2VsIGFsbCBkZWJvdW5jZWQgZnVuY3Rpb25zXG5cblxuXHQgICAgdGhpcy5yZWNhbGN1bGF0ZS5jYW5jZWwoKTtcblx0ICAgIHRoaXMub25Nb3VzZU1vdmUuY2FuY2VsKCk7XG5cdCAgICB0aGlzLmhpZGVTY3JvbGxiYXJzLmNhbmNlbCgpO1xuXHQgICAgdGhpcy5vbldpbmRvd1Jlc2l6ZS5jYW5jZWwoKTtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogVW5Nb3VudCBtdXRhdGlvbiBvYnNlcnZlciBhbmQgZGVsZXRlIFNpbXBsZUJhciBpbnN0YW5jZSBmcm9tIERPTSBlbGVtZW50XG5cdCAgICovXG5cdCAgO1xuXG5cdCAgX3Byb3RvLnVuTW91bnQgPSBmdW5jdGlvbiB1bk1vdW50KCkge1xuXHQgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMoKTtcblx0ICAgIFNpbXBsZUJhci5pbnN0YW5jZXMuZGVsZXRlKHRoaXMuZWwpO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBDaGVjayBpZiBtb3VzZSBpcyB3aXRoaW4gYm91bmRzXG5cdCAgICovXG5cdCAgO1xuXG5cdCAgX3Byb3RvLmlzV2l0aGluQm91bmRzID0gZnVuY3Rpb24gaXNXaXRoaW5Cb3VuZHMoYmJveCkge1xuXHQgICAgcmV0dXJuIHRoaXMubW91c2VYID49IGJib3gubGVmdCAmJiB0aGlzLm1vdXNlWCA8PSBiYm94LmxlZnQgKyBiYm94LndpZHRoICYmIHRoaXMubW91c2VZID49IGJib3gudG9wICYmIHRoaXMubW91c2VZIDw9IGJib3gudG9wICsgYmJveC5oZWlnaHQ7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIEZpbmQgZWxlbWVudCBjaGlsZHJlbiBtYXRjaGVzIHF1ZXJ5XG5cdCAgICovXG5cdCAgO1xuXG5cdCAgX3Byb3RvLmZpbmRDaGlsZCA9IGZ1bmN0aW9uIGZpbmRDaGlsZChlbCwgcXVlcnkpIHtcblx0ICAgIHZhciBtYXRjaGVzID0gZWwubWF0Y2hlcyB8fCBlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZWwubW96TWF0Y2hlc1NlbGVjdG9yIHx8IGVsLm1zTWF0Y2hlc1NlbGVjdG9yO1xuXHQgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChlbC5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG5cdCAgICAgIHJldHVybiBtYXRjaGVzLmNhbGwoY2hpbGQsIHF1ZXJ5KTtcblx0ICAgIH0pWzBdO1xuXHQgIH07XG5cblx0ICByZXR1cm4gU2ltcGxlQmFyO1xuXHR9KCk7XG5cblx0U2ltcGxlQmFyLmRlZmF1bHRPcHRpb25zID0ge1xuXHQgIGF1dG9IaWRlOiB0cnVlLFxuXHQgIGZvcmNlVmlzaWJsZTogZmFsc2UsXG5cdCAgY2xpY2tPblRyYWNrOiB0cnVlLFxuXHQgIGNsaWNrT25UcmFja1NwZWVkOiA0MCxcblx0ICBjbGFzc05hbWVzOiB7XG5cdCAgICBjb250ZW50RWw6ICdzaW1wbGViYXItY29udGVudCcsXG5cdCAgICBjb250ZW50V3JhcHBlcjogJ3NpbXBsZWJhci1jb250ZW50LXdyYXBwZXInLFxuXHQgICAgb2Zmc2V0OiAnc2ltcGxlYmFyLW9mZnNldCcsXG5cdCAgICBtYXNrOiAnc2ltcGxlYmFyLW1hc2snLFxuXHQgICAgd3JhcHBlcjogJ3NpbXBsZWJhci13cmFwcGVyJyxcblx0ICAgIHBsYWNlaG9sZGVyOiAnc2ltcGxlYmFyLXBsYWNlaG9sZGVyJyxcblx0ICAgIHNjcm9sbGJhcjogJ3NpbXBsZWJhci1zY3JvbGxiYXInLFxuXHQgICAgdHJhY2s6ICdzaW1wbGViYXItdHJhY2snLFxuXHQgICAgaGVpZ2h0QXV0b09ic2VydmVyV3JhcHBlckVsOiAnc2ltcGxlYmFyLWhlaWdodC1hdXRvLW9ic2VydmVyLXdyYXBwZXInLFxuXHQgICAgaGVpZ2h0QXV0b09ic2VydmVyRWw6ICdzaW1wbGViYXItaGVpZ2h0LWF1dG8tb2JzZXJ2ZXInLFxuXHQgICAgdmlzaWJsZTogJ3NpbXBsZWJhci12aXNpYmxlJyxcblx0ICAgIGhvcml6b250YWw6ICdzaW1wbGViYXItaG9yaXpvbnRhbCcsXG5cdCAgICB2ZXJ0aWNhbDogJ3NpbXBsZWJhci12ZXJ0aWNhbCcsXG5cdCAgICBob3ZlcjogJ3NpbXBsZWJhci1ob3ZlcicsXG5cdCAgICBkcmFnZ2luZzogJ3NpbXBsZWJhci1kcmFnZ2luZydcblx0ICB9LFxuXHQgIHNjcm9sbGJhck1pblNpemU6IDI1LFxuXHQgIHNjcm9sbGJhck1heFNpemU6IDAsXG5cdCAgdGltZW91dDogMTAwMFxuXHR9O1xuXHRTaW1wbGVCYXIuaW5zdGFuY2VzID0gbmV3IFdlYWtNYXAoKTtcblxuXHRTaW1wbGVCYXIuaW5pdERPTUxvYWRlZEVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuXHQgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB0aGlzLmluaXRET01Mb2FkZWRFbGVtZW50cyk7XG5cdCAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLmluaXRET01Mb2FkZWRFbGVtZW50cyk7XG5cdCAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zaW1wbGViYXJdJyksIGZ1bmN0aW9uIChlbCkge1xuXHQgICAgaWYgKGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zaW1wbGViYXInKSAhPT0gJ2luaXQnICYmICFTaW1wbGVCYXIuaW5zdGFuY2VzLmhhcyhlbCkpIG5ldyBTaW1wbGVCYXIoZWwsIGdldE9wdGlvbnMoZWwuYXR0cmlidXRlcykpO1xuXHQgIH0pO1xuXHR9O1xuXG5cdFNpbXBsZUJhci5yZW1vdmVPYnNlcnZlciA9IGZ1bmN0aW9uICgpIHtcblx0ICB0aGlzLmdsb2JhbE9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcblx0fTtcblxuXHRTaW1wbGVCYXIuaW5pdEh0bWxBcGkgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdGhpcy5pbml0RE9NTG9hZGVkRWxlbWVudHMgPSB0aGlzLmluaXRET01Mb2FkZWRFbGVtZW50cy5iaW5kKHRoaXMpOyAvLyBNdXRhdGlvbk9ic2VydmVyIGlzIElFMTErXG5cblx0ICBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAvLyBNdXRhdGlvbiBvYnNlcnZlciB0byBvYnNlcnZlIGR5bmFtaWNhbGx5IGFkZGVkIGVsZW1lbnRzXG5cdCAgICB0aGlzLmdsb2JhbE9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoU2ltcGxlQmFyLmhhbmRsZU11dGF0aW9ucyk7XG5cdCAgICB0aGlzLmdsb2JhbE9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQsIHtcblx0ICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuXHQgICAgICBzdWJ0cmVlOiB0cnVlXG5cdCAgICB9KTtcblx0ICB9IC8vIFRha2VuIGZyb20galF1ZXJ5IGByZWFkeWAgZnVuY3Rpb25cblx0ICAvLyBJbnN0YW50aWF0ZSBlbGVtZW50cyBhbHJlYWR5IHByZXNlbnQgb24gdGhlIHBhZ2VcblxuXG5cdCAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2xvYWRpbmcnICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwpIHtcblx0ICAgIC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSBpbml0XG5cdCAgICB3aW5kb3cuc2V0VGltZW91dCh0aGlzLmluaXRET01Mb2FkZWRFbGVtZW50cyk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB0aGlzLmluaXRET01Mb2FkZWRFbGVtZW50cyk7XG5cdCAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuaW5pdERPTUxvYWRlZEVsZW1lbnRzKTtcblx0ICB9XG5cdH07XG5cblx0U2ltcGxlQmFyLmhhbmRsZU11dGF0aW9ucyA9IGZ1bmN0aW9uIChtdXRhdGlvbnMpIHtcblx0ICBtdXRhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAobXV0YXRpb24pIHtcblx0ICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwobXV0YXRpb24uYWRkZWROb2RlcywgZnVuY3Rpb24gKGFkZGVkTm9kZSkge1xuXHQgICAgICBpZiAoYWRkZWROb2RlLm5vZGVUeXBlID09PSAxKSB7XG5cdCAgICAgICAgaWYgKGFkZGVkTm9kZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtc2ltcGxlYmFyJykpIHtcblx0ICAgICAgICAgICFTaW1wbGVCYXIuaW5zdGFuY2VzLmhhcyhhZGRlZE5vZGUpICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyhhZGRlZE5vZGUpICYmIG5ldyBTaW1wbGVCYXIoYWRkZWROb2RlLCBnZXRPcHRpb25zKGFkZGVkTm9kZS5hdHRyaWJ1dGVzKSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoYWRkZWROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNpbXBsZWJhcl0nKSwgZnVuY3Rpb24gKGVsKSB7XG5cdCAgICAgICAgICAgIGlmIChlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2ltcGxlYmFyJykgIT09ICdpbml0JyAmJiAhU2ltcGxlQmFyLmluc3RhbmNlcy5oYXMoZWwpICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyhlbCkpIG5ldyBTaW1wbGVCYXIoZWwsIGdldE9wdGlvbnMoZWwuYXR0cmlidXRlcykpO1xuXHQgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwobXV0YXRpb24ucmVtb3ZlZE5vZGVzLCBmdW5jdGlvbiAocmVtb3ZlZE5vZGUpIHtcblx0ICAgICAgaWYgKHJlbW92ZWROb2RlLm5vZGVUeXBlID09PSAxKSB7XG5cdCAgICAgICAgaWYgKHJlbW92ZWROb2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1zaW1wbGViYXInKSA9PT0gJ2luaXQnKSB7XG5cdCAgICAgICAgICBTaW1wbGVCYXIuaW5zdGFuY2VzLmhhcyhyZW1vdmVkTm9kZSkgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyhyZW1vdmVkTm9kZSkgJiYgU2ltcGxlQmFyLmluc3RhbmNlcy5nZXQocmVtb3ZlZE5vZGUpLnVuTW91bnQoKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChyZW1vdmVkTm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zaW1wbGViYXI9XCJpbml0XCJdJyksIGZ1bmN0aW9uIChlbCkge1xuXHQgICAgICAgICAgICBTaW1wbGVCYXIuaW5zdGFuY2VzLmhhcyhlbCkgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyhlbCkgJiYgU2ltcGxlQmFyLmluc3RhbmNlcy5nZXQoZWwpLnVuTW91bnQoKTtcblx0ICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfSk7XG5cdH07XG5cblx0U2ltcGxlQmFyLmdldE9wdGlvbnMgPSBnZXRPcHRpb25zO1xuXHQvKipcblx0ICogSFRNTCBBUElcblx0ICogQ2FsbGVkIG9ubHkgaW4gYSBicm93c2VyIGVudi5cblx0ICovXG5cblx0aWYgKGNhblVzZURvbSkge1xuXHQgIFNpbXBsZUJhci5pbml0SHRtbEFwaSgpO1xuXHR9XG5cblx0cmV0dXJuIFNpbXBsZUJhcjtcblxufSkpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/simplebar/dist/simplebar.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!"), __webpack_exec__("./node_modules/next/dist/client/router.js"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);